Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The method has 124 lines of code.
Long Method,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The method has 418 lines of code.
Long Method,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The method has 129 lines of code.
Long Method,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The method has 131 lines of code.
Long Method,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The method has 150 lines of code.
Long Method,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The method has 110 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_fast,The method has 101 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The method has 126 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The method has 147 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The method has 424 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The method has 291 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The method has 200 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The method has 154 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The method has 198 lines of code.
Complex Method,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,Cyclomatic complexity of the method is 8
Complex Method,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,Cyclomatic complexity of the method is 37
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,Cyclomatic complexity of the method is 9
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 15
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 21
Complex Method,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The method has 5 parameters. Parameters: subtitleFileName' rawText' videoFileName' name' description
Long Parameter List,Nikse.SubtitleEdit.PluginLogic,IPlugin,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\IPlugin.cs,DoAction,The method has 7 parameters. Parameters: parentForm' subtitle' frameRate' listViewLineSeparatorString' subtitleFileName' videoFileName' rawText
Long Parameter List,Nikse.SubtitleEdit.PluginLogic,OpenSubtitlesUpload,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Plugin.cs,DoAction,The method has 7 parameters. Parameters: parentForm' subtitle' frameRate' listViewLineSeparatorString' subtitleFileName' videoFileName' rawText
Long Parameter List,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The method has 7 parameters. Parameters: subtitle' subtitleFileName' movieFileName' movieFileNameFull' language' fps' encoding
Long Parameter List,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The method has 12 parameters. Parameters: subtitle' subtitleFileName' movieFileName' movieFileNameFull' language' releaseName' idMovieImdb' comment' hearingImpaired' hd' fps' encoding
Long Parameter List,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaInfo,The method has 8 parameters. Parameters: fileName' isValid' hasConstantFrameRate' frameRate' pixelWidth' pixelHeight' millisecsDuration' videoCodec
Long Parameter List,OpenSubtitlesUpload.VideoFormats.Boxes,Minf,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Minf.cs,Minf,The method has 5 parameters. Parameters: fs' maximumLength' timeScale' handlerType' mdia
Long Parameter List,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The method has 5 parameters. Parameters: fs' maximumLength' timeScale' handlerType' mdia
Long Parameter List,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,ComponentAce.Compression.Libs.zlib,Config,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,StaticTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,,The length of the parameter AutoDetectWordsCroatianAndSerbian is 33.
Long Identifier,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,,The length of the parameter AutoDetectWordsSerbianCyrillic is 30.
Long Statement,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.listViewSearchResults.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 157.
Long Statement,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.listViewSearchResults.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.listViewSearchResults_MouseDoubleClick); " is 135.
Long Statement,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.buttonOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.buttonCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,GetCurrentEncoding,The length of the statement  "            if (comboBoxEncoding.Text == Encoding.UTF8.BodyName || comboBoxEncoding.Text == Encoding.UTF8.EncodingName || comboBoxEncoding.Text == "utf-8") " is 143.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,The length of the statement  "                    var res = _api.TryUploadSubtitles(_rawText' textBoxSubtitleFileName.Text' textBoxMovieFileName.Text' _videoFileName' GetLanguageCode()' fps' GetCurrentEncoding()); " is 163.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,The length of the statement  "                        if (_api.UploadSubtitles(_rawText' textBoxSubtitleFileName.Text' textBoxMovieFileName.Text' _videoFileName' GetLanguageCode()' textBoxReleaseName.Text' textBoxImdbId.Text' textBoxComment.Text' textForHi' hd' fps' GetCurrentEncoding())) " is 235.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,GetMovieFileExtensions,The length of the statement  "            return new List<string> { ".avi"' ".mkv"' ".wmv"' ".mpg"' ".mpeg"' ".divx"' ".mp4"' ".asf"' ".flv"' ".mov"' ".m4v"' ".vob"' ".ogv"' ".webm"' ".ts"' ".m2ts" }; " is 158.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,buttonOpenVideo_Click,The length of the statement  "                //Task.Factory.StartNew(SetFrameRateFromVideoFile).ContinueWith((_) => comboBoxFrameRate.SelectedIndex = idx' TaskScheduler.FromCurrentSynchronizationContext()); // where 'idx' is global volatile " is 195.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The length of the statement  "            // Cursor = Cursors.WaitCursor; will Invalid operation exection (Note: Belong to UI thread' the expection won't crash the app 'CAREFUL')  " is 136.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The length of the statement  "                            mkv.GetMatroskaInfo(_videoFileName' ref isValid' ref hasConstantFrameRate' ref frameRate' ref pixelWidth' ref pixelHeight' ref millisecsDuration' ref videoCodec); " is 162.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.buttonUpload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxSubtitleFileName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 156.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelUploadManually.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 161.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelUploadManually.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelUploadManually_LinkClicked); " is 144.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.buttonCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxMovieFileName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 153.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxPassword.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxUserName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.groupBoxLogin.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 149.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelRegister.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 155.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelRegister.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelRegister_LinkClicked); " is 132.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.groupBoxSubtitleInfo.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 156.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelSearchImdb.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelSearchImdb_LinkClicked); " is 136.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxComment.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 150.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxReleaseName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.comboBoxLanguage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 149.
Long Statement,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.labelStatus.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 149.
Long Statement,Nikse.SubtitleEdit.PluginLogic,OpenSubtitlesUpload,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Plugin.cs,DoAction,The length of the statement  "            using (var form = new PluginForm(subtitleFileName' rawText' videoFileName' (this as IPlugin).Name' (this as IPlugin).Description)) " is 130.
Long Statement,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The length of the statement  "                int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not spanish words " is 142.
Long Statement,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The length of the statement  "                int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not italian words " is 142.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,Login,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,Login,The length of the statement  "            Token = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='token']/../value/string").InnerText; " is 128.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,LogOut,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,NoOperation,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subhash']/../value/string").InnerText = subtitleHash; " is 160.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subfilename']/../value/string").InnerText = subtitleFileName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "                doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefps']/../value/double").InnerText = fps; " is 152.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefilename']/../value/string").InnerText = movieFileName; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "                string alreadyInDb = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='alreadyindb']/../value/int").InnerText; " is 144.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='idmovieimdb']/../value/string").InnerText = idMovieImdb; " is 163.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='sublanguageid']/../value/string").InnerText = language; " is 162.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='hearingimpaired']/../value/string").InnerText = hearingImpaired; " is 171.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='highdefinition']/../value/string").InnerText = hd; " is 157.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviereleasename']/../value/string").InnerText = releaseName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subauthorcomment']/../value/string").InnerText = comment; " is 164.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subhash']/../value/string").InnerText = subtitleHash; " is 160.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subfilename']/../value/string").InnerText = subtitleFileName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "                doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefps']/../value/double").InnerText = fps; " is 152.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefilename']/../value/string").InnerText = movieFileName; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subcontent']/../value/string").InnerText = subtitleContent; " is 166.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,GZLib,The length of the statement  "                    using (var gs = new ComponentAce.Compression.Libs.zlib.ZOutputStream(mso' ComponentAce.Compression.Libs.zlib.zlibConst.Z_DEFAULT_COMPRESSION)) " is 142.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchMoviesOnIMDB,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='sublanguageid']/../value/string").InnerText = language; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 156.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 164.
Long Statement,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,Nikse.SubtitleEdit.Logic,Utils,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,GetSettingsFileName,The length of the statement  "                path = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "Subtitle Edit")' "Plugins"); " is 132.
Long Statement,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,FindTrackStartInCluster,The length of the statement  "                        clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize); // Absolute timestamp of the cluster (based on TimecodeScale). " is 126.
Long Statement,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,The length of the statement  "                    if (matroskaId == 0x2AD7B1)// TimecodeScale - u-integer     Timecode scale in nanoseconds (1.000.000 means all timecodes in the segment are expressed in milliseconds). " is 167.
Long Statement,OpenSubtitlesUpload.VideoFormats,MP4,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,GetSubtitleTracks,The length of the statement  "                    if (trak.Mdia != null && (trak.Mdia.IsTextSubtitle || trak.Mdia.IsVobSubSubtitle || trak.Mdia.IsClosedCaption) && trak.Mdia.Minf != null && trak.Mdia.Minf.Stbl != null) " is 168.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The length of the statement  "            return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 | " is 138.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The length of the statement  "            return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 | " is 138.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The length of the statement  "                    textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes " is 159.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The length of the statement  "                if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The length of the statement  "                while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The length of the statement  "            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The length of the statement  "            if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)) " is 123.
Long Statement,ComponentAce.Compression.Libs.zlib,ZStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The length of the statement  "            if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)) " is 191.
Long Statement,ComponentAce.Compression.Libs.zlib,ZStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The length of the statement  "                //System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The conditional expression  "ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047"  is complex.
Complex Conditional,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The conditional expression  "frameRate < 1 && (ext == ".mp4" || ext == ".mov" || ext == ".m4v")"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaId,The conditional expression  "x == Ebml || // ebml header                  x == 0x18538067 || // segment                  x == 0x114D9B74 || // seekhead                  x == 0x1549A966 || // segment info                  x == 0x1654AE6B || // track                  x == 0x1F43B675 || // cluster                  x == 0x1C53BB6B || // Cues                  x == 0x1941A469 || // Attachments                  x == 0x1043A770 || // Chapters                  x == 0x1254C367"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0xEC || // Void                  s == 0xBF || // CRC-32                  s == 0xD7 || // Track number                  s == 0x83 || // Track type                  s == 0xB9 || // Flag enabled                  s == 0x88 || // Flag default                  s == 0x9C || // Flag lacing                  s == 0x4F || // Track Time Code Scale                  s == 0xAA || // CodecDecodeAll                  s == 0xE0 || // Track Video                  s == 0xE1 || // Track Audio                  s == 0x86"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0x73C5 || // TrackUID                  s == 0x55AA || // FlagForced                  s == 0x6DE7 || // MinCache                  s == 0x6DF8 || // MaxCache                  s == 0x55EE || // MaxBlockAdditionID                  s == 0x63A2 || // CodecPrivate                  s == 0x7446 || // AttachmentLink                  s == 0x6D80 || // ContentEncodings                  s == 0x537F || // TrackOffset                  s == 0x6FAB || // TrackOverlay                  s == 0x536E || // Name                  s == 0x6624 || // TrackTranslate                  s == 0x66FC || // TrackTranslateEditionUID                  s == 0x66BF || // TrackTranslateCodec                  s == 0x66A5"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0x23E383 || // Default Duration                  s == 0x22B59C || // Language                  s == 0x258688 || // CodecName                  s == 0x23314F"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The conditional expression  "s == 0xEC || // Void                  s == 0xBF || // CRC-32                  s == 0xB0 || // PixelWidth                  s == 0xBA || // PixelHeight                  s == 0x9A"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The conditional expression  "s == 0x54B0 || // DisplayWidth                  s == 0x54BA || // DisplayHeight                  s == 0x54BA || // DisplayHeight                  s == 0x54AA || // PixelCropButton                  s == 0x54BB || // PixelCropTop                  s == 0x54CC || // PixelCropLeft                  s == 0x54DD || // PixelCropRight                  s == 0x54DD || // PixelCropRight                  s == 0x54B2 || // DisplayUnit                  s == 0x54B3"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The conditional expression  "s == 0x73A4 || // SegmentUID                  s == 0x7384 || // SegmentFilename                  s == 0x4444 || // SegmentFamily                  s == 0x6924 || // ChapterTranslate                  s == 0x69FC || // ChapterTranslateEditionUID                  s == 0x69BF || // ChapterTranslateCodec                  s == 0x69A5 || // ChapterTranslateID                  s == 0x4489 || // Duration                  s == 0x4461 || // DateUTC                  s == 0x7BA9 || // Title                  s == 0x4D80 || // MuxingApp                  s == 0x5741"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The conditional expression  "s == 0x3CB923 || // PrevUID                  s == 0x3C83AB || // PrevFilename                  s == 0x3EB923 || // NextUID                  s == 0x3E83BB || // NextFilename                  s == 0x2AD7B1"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaClusterId,The conditional expression  "s == 0xE7 || // TimeCode                  s == 0xA7 || // Position                  s == 0xAB || // PrevSize                  s == 0xA0 || // BlockGroup                  s == 0xA1 || // Block                  s == 0xA2 || // BlockVirtual                  s == 0xA6 || // BlockMore                  s == 0xEE || // BlockAddID                  s == 0xA5 || // BlockAdditional                  s == 0x9B || // BlockDuration                  s == 0xFA || // ReferencePriority                  s == 0xFB || // ReferenceBlock                  s == 0xFD || // ReferenceVirtual                  s == 0xA4 || // CodecState                  s == 0x8E || // Slices                  s == 0x8E || // TimeSlice                  s == 0xCC || // LaceNumber                  s == 0xCD || // FrameNumber                  s == 0xCB || // BlockAdditionID                  s == 0xCE || // Delay                  s == 0xCF || // Duration                  s == 0xA3"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,MP4,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,GetSubtitleTracks,The conditional expression  "trak.Mdia != null && (trak.Mdia.IsTextSubtitle || trak.Mdia.IsVobSubSubtitle || trak.Mdia.IsClosedCaption) && trak.Mdia.Minf != null && trak.Mdia.Minf.Stbl != null"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The conditional expression  "Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,ZStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,LoadLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SaveLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,FillLanguages,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,CheckLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The method has an empty catch block.
Empty Catch Block,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,GetBytesWithChosenEncoding,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Location = new System.Drawing.Point(12' 25);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Location = new System.Drawing.Point(12' 25);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Location = new System.Drawing.Point(104' 22);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Location = new System.Drawing.Point(104' 22);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Size = new System.Drawing.Size(310' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Size = new System.Drawing.Size(310' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Location = new System.Drawing.Point(420' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Location = new System.Drawing.Point(420' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Location = new System.Drawing.Point(15' 63);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Location = new System.Drawing.Point(15' 63);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Size = new System.Drawing.Size(480' 238);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Size = new System.Drawing.Size(480' 238);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.columnHeaderImdbId.Width = 100;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.columnHeaderTitle.Width = 350;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Location = new System.Drawing.Point(339' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Location = new System.Drawing.Point(339' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(420' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(420' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(13' 316);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(13' 316);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.TabIndex = 6;
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(507' 342);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(507' 342);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(523' 380);
Magic Number,OpenSubtitlesUpload,ImdbSearch,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(523' 380);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: if (temp.Length + 18 < rawText.Length)              {                  checkBoxTextForHI.Checked = true;              }
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: foreach (EncodingInfo ei in Encoding.GetEncodings())              {                  if (ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047)                  {                      comboBoxEncoding.Items.Add(ei.CodePage + ": " + ei.DisplayName);                      //if (ei.Name == Configuration.Settings.General.DefaultEncoding)                      //    encodingSelectedIndex = comboBoxEncoding.Items.Count - 1;                  }              }
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: foreach (EncodingInfo ei in Encoding.GetEncodings())              {                  if (ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047)                  {                      comboBoxEncoding.Items.Add(ei.CodePage + ": " + ei.DisplayName);                      //if (ei.Name == Configuration.Settings.General.DefaultEncoding)                      //    encodingSelectedIndex = comboBoxEncoding.Items.Count - 1;                  }              }
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The following statement contains a magic number: try              {                  if (!string.IsNullOrEmpty(_videoFileName) && File.Exists(_videoFileName))                  {                      var ext = Path.GetExtension(_videoFileName).ToLowerInvariant();                      if (ext == ".mkv")                      {                          bool isValid = false;                          using (var mkv = new VideoFormats.Mkv())                          {                              bool hasConstantFrameRate = true;                              int pixelWidth = 0;                              int pixelHeight = 0;                              double millisecsDuration = 0;                              string videoCodec = string.Empty;                              mkv.GetMatroskaInfo(_videoFileName' ref isValid' ref hasConstantFrameRate' ref frameRate' ref pixelWidth' ref pixelHeight' ref millisecsDuration' ref videoCodec);                          }                          if (!isValid)                              return;                      }                      if (frameRate < 1 && (ext == ".mp4" || ext == ".mov" || ext == ".m4v"))                      {                          var mp4 = new VideoFormats.MP4(_videoFileName);                          frameRate = mp4.FrameRate;                      }                      if (frameRate < 1)                      {                          using (var rp = new VideoFormats.RiffParser())                          {                              var dh = new VideoFormats.RiffDecodeHeader(rp);                              rp.OpenFile(_videoFileName);                              if (VideoFormats.RiffParser.ckidAVI == rp.FileType)                              {                                  dh.ProcessMainAVI();                                  frameRate = dh.FrameRate;                              }                          }                      }                  }                  //CheckForIllegalCrossThreadCalls = false;                  Invoke(new MethodInvoker(() =>                  {                      double minDiff = 100;                      var index = 0;                      for (int i = 1; i < comboBoxFrameRate.Items.Count; i++)                      {                          var element = comboBoxFrameRate.Items[i];                          double d;                          if (double.TryParse(element.ToString()' NumberStyles.AllowDecimalPoint' CultureInfo.InvariantCulture' out d))                          {                              double diff = Math.Abs(d - frameRate);                              if (diff < 0.01 && diff < minDiff)                              {                                  index = i;                                  minDiff = diff;                              }                          }                      }                      comboBoxFrameRate.SelectedIndex = index;                  }));                }              catch              {              }
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The following statement contains a magic number: try              {                  if (!string.IsNullOrEmpty(_videoFileName) && File.Exists(_videoFileName))                  {                      var ext = Path.GetExtension(_videoFileName).ToLowerInvariant();                      if (ext == ".mkv")                      {                          bool isValid = false;                          using (var mkv = new VideoFormats.Mkv())                          {                              bool hasConstantFrameRate = true;                              int pixelWidth = 0;                              int pixelHeight = 0;                              double millisecsDuration = 0;                              string videoCodec = string.Empty;                              mkv.GetMatroskaInfo(_videoFileName' ref isValid' ref hasConstantFrameRate' ref frameRate' ref pixelWidth' ref pixelHeight' ref millisecsDuration' ref videoCodec);                          }                          if (!isValid)                              return;                      }                      if (frameRate < 1 && (ext == ".mp4" || ext == ".mov" || ext == ".m4v"))                      {                          var mp4 = new VideoFormats.MP4(_videoFileName);                          frameRate = mp4.FrameRate;                      }                      if (frameRate < 1)                      {                          using (var rp = new VideoFormats.RiffParser())                          {                              var dh = new VideoFormats.RiffDecodeHeader(rp);                              rp.OpenFile(_videoFileName);                              if (VideoFormats.RiffParser.ckidAVI == rp.FileType)                              {                                  dh.ProcessMainAVI();                                  frameRate = dh.FrameRate;                              }                          }                      }                  }                  //CheckForIllegalCrossThreadCalls = false;                  Invoke(new MethodInvoker(() =>                  {                      double minDiff = 100;                      var index = 0;                      for (int i = 1; i < comboBoxFrameRate.Items.Count; i++)                      {                          var element = comboBoxFrameRate.Items[i];                          double d;                          if (double.TryParse(element.ToString()' NumberStyles.AllowDecimalPoint' CultureInfo.InvariantCulture' out d))                          {                              double diff = Math.Abs(d - frameRate);                              if (diff < 0.01 && diff < minDiff)                              {                                  index = i;                                  minDiff = diff;                              }                          }                      }                      comboBoxFrameRate.SelectedIndex = index;                  }));                }              catch              {              }
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Location = new System.Drawing.Point(301' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Location = new System.Drawing.Point(301' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Location = new System.Drawing.Point(116' 107);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Location = new System.Drawing.Point(116' 107);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.TabIndex = 9;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Location = new System.Drawing.Point(13' 473);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Location = new System.Drawing.Point(13' 473);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(382' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(382' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Location = new System.Drawing.Point(6' 110);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Location = new System.Drawing.Point(6' 110);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Size = new System.Drawing.Size(52' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Size = new System.Drawing.Size(52' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.TabIndex = 8;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Location = new System.Drawing.Point(6' 163);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Location = new System.Drawing.Point(6' 163);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Size = new System.Drawing.Size(81' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Size = new System.Drawing.Size(81' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.TabIndex = 12;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Location = new System.Drawing.Point(116' 160);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Location = new System.Drawing.Point(116' 160);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Size = new System.Drawing.Size(287' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Size = new System.Drawing.Size(287' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.TabIndex = 13;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Location = new System.Drawing.Point(14' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Location = new System.Drawing.Point(14' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Size = new System.Drawing.Size(53' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Size = new System.Drawing.Size(53' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Location = new System.Drawing.Point(114' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Location = new System.Drawing.Point(114' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Location = new System.Drawing.Point(14' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Location = new System.Drawing.Point(14' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Size = new System.Drawing.Size(58' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Size = new System.Drawing.Size(58' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Location = new System.Drawing.Point(114' 29);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Location = new System.Drawing.Point(114' 29);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Location = new System.Drawing.Point(16' 353);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Location = new System.Drawing.Point(16' 353);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Size = new System.Drawing.Size(438' 89);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Size = new System.Drawing.Size(438' 89);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Location = new System.Drawing.Point(299' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Location = new System.Drawing.Point(299' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Size = new System.Drawing.Size(95' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Size = new System.Drawing.Size(95' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Location = new System.Drawing.Point(12' 12);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Location = new System.Drawing.Point(12' 12);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Size = new System.Drawing.Size(442' 335);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Size = new System.Drawing.Size(442' 335);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Location = new System.Drawing.Point(116' 185);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Location = new System.Drawing.Point(116' 185);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Size = new System.Drawing.Size(315' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Size = new System.Drawing.Size(315' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.TabIndex = 16;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Location = new System.Drawing.Point(6' 189);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Location = new System.Drawing.Point(6' 189);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Size = new System.Drawing.Size(27' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Size = new System.Drawing.Size(27' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.TabIndex = 15;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Location = new System.Drawing.Point(116' 133);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Location = new System.Drawing.Point(116' 133);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.TabIndex = 11;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 136);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 136);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 10;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Location = new System.Drawing.Point(227' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Location = new System.Drawing.Point(227' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Size = new System.Drawing.Size(118' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Size = new System.Drawing.Size(118' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.TabIndex = 20;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Location = new System.Drawing.Point(116' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Location = new System.Drawing.Point(116' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Size = new System.Drawing.Size(106' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Size = new System.Drawing.Size(106' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.TabIndex = 19;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Location = new System.Drawing.Point(207' 53);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Location = new System.Drawing.Point(207' 53);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Location = new System.Drawing.Point(409' 158);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Location = new System.Drawing.Point(409' 158);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.TabIndex = 14;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Location = new System.Drawing.Point(236' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Location = new System.Drawing.Point(236' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Size = new System.Drawing.Size(72' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Size = new System.Drawing.Size(72' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Location = new System.Drawing.Point(116' 212);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Location = new System.Drawing.Point(116' 212);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Size = new System.Drawing.Size(317' 91);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Size = new System.Drawing.Size(317' 91);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.TabIndex = 18;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 215);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 215);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(51' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(51' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 17;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 84);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 84);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Location = new System.Drawing.Point(116' 81);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Location = new System.Drawing.Point(116' 81);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.TabIndex = 7;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(44' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(44' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Location = new System.Drawing.Point(116' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Location = new System.Drawing.Point(116' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Size = new System.Drawing.Size(85' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Size = new System.Drawing.Size(85' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Location = new System.Drawing.Point(116' 28);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Location = new System.Drawing.Point(116' 28);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 31);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 31);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(55' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(55' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(14' 445);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(14' 445);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(469' 500);
Magic Number,OpenSubtitlesUpload,PluginForm,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(469' 500);
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int norwegianCount = GetCount(text' "ut"' "deg"' "meg"' "merkelig"' "mye"' "sprre");                  int dutchCount = GetCount(text' AutoDetectWordsDutch);                  if (norwegianCount < 2 && dutchCount < count)                      return "da";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int danishCount = GetCount(text' "siger"' "dig"' "mig"' "mrkelig"' "tilbage"' "sprge");                  int dutchCount = GetCount(text' AutoDetectWordsDutch);                  if (danishCount < 2 && dutchCount < count)                      return "no";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not spanish words                  int portugueseCount = GetCount(text' "[NnCc]o"' "Ento"' "h?ouve"' "pessoal"' "rapariga"' "tivesse"' "fizeste"'                                                       "jantar"' "conheo"' "ateno"' "foste"' "milhes"' "devias"' "ganhar"' "raios"); // not spanish words                  if (frenchCount < 2 && portugueseCount < 2)                      return "es";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not spanish words                  int portugueseCount = GetCount(text' "[NnCc]o"' "Ento"' "h?ouve"' "pessoal"' "rapariga"' "tivesse"' "fizeste"'                                                       "jantar"' "conheo"' "ateno"' "foste"' "milhes"' "devias"' "ganhar"' "raios"); // not spanish words                  if (frenchCount < 2 && portugueseCount < 2)                      return "es";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not italian words                  if (frenchCount < 2)                      return "it";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount)              {                  int romanianCount = GetCount(text' "[Vv]reau"' "[Ss]nt"' "[Aa]cum"' "pentru"' "domnule"' "aici");                  if (romanianCount < 5)                      return "fr";              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > 10 || count > bestCount)                  return "th";
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > 10 || count > bestCount)                  return "ko";
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount * 2)                  return "ja";
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: if (count > bestCount * 2)                  return "zh";
Magic Number,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SendRequestAndGetResponse,The following statement contains a magic number: webRequest.Timeout = 10000;
Magic Number,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,ComputeMovieHash,The following statement contains a magic number: const int c = 65536;
Magic Number,OpenSubtitles,OpenSubtitlesApi,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,ComputeMovieHash,The following statement contains a magic number: while (i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0))              {                  i++;                  lhash += BitConverter.ToInt64(buffer' 0);              }
Magic Number,Nikse.SubtitleEdit.Logic,Utils,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: string languageId = AutoDetectGoogleLanguage(text' 10);
Magic Number,Nikse.SubtitleEdit.Logic,Utils,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,GetSettingsFileName,The following statement contains a magic number: if (path.StartsWith("file:\\"' StringComparison.Ordinal))                  path = path.Remove(0' 6);
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,FindTrackStartInCluster,The following statement contains a magic number: return (clusterTimeCode + trackStartTime) * _timeCodeScale / 1000000;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: int a = 255;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 255)                  result = 1;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 127;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 127)                  result = 2;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 127)                  result = 2;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 63;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 63)                  result = 3;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 63)                  result = 3;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 31;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 31)                  result = 4;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 31)                  result = 4;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 15;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 15)                  result = 5;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 15)                  result = 5;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 7;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 7)                  result = 6;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 7)                  result = 6;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 3;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 3)                  result = 7;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 3)                  result = 7;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: if (a == 1)                  result = 8;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: if (sizeOfSize == 8)              {                  long i = (long)_f.ReadByte() << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 7)              {                  long i = firstByte << 48;                  i += (long)_f.ReadByte() << 40;                  i += (long)_f.ReadByte() << 32;                  i += (long)_f.ReadByte() << 24;                  i += (long)_f.ReadByte() << 16;                  i += (long)_f.ReadByte() << 8;                  i += _f.ReadByte();                  return i;              }              else if (sizeOfSize == 6)              {                  firstByte = (byte)(firstByte & 3); // 00000011                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  firstByte = (byte)(firstByte & 7); // 00000111                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  firstByte = (byte)(firstByte & 15); // 00001111                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (b6 << 16) + (firstByte << 24);              }              else if (sizeOfSize == 3)              {                  firstByte = (byte)(firstByte & 31); // 00011111                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  return b8 + (b7 << 8) + (firstByte << 16);              }              else if (sizeOfSize == 2)              {                  firstByte = (byte)(firstByte & 63); // 00111111                  b8 = (byte)_f.ReadByte();                  return b8 + (firstByte << 8);              }              else if (sizeOfSize == 1)              {                  return firstByte & 127; //01111111              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: if (sizeOfSize >= 8)              {                  throw new NotImplementedException();              }              else if (sizeOfSize == 7)              {                  b3 = (byte)_f.ReadByte();                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (b3 * 1099511627776) +                           (firstByte * 281474976710656);                }              else if (sizeOfSize == 6)              {                  b4 = (byte)_f.ReadByte();                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (b4 * 4294967296) + (firstByte * 1099511627776);              }              else if (sizeOfSize == 5)              {                  b5 = (byte)_f.ReadByte();                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (b5 * 16777216) + (firstByte * 4294967296);              }              else if (sizeOfSize == 4)              {                  b6 = (byte)_f.ReadByte();                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (b6 * 65536) + (firstByte * 16777216);              }              else if (sizeOfSize == 3)              {                  b7 = (byte)_f.ReadByte();                  b8 = (byte)_f.ReadByte();                  result = b8 + (b7 * 256) + (firstByte * 65536);              }              else if (sizeOfSize == 2)              {                  b8 = (byte)_f.ReadByte();                  result = b8 + (firstByte * 256);              }              else if (sizeOfSize == 1)              {                  result = firstByte;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The following statement contains a magic number: UInt32 s = (UInt32)b * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The following statement contains a magic number: s = (UInt32)b * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaTrackEntryId();                  if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0x23E383)// Default Duration                      {                          afterPosition = _f.Position + dataSize;                            b = (byte)_f.ReadByte();                          defaultDuration = GetMatroskaDataSize(dataSize' b);                            _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xE0)// Video settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isVideo = true;                      }                      else if (matroskaId == 0xE1)// Audio settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isAudio = true;                      }                      else if (matroskaId == 0xD7) // Track number                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              trackNumber = (byte)_f.ReadByte();                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x536E) // Name                      {                          afterPosition = _f.Position + dataSize;                          name = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x22B59C) // Language                      {                          afterPosition = _f.Position + dataSize;                          language = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x86) // CodecId                      {                          afterPosition = _f.Position + dataSize;                          codecId = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x83) // Track type                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              byte trackType = (byte)_f.ReadByte();                              if (trackType == 0x11) // subtitle                                  isSubtitle = true;                              if (trackType == 1)                                  isVideo = true;                              if (trackType == 2)                                  isAudio = true;                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x63A2) // CodecPrivate                      {                          afterPosition = _f.Position + dataSize;                          codecPrivate = GetMatroskaString(dataSize);                          if (codecPrivate.Length > 20)                              biCompression = codecPrivate.Substring(16' 4);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x6D80) // ContentEncodings                      {                          afterPosition = _f.Position + dataSize;                            contentCompressionAlgorithm = 0; // default value                          contentEncodingType = 0; // default value                            int contentEncoding1 = _f.ReadByte();                          int contentEncoding2 = _f.ReadByte();                            if (contentEncoding1 == 0x62 && contentEncoding2 == 0x40)                          {                              AnalyzeMatroskaContentEncoding(afterPosition' ref contentCompressionAlgorithm' ref contentEncodingType);                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaTrackEntryId();                  if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0x23E383)// Default Duration                      {                          afterPosition = _f.Position + dataSize;                            b = (byte)_f.ReadByte();                          defaultDuration = GetMatroskaDataSize(dataSize' b);                            _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xE0)// Video settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isVideo = true;                      }                      else if (matroskaId == 0xE1)// Audio settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isAudio = true;                      }                      else if (matroskaId == 0xD7) // Track number                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              trackNumber = (byte)_f.ReadByte();                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x536E) // Name                      {                          afterPosition = _f.Position + dataSize;                          name = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x22B59C) // Language                      {                          afterPosition = _f.Position + dataSize;                          language = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x86) // CodecId                      {                          afterPosition = _f.Position + dataSize;                          codecId = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x83) // Track type                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              byte trackType = (byte)_f.ReadByte();                              if (trackType == 0x11) // subtitle                                  isSubtitle = true;                              if (trackType == 1)                                  isVideo = true;                              if (trackType == 2)                                  isAudio = true;                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x63A2) // CodecPrivate                      {                          afterPosition = _f.Position + dataSize;                          codecPrivate = GetMatroskaString(dataSize);                          if (codecPrivate.Length > 20)                              biCompression = codecPrivate.Substring(16' 4);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x6D80) // ContentEncodings                      {                          afterPosition = _f.Position + dataSize;                            contentCompressionAlgorithm = 0; // default value                          contentEncodingType = 0; // default value                            int contentEncoding1 = _f.ReadByte();                          int contentEncoding2 = _f.ReadByte();                            if (contentEncoding1 == 0x62 && contentEncoding2 == 0x40)                          {                              AnalyzeMatroskaContentEncoding(afterPosition' ref contentCompressionAlgorithm' ref contentEncodingType);                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaTrackEntryId();                  if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0x23E383)// Default Duration                      {                          afterPosition = _f.Position + dataSize;                            b = (byte)_f.ReadByte();                          defaultDuration = GetMatroskaDataSize(dataSize' b);                            _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xE0)// Video settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isVideo = true;                      }                      else if (matroskaId == 0xE1)// Audio settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isAudio = true;                      }                      else if (matroskaId == 0xD7) // Track number                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              trackNumber = (byte)_f.ReadByte();                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x536E) // Name                      {                          afterPosition = _f.Position + dataSize;                          name = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x22B59C) // Language                      {                          afterPosition = _f.Position + dataSize;                          language = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x86) // CodecId                      {                          afterPosition = _f.Position + dataSize;                          codecId = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x83) // Track type                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              byte trackType = (byte)_f.ReadByte();                              if (trackType == 0x11) // subtitle                                  isSubtitle = true;                              if (trackType == 1)                                  isVideo = true;                              if (trackType == 2)                                  isAudio = true;                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x63A2) // CodecPrivate                      {                          afterPosition = _f.Position + dataSize;                          codecPrivate = GetMatroskaString(dataSize);                          if (codecPrivate.Length > 20)                              biCompression = codecPrivate.Substring(16' 4);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x6D80) // ContentEncodings                      {                          afterPosition = _f.Position + dataSize;                            contentCompressionAlgorithm = 0; // default value                          contentEncodingType = 0; // default value                            int contentEncoding1 = _f.ReadByte();                          int contentEncoding2 = _f.ReadByte();                            if (contentEncoding1 == 0x62 && contentEncoding2 == 0x40)                          {                              AnalyzeMatroskaContentEncoding(afterPosition' ref contentCompressionAlgorithm' ref contentEncodingType);                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaTrackEntryId();                  if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0x23E383)// Default Duration                      {                          afterPosition = _f.Position + dataSize;                            b = (byte)_f.ReadByte();                          defaultDuration = GetMatroskaDataSize(dataSize' b);                            _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xE0)// Video settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isVideo = true;                      }                      else if (matroskaId == 0xE1)// Audio settings                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaTrackVideo(afterPosition);                          _f.Seek(afterPosition' SeekOrigin.Begin);                          isAudio = true;                      }                      else if (matroskaId == 0xD7) // Track number                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              trackNumber = (byte)_f.ReadByte();                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x536E) // Name                      {                          afterPosition = _f.Position + dataSize;                          name = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x22B59C) // Language                      {                          afterPosition = _f.Position + dataSize;                          language = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x86) // CodecId                      {                          afterPosition = _f.Position + dataSize;                          codecId = GetMatroskaString(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x83) // Track type                      {                          afterPosition = _f.Position + dataSize;                          if (dataSize == 1)                          {                              byte trackType = (byte)_f.ReadByte();                              if (trackType == 0x11) // subtitle                                  isSubtitle = true;                              if (trackType == 1)                                  isVideo = true;                              if (trackType == 2)                                  isAudio = true;                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x63A2) // CodecPrivate                      {                          afterPosition = _f.Position + dataSize;                          codecPrivate = GetMatroskaString(dataSize);                          if (codecPrivate.Length > 20)                              biCompression = codecPrivate.Substring(16' 4);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x6D80) // ContentEncodings                      {                          afterPosition = _f.Position + dataSize;                            contentCompressionAlgorithm = 0; // default value                          contentEncodingType = 0; // default value                            int contentEncoding1 = _f.ReadByte();                          int contentEncoding2 = _f.ReadByte();                            if (contentEncoding1 == 0x62 && contentEncoding2 == 0x40)                          {                              AnalyzeMatroskaContentEncoding(afterPosition' ref contentCompressionAlgorithm' ref contentEncodingType);                          }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: if (isVideo)              {                  if (defaultDuration > 0)                      _frameRate = 1.0 / (defaultDuration / 1000000000.0);                  _videoCodecId = codecId;              }              else if (isSubtitle)              {                  _subtitleList.Add(new MatroskaSubtitleInfo                  {                      Name = name'                      TrackNumber = trackNumber'                      CodecId = codecId'                      Language = language'                      CodecPrivate = codecPrivate'                      ContentEncodingType = contentEncodingType'                      ContentCompressionAlgorithm = contentCompressionAlgorithm                  });              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();                    if (ebmlId == 0)                      done = true;                  else                  {                      if (ebmlId == 0x5031)// ContentEncodingOrder                      {                          int contentEncodingOrder = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingOrder: " + contentEncodingOrder.ToString());                      }                      else if (ebmlId == 0x5032)// ContentEncodingScope                      {                          int contentEncodingScope = _f.ReadByte() * 256 + _f.ReadByte();                          System.Diagnostics.Debug.WriteLine("ContentEncodingScope: " + contentEncodingScope.ToString());                      }                      else if (ebmlId == 0x5033)// ContentEncodingType                      {                          contentEncodingType = _f.ReadByte() * 256 + _f.ReadByte();                      }                      else if (ebmlId == 0x5034)// ContentCompression                      {                          byte b = (byte)_f.ReadByte();                          long sizeOfSize = GetMatroskaVariableIntLength(b);                          long dataSize = GetMatroskaDataSize(sizeOfSize' b);                          long afterPosition = _f.Position + dataSize;                          while (_f.Position < afterPosition)                          {                              int contentCompressionId = _f.ReadByte() * 256 + _f.ReadByte();                              if (contentCompressionId == 0x4254)                              {                                  contentCompressionAlgorithm = _f.ReadByte() * 256 + _f.ReadByte();                              }                              else if (contentCompressionId == 0x4255)                              {                                  int contentCompSettings = _f.ReadByte() * 256 + _f.ReadByte();                                  System.Diagnostics.Debug.WriteLine("contentCompSettings: " + contentCompSettings.ToString());                              }                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,The following statement contains a magic number: while (_f.Position < endPosition && done == false)              {                  matroskaId = GetMatroskaSegmentId();                  if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0x2AD7B1)// TimecodeScale - u-integer     Timecode scale in nanoseconds (1.000.000 means all timecodes in the segment are expressed in milliseconds).                      {                          afterPosition = _f.Position + dataSize;                          b = (byte)_f.ReadByte();                          timeCodeScale = GetMatroskaDataSize(dataSize' b);                          _timeCodeScale = timeCodeScale;                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0x4489)// Duration (float)                      {                          afterPosition = _f.Position + dataSize;                            if (dataSize == 4)                          {                              duration8b = GetFloat32();                          }                          else                          {                              duration8b = GetFloat64();                          }                            _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,The following statement contains a magic number: if (timeCodeScale > 0 && duration8b > 0)                  _durationInMilliseconds = duration8b / timeCodeScale * 1000000.0;              else if (duration8b > 0)                  _durationInMilliseconds = duration8b;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaClusterId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaClusterId();                    if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0xE7) // Timecode                      {                          afterPosition = _f.Position + dataSize;                          clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA0) // BlockGroup                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaBlock(clusterTimeCode);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA3) // SimpleBlock                      {                          afterPosition = _f.Position + dataSize;                          long before = _f.Position;                          b = (byte)_f.ReadByte();                          int sizeOftrackNumber = GetMatroskaVariableIntLength(b);                          long trackNumber = GetMatroskaDataSize(sizeOftrackNumber' b);                            if (trackNumber == _subtitleRipTrackNumber)                          {                              int timeCode = GetInt16();                                // lacing                              byte flags = (byte)_f.ReadByte();                              byte numberOfFrames = 0;                              switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }                                byte[] buffer = new byte[dataSize - (_f.Position - before)];                              _f.Read(buffer' 0' buffer.Length);                              _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaClusterId();                    if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0xE7) // Timecode                      {                          afterPosition = _f.Position + dataSize;                          clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA0) // BlockGroup                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaBlock(clusterTimeCode);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA3) // SimpleBlock                      {                          afterPosition = _f.Position + dataSize;                          long before = _f.Position;                          b = (byte)_f.ReadByte();                          int sizeOftrackNumber = GetMatroskaVariableIntLength(b);                          long trackNumber = GetMatroskaDataSize(sizeOftrackNumber' b);                            if (trackNumber == _subtitleRipTrackNumber)                          {                              int timeCode = GetInt16();                                // lacing                              byte flags = (byte)_f.ReadByte();                              byte numberOfFrames = 0;                              switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }                                byte[] buffer = new byte[dataSize - (_f.Position - before)];                              _f.Read(buffer' 0' buffer.Length);                              _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaClusterId();                    if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0xE7) // Timecode                      {                          afterPosition = _f.Position + dataSize;                          clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA0) // BlockGroup                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaBlock(clusterTimeCode);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA3) // SimpleBlock                      {                          afterPosition = _f.Position + dataSize;                          long before = _f.Position;                          b = (byte)_f.ReadByte();                          int sizeOftrackNumber = GetMatroskaVariableIntLength(b);                          long trackNumber = GetMatroskaDataSize(sizeOftrackNumber' b);                            if (trackNumber == _subtitleRipTrackNumber)                          {                              int timeCode = GetInt16();                                // lacing                              byte flags = (byte)_f.ReadByte();                              byte numberOfFrames = 0;                              switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }                                byte[] buffer = new byte[dataSize - (_f.Position - before)];                              _f.Read(buffer' 0' buffer.Length);                              _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following statement contains a magic number: while (_f.Position < _f.Length && done == false)              {                  matroskaId = GetMatroskaClusterId();                    if (matroskaId == 0)                      done = true;                  else                  {                      b = (byte)_f.ReadByte();                      sizeOfSize = GetMatroskaVariableIntLength(b);                      dataSize = GetMatroskaDataSize(sizeOfSize' b);                        if (matroskaId == 0xE7) // Timecode                      {                          afterPosition = _f.Position + dataSize;                          clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA0) // BlockGroup                      {                          afterPosition = _f.Position + dataSize;                          AnalyzeMatroskaBlock(clusterTimeCode);                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else if (matroskaId == 0xA3) // SimpleBlock                      {                          afterPosition = _f.Position + dataSize;                          long before = _f.Position;                          b = (byte)_f.ReadByte();                          int sizeOftrackNumber = GetMatroskaVariableIntLength(b);                          long trackNumber = GetMatroskaDataSize(sizeOftrackNumber' b);                            if (trackNumber == _subtitleRipTrackNumber)                          {                              int timeCode = GetInt16();                                // lacing                              byte flags = (byte)_f.ReadByte();                              byte numberOfFrames = 0;                              switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }                                byte[] buffer = new byte[dataSize - (_f.Position - before)];                              _f.Read(buffer' 0' buffer.Length);                              _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                            }                          _f.Seek(afterPosition' SeekOrigin.Begin);                      }                      else                          _f.Seek(dataSize' SeekOrigin.Current);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: if (b == 0xA1) // Block              {                  b = (byte)_f.ReadByte();                  int sizeOfSize = GetMatroskaVariableIntLength(b);                  long dataSize = GetMatroskaDataSize(sizeOfSize' b);                    long afterPosition = _f.Position + dataSize;                    // track number                  b = (byte)_f.ReadByte();                  int sizeOfTrackNo = GetMatroskaVariableIntLength(b);                  long trackNo = GetMatroskaDataSize(sizeOfTrackNo' b);                    // time code                  Int16 timeCode = GetInt16();                    // lacing                  byte flags = (byte)_f.ReadByte();                  byte numberOfFrames = 0;                  switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }                    // save subtitle data                  if (trackNo == _subtitleRipTrackNumber)                  {                      long sublength = afterPosition - _f.Position;                      if (sublength > 0)                      {                          byte[] buffer = new byte[sublength];                          _f.Read(buffer' 0' (int)sublength);                            //string s = GetMatroskaString(sublength);                          //s = s.Replace("\\N"' Environment.NewLine);                            _f.Seek(afterPosition' SeekOrigin.Begin);                          b = (byte)_f.ReadByte();                          if (b == 0x9B) // BlockDuration                          {                              b = (byte)_f.ReadByte();                              sizeOfSize = GetMatroskaVariableIntLength(b);                              dataSize = GetMatroskaDataSize(sizeOfSize' b);                              duration = GetMatroskaVariableSizeUnsignedInt(dataSize);                          }                            _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                      }                  }                }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: if (b == 0xA1) // Block              {                  b = (byte)_f.ReadByte();                  int sizeOfSize = GetMatroskaVariableIntLength(b);                  long dataSize = GetMatroskaDataSize(sizeOfSize' b);                    long afterPosition = _f.Position + dataSize;                    // track number                  b = (byte)_f.ReadByte();                  int sizeOfTrackNo = GetMatroskaVariableIntLength(b);                  long trackNo = GetMatroskaDataSize(sizeOfTrackNo' b);                    // time code                  Int16 timeCode = GetInt16();                    // lacing                  byte flags = (byte)_f.ReadByte();                  byte numberOfFrames = 0;                  switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }                    // save subtitle data                  if (trackNo == _subtitleRipTrackNumber)                  {                      long sublength = afterPosition - _f.Position;                      if (sublength > 0)                      {                          byte[] buffer = new byte[sublength];                          _f.Read(buffer' 0' (int)sublength);                            //string s = GetMatroskaString(sublength);                          //s = s.Replace("\\N"' Environment.NewLine);                            _f.Seek(afterPosition' SeekOrigin.Begin);                          b = (byte)_f.ReadByte();                          if (b == 0x9B) // BlockDuration                          {                              b = (byte)_f.ReadByte();                              sizeOfSize = GetMatroskaVariableIntLength(b);                              dataSize = GetMatroskaDataSize(sizeOfSize' b);                              duration = GetMatroskaVariableSizeUnsignedInt(dataSize);                          }                            _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                      }                  }                }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: if (b == 0xA1) // Block              {                  b = (byte)_f.ReadByte();                  int sizeOfSize = GetMatroskaVariableIntLength(b);                  long dataSize = GetMatroskaDataSize(sizeOfSize' b);                    long afterPosition = _f.Position + dataSize;                    // track number                  b = (byte)_f.ReadByte();                  int sizeOfTrackNo = GetMatroskaVariableIntLength(b);                  long trackNo = GetMatroskaDataSize(sizeOfTrackNo' b);                    // time code                  Int16 timeCode = GetInt16();                    // lacing                  byte flags = (byte)_f.ReadByte();                  byte numberOfFrames = 0;                  switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }                    // save subtitle data                  if (trackNo == _subtitleRipTrackNumber)                  {                      long sublength = afterPosition - _f.Position;                      if (sublength > 0)                      {                          byte[] buffer = new byte[sublength];                          _f.Read(buffer' 0' (int)sublength);                            //string s = GetMatroskaString(sublength);                          //s = s.Replace("\\N"' Environment.NewLine);                            _f.Seek(afterPosition' SeekOrigin.Begin);                          b = (byte)_f.ReadByte();                          if (b == 0x9B) // BlockDuration                          {                              b = (byte)_f.ReadByte();                              sizeOfSize = GetMatroskaVariableIntLength(b);                              dataSize = GetMatroskaDataSize(sizeOfSize' b);                              duration = GetMatroskaVariableSizeUnsignedInt(dataSize);                          }                            _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                      }                  }                }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: if (b == 0xA1) // Block              {                  b = (byte)_f.ReadByte();                  int sizeOfSize = GetMatroskaVariableIntLength(b);                  long dataSize = GetMatroskaDataSize(sizeOfSize' b);                    long afterPosition = _f.Position + dataSize;                    // track number                  b = (byte)_f.ReadByte();                  int sizeOfTrackNo = GetMatroskaVariableIntLength(b);                  long trackNo = GetMatroskaDataSize(sizeOfTrackNo' b);                    // time code                  Int16 timeCode = GetInt16();                    // lacing                  byte flags = (byte)_f.ReadByte();                  byte numberOfFrames = 0;                  switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }                    // save subtitle data                  if (trackNo == _subtitleRipTrackNumber)                  {                      long sublength = afterPosition - _f.Position;                      if (sublength > 0)                      {                          byte[] buffer = new byte[sublength];                          _f.Read(buffer' 0' (int)sublength);                            //string s = GetMatroskaString(sublength);                          //s = s.Replace("\\N"' Environment.NewLine);                            _f.Seek(afterPosition' SeekOrigin.Begin);                          b = (byte)_f.ReadByte();                          if (b == 0x9B) // BlockDuration                          {                              b = (byte)_f.ReadByte();                              sizeOfSize = GetMatroskaVariableIntLength(b);                              dataSize = GetMatroskaDataSize(sizeOfSize' b);                              duration = GetMatroskaVariableSizeUnsignedInt(dataSize);                          }                            _subtitleRip.Add(new SubtitleSequence(buffer' timeCode + clusterTimeCode' timeCode + clusterTimeCode + duration));                      }                  }                }
Magic Number,OpenSubtitlesUpload.VideoFormats,MP4,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,ParseMp4,The following statement contains a magic number: using (fs)              {                  bool moreBytes = true;                  while (moreBytes)                  {                      moreBytes = InitializeSizeAndName(fs);                      if (Size < 8)                          return;                        if (Name == "moov" && Moov == null)                          Moov = new Moov(fs' Position);                        count++;                      if (count > 100)                          break;                        if (Position > (ulong)fs.Length)                          break;                      fs.Seek((long)Position' SeekOrigin.Begin);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,MP4,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,ParseMp4,The following statement contains a magic number: using (fs)              {                  bool moreBytes = true;                  while (moreBytes)                  {                      moreBytes = InitializeSizeAndName(fs);                      if (Size < 8)                          return;                        if (Name == "moov" && Moov == null)                          Moov = new Moov(fs' Position);                        count++;                      if (count > 100)                          break;                        if (Position > (ulong)fs.Length)                          break;                      fs.Seek((long)Position' SeekOrigin.Begin);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffDecodeHeader,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffDecodeHeader.cs,DecodeAVIStream,The following statement contains a magic number: fixed (Byte* bp = &ba[0])              {                  AVISTREAMHEADER* avi = (AVISTREAMHEADER*)bp;                    if (AviRiffData.streamtypeVIDEO == avi->fccType)                  {                      m_vidHandler = RiffParser.FromFourCC(avi->fccHandler);                      if (avi->dwScale > 0)                      {                          m_vidDataRate = (double)avi->dwRate / (double)avi->dwScale;                      }                      else                      {                          m_vidDataRate = 0.0;                      }                  }                  else if (AviRiffData.streamtypeAUDIO == avi->fccType)                  {                      if (AviRiffData.ckidMP3 == avi->fccHandler)                      {                          m_audHandler = "MP3";                      }                      else                      {                          m_audHandler = RiffParser.FromFourCC(avi->fccHandler);                      }                      if (avi->dwScale > 0)                      {                          m_audDataRate = 8.0 * (double)avi->dwRate / (double)avi->dwScale;                          if (avi->dwSampleSize > 0)                          {                              m_audDataRate /= (double)avi->dwSampleSize;                          }                        }                      else                      {                          m_audDataRate = 0.0;                      }                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ReadElement,The following statement contains a magic number: if (0 == String.Compare(type' LIST4CC))              {                  // We have a list                  ReadOneInt(out FourCC);                    if (null == list)                  {                      SkipData(size - 4);                  }                  else                  {                      // Invoke the list method                      list(this' FourCC' size - 4);                  }                    // Adjust size                  bytesleft -= size;              }              else              {                  // Calculated padded size - padded to WORD boundary                  int paddedSize = size;                  if (0 != (size & 1)) ++paddedSize;                    if (null == chunk)                  {                      SkipData(paddedSize);                  }                  else                  {                      chunk(this' FourCC' size' paddedSize);                  }                    // Adjust size                  bytesleft -= paddedSize;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ReadElement,The following statement contains a magic number: if (0 == String.Compare(type' LIST4CC))              {                  // We have a list                  ReadOneInt(out FourCC);                    if (null == list)                  {                      SkipData(size - 4);                  }                  else                  {                      // Invoke the list method                      list(this' FourCC' size - 4);                  }                    // Adjust size                  bytesleft -= size;              }              else              {                  // Calculated padded size - padded to WORD boundary                  int paddedSize = size;                  if (0 != (size & 1)) ++paddedSize;                    if (null == chunk)                  {                      SkipData(paddedSize);                  }                  else                  {                      chunk(this' FourCC' size' paddedSize);                  }                    // Adjust size                  bytesleft -= paddedSize;              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: char[] chars = new char[4];
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[1] = (char)((FourCC >> 8) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[2] = (char)((FourCC >> 16) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[2] = (char)((FourCC >> 16) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[3] = (char)((FourCC >> 24) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[3] = (char)((FourCC >> 24) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: if (FourCC.Length != 4)              {                  throw new Exception("FourCC strings must be 4 characters long " + FourCC);              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: if (FourCC.Length != 4)              {                  throw new Exception("FourCC char arrays must be 4 characters long " + new string(FourCC));              }
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetWord,The following statement contains a magic number: return (buffer[index] << 8) + buffer[index + 1];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetWord,The following statement contains a magic number: return (Buffer[index] << 8) + Buffer[index + 1];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Buffer = new byte[8];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Name = GetString(4' 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Name = GetString(4' 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: if (Size == 1)              {                  bytesRead = fs.Read(Buffer' 0' Buffer.Length);                  if (bytesRead < Buffer.Length)                      return false;                  Size = GetUInt64(0) - 8;              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Position = ((ulong)(fs.Position)) + Size - 8;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: Buffer = new byte[size - 4];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageIndex = 20;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: if (version == 0)              {                  CreationTime = GetUInt(4);                  ModificationTime = GetUInt(8);                  TimeScale = GetUInt(12);                  Duration = GetUInt(16);                  Quality = GetWord(22);              }              else              {                  CreationTime = GetUInt64(4);                  ModificationTime = GetUInt64(12);                  TimeScale = GetUInt(16);                  Duration = GetUInt64(20);                  languageIndex = 24;                  Quality = GetWord(26);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte = ((Buffer[languageIndex] << 1) >> 3) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte2 = ((Buffer[languageIndex] & 0x3) << 3) + (Buffer[languageIndex + 1] >> 5) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte2 = ((Buffer[languageIndex] & 0x3) << 3) + (Buffer[languageIndex + 1] >> 5) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo)                  {                      uint timeScale = 90000;                      if (Mdhd != null)                          timeScale = Mdhd.TimeScale;                      Minf = new Minf(fs' Position' timeScale' HandlerType' this);                  }                  else if (Name == "hdlr")                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      HandlerType = GetString(8' 4);                      if (Size > 25)                          HandlerName = GetString(24' Buffer.Length - (24 + 5)); // TODO: how to find this?                  }                  else if (Name == "mdhd")                  {                      Mdhd = new Mdhd(fs' Size);                  }                  fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: Buffer = new byte[20];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: CreationTime = GetUInt(4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: ModificationTime = GetUInt(8);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: TimeScale = GetUInt(12);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: Duration = GetUInt(16);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: while (fs.Position < (long)maximumLength)              {                  if (!InitializeSizeAndName(fs))                      return;                    if (Name == "stco") // 32-bit - chunk offset                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        uint lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          uint offset = GetUInt(8 + i * 4);                          if (lastOffset + 5 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "co64") // 64-bit                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint totalEntries = GetUInt(4);                        ulong lastOffset = 0;                      for (int i = 0; i < totalEntries; i++)                      {                          ulong offset = GetUInt64(8 + i * 8);                          if (lastOffset + 8 < offset)                              ReadText(fs' offset' handlerType);                          lastOffset = offset;                      }                  }                  else if (Name == "stsz") // sample sizes                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint uniformSizeOfEachSample = GetUInt(4);                      uint numberOfSampleSizes = GetUInt(8);                      StszSampleCount = numberOfSampleSizes;                      for (int i = 0; i < numberOfSampleSizes; i++)                      {                          if (12 + i * 4 + 4 < Buffer.Length)                          {                              uint sampleSize = GetUInt(12 + i * 4);                          }                      }                  }                  else if (Name == "stts") // sample table time to sample map                  {                      //https://developer.apple.com/library/mac/#documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW1                        Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      double totalTime = 0;                      if (_mdia.IsClosedCaption)                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              for (int j = 0; j < sampleCount; j++)                              {                                  totalTime += sampleDelta / (double)timeScale;                                  if (StartTimeCodes.Count > 0)                                      EndTimeCodes[EndTimeCodes.Count - 1] = totalTime - 0.001;                                  StartTimeCodes.Add(totalTime);                                  EndTimeCodes.Add(totalTime + 2.5);                              }                          }                      }                      else                      {                          for (int i = 0; i < numberOfSampleTimes; i++)                          {                              uint sampleCount = GetUInt(8 + i * 8);                              uint sampleDelta = GetUInt(12 + i * 8);                              totalTime += sampleDelta / (double)timeScale;                              if (StartTimeCodes.Count <= EndTimeCodes.Count)                                  StartTimeCodes.Add(totalTime);                              else                                  EndTimeCodes.Add(totalTime);                          }                      }                  }                  else if (Name == "stsc") // sample table sample to chunk map                  {                      Buffer = new byte[Size - 4];                      fs.Read(Buffer' 0' Buffer.Length);                      int version = Buffer[0];                      uint numberOfSampleTimes = GetUInt(4);                      for (int i = 0; i < numberOfSampleTimes; i++)                      {                          if (16 + i * 12 + 4 < Buffer.Length)                          {                              uint firstChunk = GetUInt(8 + i * 12);                              uint samplesPerChunk = GetUInt(12 + i * 12);                              uint sampleDescriptionIndex = GetUInt(16 + i * 12);                          }                      }                  }                    fs.Seek((long)Position' SeekOrigin.Begin);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: var data = new byte[4];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: fs.Read(data' 0' 2);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: if (handlerType == "subp") // VobSub created with Mp4Box              {                  if (textSize > 100)                  {                      fs.Seek((long)offset' SeekOrigin.Begin);                      data = new byte[textSize + 2];                      fs.Read(data' 0' data.Length);                      //SubPictures.Add(new SubPicture(data)); //TODO: where is palette?                  }              }              else              {                  if (textSize == 0)                  {                      fs.Read(data' 2' 2);                      textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes                  }                  if (textSize > 0 && textSize < 500)                  {                      data = new byte[textSize];                      fs.Read(data' 0' data.Length);                      string text = GetString(data' 0' (int)textSize).TrimEnd();                        if (_mdia.IsClosedCaption)                      {                          var sb = new StringBuilder();                          for (int j = 8; j < data.Length - 3; j++)                          {                              string h = data[j].ToString("X2").ToLower();                              if (h.Length < 2)                                  h = "0" + h;                              sb.Append(h);                              if (j % 2 == 1)                                  sb.Append(" ");                          }                          var hex = sb.ToString();                          //int errorCount = 0;                          //text = SubtitleFormats.ScenaristClosedCaptions.GetSccText(hex' ref errorCount);                          if (text.StartsWith('n') && text.Length > 1)                              text = "<i>" + text.Substring(1) + "</i>";                          if (text.StartsWith("-n"))                              text = text.Remove(0' 2);                          if (text.StartsWith("-N"' StringComparison.Ordinal))                              text = text.Remove(0' 2);                          if (text.StartsWith('-') && !text.Contains(Environment.NewLine + "-"))                              text = text.Remove(0' 1);                      }                      Texts.Add(text.Replace(Environment.NewLine' "\n").Replace("\n"' Environment.NewLine));                  }                  else                  {                      Texts.Add(string.Empty);                  }              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Buffer = new byte[84];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: if (version == 1)                  addToIndex64Bit = 8;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: TrackId = GetUInt(12 + addToIndex64Bit);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: if (version == 1)              {                  Duration = GetUInt64(20 + addToIndex64Bit);                  addToIndex64Bit += 4;              }              else              {                  Duration = GetUInt(20 + addToIndex64Bit);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: if (version == 1)              {                  Duration = GetUInt64(20 + addToIndex64Bit);                  addToIndex64Bit += 4;              }              else              {                  Duration = GetUInt(20 + addToIndex64Bit);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: if (version == 1)              {                  Duration = GetUInt64(20 + addToIndex64Bit);                  addToIndex64Bit += 4;              }              else              {                  Duration = GetUInt(20 + addToIndex64Bit);              }
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Width = (uint)GetWord(76 + addToIndex64Bit);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Height = (uint)GetWord(80 + addToIndex64Bit);
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff); s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff); s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < L_CODES; i++)                  dyn_ltree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < D_CODES; i++)                  dyn_dtree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < BL_CODES; i++)                  bl_tree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)SupportClass.Identity(0xffff);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte)(SupportClass.URShift(w' 8)));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte)(b >> 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.static_ltree);                  bi_flush();              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte)(SupportClass.URShift(dist' 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte)(SupportClass.URShift(dist' 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte)dist;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;                  dyn_dtree[Tree.d_code(dist) * 2]++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit * 8;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));                  }                  out_length = SupportClass.URShift(out_length' 3);                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff; lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff; lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);                      lc = (pending_buf[l_buf + lx]) & 0xff; lx++;                        if (dist == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // Here' lc is the match length - MIN_MATCH                          code = Tree._length_code[lc];                            send_code(code + LITERALS + 1' ltree); // send the length code                          extra = Tree.extra_lbits[code];                          if (extra != 0)                          {                              lc -= Tree.base_length[code];                              send_bits(lc' extra); // send the extra length bits                          }                          dist--; // dist is now the match distance - 1                          code = Tree.d_code(dist);                            send_code(code' dtree); // send the distance code                          extra = Tree.extra_dbits[code];                          if (extra != 0)                          {                              dist -= Tree.base_dist[code];                              send_bits(dist' extra); // send the extra distance bits                          }                      } // literal or match pair ?                        // Check that the overlay between pending_buf and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < LITERALS)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte)(bin_freq > (SupportClass.URShift(ascii_freq' 2)) ? Z_BINARY : Z_ASCII);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte)bi_buf);                  bi_buf = (short)(SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte)bi_buf);                  bi_buf = (short)(SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte)bi_buf);                  bi_buf = (short)(SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  put_short(bi_buf);                  bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  put_byte((byte)bi_buf);                  bi_buf = (short)(SupportClass.URShift(bi_buf' 8));                  bi_valid -= 8;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  put_short(bi_buf);              }              else if (bi_valid > 0)              {                  put_byte((byte)bi_buf);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)              {                  max_block_size = pending_buf_size - 5;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)              {                  max_block_size = pending_buf_size - 5;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  l_desc.build_tree(this);                    d_desc.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);                  static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  compress_block(StaticTree.static_ltree' StaticTree.static_dtree);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);                  compress_block(dyn_ltree' dyn_dtree);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short)strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length; prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short)strstart;                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short)strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length; prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short)strstart;                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      fill_window();                      if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)                      {                          return NeedMore;                      }                      if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //	prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = (short)strstart;                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length; prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (strategy != Z_HUFFMAN_ONLY)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                          // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = (short)strstart;                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (strm.avail_out == 0)                              return NeedMore;                      }                  }                  else if (match_available != 0)                  {                      // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (strm.avail_out == 0)                          return NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= good_match)              {                  chain_length >>= 2;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The following statement contains a magic number: do              {                  match = cur_match;                    // Skip to next match if the match length cannot increase                  // or if the match length is less than 2:                  if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1])                      continue;                    // The check at best_len-1 can be removed because it will be made                  // again later. (This heuristic is not always a win.)                  // It is not necessary to compare scan[2] and match[2] since they                  // are always equal when the other bytes match' given that                  // the hash keys are equal and that HASH_BITS >= 8.                  scan += 2; match++;                    // We check for insufficient lookahead only every 8th comparison;                  // the 256th check will be made at strstart+258.                  do                  {                  }                  while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);                    len = MAX_MATCH - (int)(strend - scan);                  scan = strend - MAX_MATCH;                    if (len > best_len)                  {                      match_start = cur_match;                      best_len = len;                      if (len >= nice_match)                          break;                      scan_end1 = window[scan + best_len - 1];                      scan_end = window[scan + best_len];                  }              }              while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)                  level = 6;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION)              {                  _level = 6;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY)              {                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = ((level - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  putShortMSB(header);                    // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));                      putShortMSB((int)(strm.adler & 0xffff));                  }                  strm.adler = strm._adler.adler32(0' null' 0' 0);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {                  config_table = new Config[10];                  //                         good  lazy  nice  chain                  config_table[0] = new Config(0' 0' 0' 0' STORED);                  config_table[1] = new Config(4' 4' 8' 4' FAST);                  config_table[2] = new Config(4' 5' 16' 8' FAST);                  config_table[3] = new Config(4' 6' 32' 32' FAST);                    config_table[4] = new Config(4' 4' 16' 16' SLOW);                  config_table[5] = new Config(8' 16' 32' 32' SLOW);                  config_table[6] = new Config(8' 16' 128' 128' SLOW);                  config_table[7] = new Config(8' 32' 128' 256' SLOW);                  config_table[8] = new Config(32' 128' 258' 1024' SLOW);                  config_table[9] = new Config(32' 258' 258' 4096' SLOW);              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  if ((e = tp[(tp_index + t) * 3]) == 0)                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                      m--;                      continue;                  }                  do                  {                      b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.next_in[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          e = tp[(tp_index + t) * 3];                            do                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; c--; // minimum count is three'                                          s.window[q++] = s.window[r++]; c--; // so unroll loop a little                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[(tp_index + t) * 3 + 2];                                  t += (b & inflate_mask[e]);                                  e = tp[(tp_index + t) * 3];                              }                              else                              {                                  z.msg = "invalid distance code";                                    c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                    return Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[(tp_index + t) * 3 + 2];                          t += (b & inflate_mask[e]);                          if ((e = tp[(tp_index + t) * 3]) == 0)                          {                              b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);                                s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_STREAM_END;                      }                      else                      {                          z.msg = "invalid literal/length code";                            c = z.avail_in - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                            return Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)              {                  inflateEnd(z);                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)              {                  inflateEnd(z);                  return Z_STREAM_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)              {                  //System.out.println("mode: "+z.istate.mode);                  switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.next_in[p] == mark[m])                  {                      m++;                  }                  else if (z.next_in[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.next_in[p] == mark[m])                  {                      m++;                  }                  else if (z.next_in[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4)              {                  return Z_DATA_ERROR;              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: int[] r = new int[3];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)              {                  a = c[k];                  while (a-- != 0)                  {                      // here i is the Huffman code of length k bits for value *p                      // make tables up to required level                      while (k > w + l)                      {                          h++;                          w += l; // previous table always l bits                          // compute minimum size table less than or equal to l bits                          z = g - w;                          z = (z > l) ? l : z; // table size upper limit                          if ((f = 1 << (j = k - w)) > a + 1)                          {                              // try a k-w bit table                              // too few codes for k-w bit table                              f -= (a + 1); // deduct codes from patterns left                              xp = k;                              if (j < z)                              {                                  while (++j < z)                                  {                                      // try smaller tables up to z bits                                      if ((f <<= 1) <= c[++xp])                                          break; // enough codes to use up j bits                                      f -= c[xp]; // else deduct codes from patterns                                  }                              }                          }                          z = 1 << j; // table entries for j-bit table                            // allocate new table                          if (hn[0] + z > MANY)                              // (note: doesn't matter for fixed)                              return Z_DATA_ERROR; // overflow of MANY                          u[h] = q = hn[0]; // DEBUG                          hn[0] += z;                            // connect to last table' if there is one                          if (h != 0)                          {                              x[h] = i; // save pattern for backing up                              r[0] = (byte)j; // bits in this table                              r[1] = (byte)l; // bits to dump before this table                              j = SupportClass.URShift(i' (w - l));                              r[2] = (int)(q - u[h - 1] - j); // offset to this table                              Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                          }                          else                          {                              t[0] = q; // first table is returned result                          }                      }                        // set up table entry in r                      r[1] = (byte)(k - w);                      if (p >= n)                      {                          r[0] = 128 + 64; // out of values--invalid code                      }                      else if (v[p] < s)                      {                          r[0] = (byte)(v[p] < 256 ? 0 : 32 + 64); // 256 is end-of-block                          r[2] = v[p++]; // simple code is just the value                      }                      else                      {                          r[0] = (byte)(e[v[p] - s] + 16 + 64); // non-simple--look up in lists                          r[2] = d[v[p++] - s];                      }                        // fill code-like entries with r                      f = 1 << (k - w);                      for (j = SupportClass.URShift(i' w); j < z; j += f)                      {                          Array.Copy(r' 0' hp' (q + j) * 3' 3);                      }                        // backwards increment the k-bit code i                      for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))                      {                          i ^= j;                      }                      i ^= j;                        // backup over finished tables                      mask = (1 << w) - 1; // needed on HP' cc -O bug                      while ((i & mask) != x[h])                      {                          h--; // don't need to update q                          w -= l;                          mask = (1 << w) - 1;                      }                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int[] v = new int[19];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: int[] v = new int[288];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || (bd[0] == 0 && nl > 257))              {                  if (r == Z_DATA_ERROR)                  {                      z.msg = "oversubscribed distance tree";                  }                  else if (r == Z_BUF_ERROR)                  {                      z.msg = "incomplete distance tree";                      r = Z_DATA_ERROR;                  }                  else if (r != Z_MEM_ERROR)                  {                      z.msg = "empty distance tree with lengths";                      r = Z_DATA_ERROR;                  }                  return r;              }
Magic Number,ComponentAce.Compression.Libs.zlib,SupportClass,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\SupportClass.cs,URShift,The following statement contains a magic number: if (number >= 0)                  return number >> bits;              else                  return (number >> bits) + (2 << ~bits);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short)bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short)bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short)bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short)bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short)bits;                  // We overwrite tree[n*2+1] which is no longer needed                    if (n > max_code)                      continue; // not a leaf node                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do              {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short)(s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do              {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short)(s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);                          tree[m * 2 + 1] = (short)bits;                      }                      n--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);                          tree[m * 2 + 1] = (short)bits;                      }                      n--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);                          tree[m * 2 + 1] = (short)bits;                      }                      n--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);                          tree[m * 2 + 1] = (short)bits;                      }                      n--;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)                  s.pqdownheap(tree' n);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: do              {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                    // Create a new node father of n and m                  tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);                  s.depth[node] = (byte)(System.Math.Max((byte)s.depth[n]' (byte)s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] = (short)(bi_reverse(next_code[len]++' len));              }
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] = (short)(bi_reverse(next_code[len]++' len));              }
Magic Number,ComponentAce.Compression.Libs.zlib,ZInputStream,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZInputStream.cs,skip,The following statement contains a magic number: int len = 512;
Missing Default,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following switch statement is missing a default case: switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }
Missing Default,OpenSubtitlesUpload.VideoFormats,Mkv,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following switch statement is missing a default case: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Missing Default,ComponentAce.Compression.Libs.zlib,InfBlocks,C:\repos\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }
