Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GruntXProductions.Quasar.Assembler.Assemblers,JmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\JmpAssembler.cs,Assemble,Cyclomatic complexity of the method is 38
Complex Method,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,Cyclomatic complexity of the method is 12
Complex Method,GruntXProductions.Quasar.Assembler,BinaryFile,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\BinaryFile.cs,FinalizeExecutable,Cyclomatic complexity of the method is 8
Complex Method,GruntXProductions.Quasar.Assembler,Program,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Program.cs,Main,Cyclomatic complexity of the method is 11
Complex Method,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,ProcessTokens,Cyclomatic complexity of the method is 17
Complex Method,GruntXProductions.Quasar.Assembler.Scanner,Lexer,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Scanner\Lexer.cs,Scan,Cyclomatic complexity of the method is 28
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,AddAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AddAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,AddAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AddAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,AndAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AndAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,AndAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AndAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,BorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\BorAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,BorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\BorAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,CmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\CmpAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,CmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\CmpAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,DivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,DivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,IDivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,IDivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,InAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\InAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral))) { " is 132.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,JmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\JmpAssembler.cs,Assemble,The length of the statement  "		str.Emit (new QuasarInstruction (Opcode.BR' new ConditionCodeOperand (code)' new SymbolReferenceOperand (label.Value' true))); " is 126.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ModAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ModAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ModAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ModAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_BYTE' r1.Offset)' new RegisterOperand (r2.Register))); " is 180.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_BYTE' r1.Offset)' new RegisterOperand (r2.Register))); " is 180.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_WORD' r1.Offset)' new RegisterOperand (r2.Register))); " is 180.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new SymbolReferenceOperand (i1.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new IndirectRegisterOffsetOperand (r2.Register' r2.Offset))); " is 141.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT' r1.Offset)' new RegisterOperand (r2.Register))); " is 175.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,MulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,IMulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,IMulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,OutAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\OutAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenIntLiteral || ins.Operands [0] is TokenRegister) && !(ins.Operands [1] is TokenRegister)) { " is 127.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ShlAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ShlAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SalAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SalAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ShrAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,ShrAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SarAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SarAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SubAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\SubAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,SubAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\SubAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,TstAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\TstAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,TstAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\TstAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,XorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\XorAssembler.cs,Assemble,The length of the statement  "	else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) { " is 174.
Long Statement,GruntXProductions.Quasar.Assembler.Assemblers,XorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\XorAssembler.cs,Assemble,The length of the statement  "			str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value))); " is 120.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,AddAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AddAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,AndAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AndAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,BorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\BorAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,CmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\CmpAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,DivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,IDivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,ModAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ModAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,MulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,IMulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,ShlAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,SalAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,ShrAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,SarAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,SubAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\SubAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,TstAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\TstAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Complex Conditional,GruntXProductions.Quasar.Assembler.Assemblers,XorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\XorAssembler.cs,Assemble,The conditional expression  "!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))"  is complex.
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,AddAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AddAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.ADD;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		Console.WriteLine ("Add with " + op1.Register);  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,AndAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\AndAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.AND;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,BorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\BorAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.BOR;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,CmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\CmpAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.CMP;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,DivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.DIV;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,IDivAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\DivAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.IDIV;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,InAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\InAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.IN;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,LfpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\LfpAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2)  	cgen.CreateError ("Instruction {0} does not take {1} operand(s)!"' ins.Name' ins.Operands.Count);  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,ModAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ModAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.MOD;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,MovAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MovAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2)  	cgen.CreateError ("Instruction {0} does not take {1} operand(s)!"' ins.Name' ins.Operands.Count);  else if (ins.Name == "movb") {  	if (ins.Operands [0] is TokenIndirectRegister && ins.Operands [1] is TokenRegister) {  		TokenIndirectRegister r1 = ins.Operands [0] as TokenIndirectRegister;  		TokenRegister r2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_BYTE' r1.Offset)' new RegisterOperand (r2.Register)));  	}  	else if (ins.Operands [0] is TokenIndirectRegister && ins.Operands [1] is TokenRegister) {  		TokenIndirectRegister r1 = ins.Operands [0] as TokenIndirectRegister;  		TokenRegister r2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_BYTE' r1.Offset)' new RegisterOperand (r2.Register)));  	}  }  else if (ins.Name == "movw") {  	if (ins.Operands [0] is TokenIndirectRegister && ins.Operands [1] is TokenRegister) {  		TokenIndirectRegister r1 = ins.Operands [0] as TokenIndirectRegister;  		TokenRegister r2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT_WORD' r1.Offset)' new RegisterOperand (r2.Register)));  	}  }  else {  	if (ins.Operands [0] is TokenRegister && ins.Operands [1] is TokenRegister) {  		TokenRegister r1 = ins.Operands [0] as TokenRegister;  		TokenRegister r2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new RegisterOperand (r2.Register)));  	}  	else if (ins.Operands [0] is TokenRegister && ins.Operands [1] is TokenIntLiteral) {  		TokenRegister r1 = ins.Operands [0] as TokenRegister;  		TokenIntLiteral i1 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new IntegerOperand ((int)i1.Value)));  	}  	else if (ins.Operands [0] is TokenRegister && ins.Operands [1] is TokenIdentifier) {  		TokenRegister r1 = ins.Operands [0] as TokenRegister;  		TokenIdentifier i1 = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new SymbolReferenceOperand (i1.Value)));  	}  	else if (ins.Operands [0] is TokenRegister && ins.Operands [1] is TokenIndirectRegister) {  		TokenRegister r1 = ins.Operands [0] as TokenRegister;  		TokenIndirectRegister r2 = ins.Operands [1] as TokenIndirectRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new RegisterOperand (r1.Register)' new IndirectRegisterOffsetOperand (r2.Register' r2.Offset)));  	}  	else if (ins.Operands [0] is TokenIndirectRegister && ins.Operands [1] is TokenRegister) {  		TokenIndirectRegister r1 = ins.Operands [0] as TokenIndirectRegister;  		TokenRegister r2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (Opcode.MOV' new IndirectRegisterOffsetOperand (r1.Register' AddressingMode.REGISTER_INDIRECT' r1.Offset)' new RegisterOperand (r2.Register)));  	}  	else {  		cgen.CreateError ("Unsupported addressing mode for instruction {0}"' ins.Name);  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,MulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.MUL;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,IMulAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\MulAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.IMUL;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,OutAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\OutAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenIntLiteral || ins.Operands [0] is TokenRegister) && !(ins.Operands [1] is TokenRegister)) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op2 = ins.Operands [1] as TokenRegister;  	Opcode opcode = Opcode.OUT;  	if (ins.Operands [0] is TokenRegister) {  		TokenRegister op1 = ins.Operands [0] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [0] is TokenIntLiteral) {  		TokenIntLiteral op1 = ins.Operands [0] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new IntegerOperand ((int)op1.Value)' new RegisterOperand (op2.Register)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,ShlAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.SHL;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,SalAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShlAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.SAL;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,ShrAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.SHR;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,SarAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\ShrAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.SAR;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,SubAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\SubAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.SUB;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,TstAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\TstAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.TST;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,XorAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\XorAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister) || (!(ins.Operands [1] is TokenRegister) && !(ins.Operands [1] is TokenIntLiteral) && !(ins.Operands [1] is TokenIdentifier))) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	Opcode opcode = Opcode.XOR;  	if (ins.Operands [1] is TokenRegister) {  		TokenRegister op2 = ins.Operands [1] as TokenRegister;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  	}  	else if (ins.Operands [1] is TokenIntLiteral) {  		TokenIntLiteral op2 = ins.Operands [1] as TokenIntLiteral;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new IntegerOperand ((int)op2.Value)));  	}  	else if (ins.Operands [1] is TokenIdentifier) {  		TokenIdentifier ident = ins.Operands [1] as TokenIdentifier;  		str.Emit (new QuasarInstruction (opcode' new RegisterOperand (op1.Register)' new SymbolReferenceOperand (ident.Value)));  	}  }  
Magic Number,GruntXProductions.Quasar.Assembler.Assemblers,SwpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\SwpAssembler.cs,Assemble,The following statement contains a magic number: if (ins.Operands.Count != 2) {  	cgen.CreateError ("{0} does not take {1} arguments!"' ins.Name' ins.Operands.Count);  }  else if (!(ins.Operands [0] is TokenRegister && ins.Operands [1] is TokenRegister)) {  	cgen.CreateError ("Unsupported addressing mode for instruction '{0}'"' ins.Name);  }  else {  	TokenRegister op1 = ins.Operands [0] as TokenRegister;  	TokenRegister op2 = ins.Operands [1] as TokenRegister;  	str.Emit (new QuasarInstruction (Opcode.SWP' new RegisterOperand (op1.Register)' new RegisterOperand (op2.Register)));  }  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleInstruction,The following statement contains a magic number: if (list [0] is TokenIdentifier) {  	string name = list [0].ToString ();  	List<AbstractToken> operands = new List<AbstractToken> ();  	for (int pos = 1; pos < list.Count; pos++) {  		if (pos % 2 != 0)  			operands.Add (list [pos]);  		else if (!(list [pos] is TokenComma))  			CreateError ("Comma or EOL expected!");  	}  	this.instructions.Add (new Instruction (list [0].Line' name' operands));  }  else  	CreateError ("Mnemonic expected!");  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleInstruction,The following statement contains a magic number: for (int pos = 1; pos < list.Count; pos++) {  	if (pos % 2 != 0)  		operands.Add (list [pos]);  	else if (!(list [pos] is TokenComma))  		CreateError ("Comma or EOL expected!");  }  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleInstruction,The following statement contains a magic number: if (pos % 2 != 0)  	operands.Add (list [pos]);  else if (!(list [pos] is TokenComma))  	CreateError ("Comma or EOL expected!");  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleDirective,The following statement contains a magic number: if (list [0] is TokenIdentifier) {  	string name = list [0].ToString ();  	List<AbstractToken> operands = new List<AbstractToken> ();  	for (int pos = 1; pos < list.Count; pos++) {  		if (pos % 2 != 0)  			operands.Add (list [pos]);  		else if (!(list [pos] is TokenComma))  			CreateError ("Comma or EOL expected!");  	}  	this.instructions.Add (new PreprocessorDirective (list [0].Line' name' operands));  }  else  	CreateError ("Mnemonic expected!");  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleDirective,The following statement contains a magic number: for (int pos = 1; pos < list.Count; pos++) {  	if (pos % 2 != 0)  		operands.Add (list [pos]);  	else if (!(list [pos] is TokenComma))  		CreateError ("Comma or EOL expected!");  }  
Magic Number,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,parseSingleDirective,The following statement contains a magic number: if (pos % 2 != 0)  	operands.Add (list [pos]);  else if (!(list [pos] is TokenComma))  	CreateError ("Comma or EOL expected!");  
Missing Default,GruntXProductions.Quasar.Assembler.Assemblers,JmpAssembler,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Assemblers\JmpAssembler.cs,Assemble,The following switch statement is missing a default case: switch (ins.Name) {  case "bc":  	code = QuasarConditionCode.C;  	break;  case "bs":  	code = QuasarConditionCode.N;  	break;  case "bv":  	code = QuasarConditionCode.V;  	break;  case "bz":  	code = QuasarConditionCode.Z;  	break;  case "be":  	code = QuasarConditionCode.EQ;  	break;  case "bne":  	code = QuasarConditionCode.NE;  	break;  case "ba":  	code = QuasarConditionCode.AB;  	break;  case "bb":  	code = QuasarConditionCode.BL;  	break;  case "bl":  	code = QuasarConditionCode.LT;  	break;  case "bg":  	code = QuasarConditionCode.GT;  	break;  case "ble":  	code = QuasarConditionCode.LE;  	break;  case "bge":  	code = QuasarConditionCode.GE;  	break;  }  
Missing Default,GruntXProductions.Quasar.Assembler.Parser,Parser,C:\repos\GruntTheDivine_quasar-sharp\src\Qasm\Parser\Parser.cs,ProcessTokens,The following switch statement is missing a default case: switch (dir.Name) {  case "include":  	newInstructions.AddRange (parseInclude (dir));  	break;  }  
