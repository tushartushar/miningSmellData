Implementation smell,Namespace,Class,File,Method,Description
Long Method,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,Parse,The method has 114 lines of code.
Long Method,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseArgument,The method has 192 lines of code.
Long Method,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,The method has 132 lines of code.
Long Method,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The method has 124 lines of code.
Complex Method,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseOptionalArgument,Cyclomatic complexity of the method is 9
Complex Method,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseArgument,Cyclomatic complexity of the method is 19
Complex Method,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,Cyclomatic complexity of the method is 25
Complex Method,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,Cyclomatic complexity of the method is 15
Complex Method,clipr.Utils,StringExtensions,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Utils\StringExtensions.cs,ReflowWords,Cyclomatic complexity of the method is 14
Long Parameter List,clipr.Core,IndexerValueStore,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\IndexerValueStore.cs,IndexerValueStore,The method has 5 parameters. Parameters: name' key' getter' setter' converters
Long Parameter List,clipr.Core,VerbParserConfig<TVerb>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\VerbParserConfig.cs,VerbParserConfig,The method has 5 parameters. Parameters: internalParserConfig' store' options' factory' precursorVerbs
Long Parameter List,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseVarargs,The method has 5 parameters. Parameters: attrName' list' arg' args' positionalDelimiterFound
Long Parameter List,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,AppendNamedArgumentList,The method has 6 parameters. Parameters: helpDataBuilder' sectionTitle' args' tabstop' lineWidth' prevSection
Long Identifier,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,,The length of the parameter _parsedMutuallyExclusiveGroups is 30.
Long Statement,clipr,CliParserBuilder<TConf>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\CliParserBuilder.cs,HasVerb,The length of the statement  "                subConfig = new AttributeParserConfig<TArg>(Options' null /* TODO process triggers in verb */' FluentConfig.VerbFactory);" is 121.
Long Statement,clipr,CliParserBuilder<TConf>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\CliParserBuilder.cs,HasVerb,The length of the statement  "                new VerbParserConfig<TArg>(subConfig' GetDefinitionFromExpression(expr)' Options' subConfig.VerbFactory ?? FluentConfig.VerbFactory' null));" is 140.
Long Statement,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "            AppendNamedArgumentList(helpDataBuilder' RequiredNamedArgumentsTitle' namedRequiredDisplay' tabstop' lineWidth' prevSection);" is 125.
Long Statement,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "            AppendNamedArgumentList(helpDataBuilder' OptionalNamedArgumentsTitle' namedOptionalDisplay' tabstop' lineWidth' prevSection);" is 125.
Complex Conditional,clipr.Core,IntegrityChecker,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\IntegrityChecker.cs,ConvertibleConstValuesCheck,The conditional expression  "(attr.Action == ParseAction.StoreConst &&                         !attr.Store.Type.ValueIsConvertible(attr.Const)) ||                     (attr.Action == ParseAction.AppendConst &&                         !attr.Store.Type.ValueIsConvertibleGeneric(attr.Const))"  is complex.
Complex Conditional,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseVarargs,The conditional expression  "!positionalDelimiterFound &&                     stringValue != null &&                     stringValue.StartsWith(Config.ArgumentPrefix #if NET35                         .ToString(CultureInfo.InvariantCulture)) && #else                         .ToString()) && #endif                     (stringValue.Length > 1 && !Char.IsDigit(stringValue[1]))"  is complex.
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: const int ENTER = 13' BACKSP = 8' CTRLBACKSP = 127;
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: const int ENTER = 13' BACKSP = 8' CTRLBACKSP = 127;
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: const int ENTER = 13' BACKSP = 8' CTRLBACKSP = 127;
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: int[] FILTERED = { 0' 27' 9' 10 };
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: int[] FILTERED = { 0' 27' 9' 10 };
Magic Number,clipr,PromptIfValueMissing,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\PromptIfValueMissing.cs,InsecureMaskedPrompt,The following statement contains a magic number: int[] FILTERED = { 0' 27' 9' 10 };
Magic Number,clipr.Core,ParserConfig<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParserConfig.cs,GetLongName,The following statement contains a magic number: arg.LongName.Length < 2
Magic Number,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: var partition = arg.Substring(2).Split(                             new []{Config.LongOptionSeparator}' 2);
Magic Number,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: var partition = arg.Substring(2).Split(                             new []{Config.LongOptionSeparator}' 2);
Magic Number,clipr.Usage,AutomaticHelpGenerator<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Usage\AutomaticHelpGenerator.cs,AutomaticHelpGenerator,The following statement contains a magic number: MinDisplayWidth = new DisplayWidth(20);
Duplicate Code,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseArgument,The method contains a code clone-set at the following line numbers (starting from the method definition): ((35' 60)' (64' 89))
Missing Default,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseArgument,The following switch statement is missing a default case: switch (arg.Action)             {                 case ParseAction.Store:                     {                         if (!arg.ConsumesMultipleArgs)                         {                             if (remainingArgs.Count == 0)                             {                                 if(arg.Constraint == NumArgsConstraint.Optional)                                 {                                     var defaultValue = arg.Const;                                     object converted;                                     if (TryConvertFrom(store' defaultValue' out converted))                                     {                                         store.SetValue(Object' converted);                                     }                                     else                                     {                                         throw new ParseException(attrName' String.Format(                                             @"Argument {0} value ""{1}"" cannot be converted to the " +                                             "required type {2}."'                                             attrName' defaultValue' store.Type));                                     }                                     break;                                 }                                 else if (!arg.PromptIfValueMissing.Enabled)                                 {                                     throw new ParseException(attrName' String.Format(                                         @"Argument ""{0}"" requires a value but " +                                         "none was provided."' attrName));                                 }                                 else                                 {                                     var value = arg.PromptIfValueMissing.Prompt(attrName);                                     try                                     {                                         object converted;                                         if (TryConvertFrom(store' value' out converted))                                         {                                             store.SetValue(Object' converted);                                         }                                         else                                         {                                             throw new ParseException(attrName' String.Format(                                                 @"Argument {0} value ""{1}"" cannot be converted to the " +                                                 "required type {2}."'                                                 attrName' value' store.Type));                                         }                                     }                                     catch (Exception e)                                     {                                         throw new ParseException(attrName' String.Format(                                             @"Argument {0} value ""{1}"" cannot be converted to the " +                                             "required type {2}."'                                              attrName' value' store.Type)' e);                                     }                                     break;                                 }                             }                             var stringValue = remainingArgs.Pop();                             if(arg.PromptIfValueMissing.Enabled && stringValue == arg.PromptIfValueMissing.SignalString)                             {                                 var value = arg.PromptIfValueMissing.Prompt(attrName);                                 try                                 {                                     object converted;                                     if (TryConvertFrom(store' value' out converted))                                     {                                         store.SetValue(Object' converted);                                     }                                     else                                     {                                         throw new ParseException(attrName' String.Format(                                             @"Argument {0} value ""{1}"" cannot be converted to the " +                                             "required type {2}."'                                             attrName' value' store.Type));                                     }                                 }                                 catch (Exception e)                                 {                                     throw new ParseException(attrName' String.Format(                                         @"Argument {0} value ""{1}"" cannot be converted to the " +                                         "required type {2}."'                                          attrName' value' store.Type)' e);                                 }                                 break;                             }                              try                             {                                 object converted;                                 if (TryConvertFrom(store' stringValue' out converted))                                 {                                     store.SetValue(Object' converted);                                 }                                 else                                 {                                     throw new ParseException(attrName' String.Format(                                         @"Argument {0} value ""{1}"" cannot be converted to the " +                                         "required type {2}."'                                         attrName' stringValue' store.Type));                                 }                             }                             catch (Exception e)                             {                                 throw new ParseException(attrName' String.Format(                                     @"Argument {0} value ""{1}"" cannot be converted to the " +                                     "required type {2}."'                                      attrName' stringValue' store.Type)' e);                             }                         }                         else                         {                             var existing = (IEnumerable)store.GetValue(Object);                             var backingList = CreateGenericList(store' existing);                              ParseVarargs(attrName' backingList' arg' remainingArgs' positionalDelimiterFound);                             store.SetValue(Object' backingList);                         }                         break;                     }                 case ParseAction.StoreConst:                     store.SetValue(Object' arg.Const);                     break;                  case ParseAction.StoreTrue:                     store.SetValue(Object' true);                     break;                  case ParseAction.StoreFalse:                     store.SetValue(Object' false);                     break;                  case ParseAction.Append:                     {                         var existing = (IEnumerable)store.GetValue(Object);                         var backingList = CreateGenericList(store' existing);                          if (!arg.ConsumesMultipleArgs)                         {                             if (remainingArgs.Count == 0)                             {                                 throw new ParseException(attrName);                             }                             var stringValue = remainingArgs.Pop();                             try                             {                                 object converted;                                 if (TryConvertFromGeneric(store' stringValue' out converted))                                 {                                     backingList.Add(converted);                                 }                                 else                                 {                                     throw new ParseException(attrName' String.Format(                                         @"Argument {0} value ""{1}"" cannot be converted to the " +                                         "required type {2}."'                                         attrName' stringValue' arg.Store.Type));                                 }                             }                             catch (Exception e)                             {                                 throw new ParseException(attrName' String.Format(                                     @"Argument {0} value ""{1}"" cannot be converted to the " +                                     "required type {2}."'                                     attrName' stringValue' store.Type)' e);                             }                         }                         else                         {                             ParseVarargs(attrName' backingList' arg' remainingArgs' positionalDelimiterFound);                          }                         store.SetValue(Object' backingList);                         break;                     }                 case ParseAction.AppendConst:                     {                         var existing = (IEnumerable) store.GetValue(Object);                         var backingList = CreateGenericList(store' existing);                         backingList.Add(arg.Const);                         store.SetValue(Object' backingList);                         break;                     }                 case ParseAction.Count:                     var cnt = (int)store.GetValue(Object);                     store.SetValue(Object' cnt + 1);                     break;             }
Missing Default,clipr.Core,ParsingContext<T>,C:\research\architectureSmells\repos\nemec_clipr\src\clipr\Core\ParsingContext.cs,ParseVarargs,The following switch statement is missing a default case: switch (arg.Constraint)             {                 case NumArgsConstraint.Exactly:                     minArgs = arg.NumArgs;                     maxArgs = arg.NumArgs;                     break;                 case NumArgsConstraint.AtLeast:                     minArgs = arg.NumArgs;                     maxArgs = uint.MaxValue;                     break;                 case NumArgsConstraint.AtMost:                     minArgs = 0;                     maxArgs = arg.NumArgs;                     break;             }
