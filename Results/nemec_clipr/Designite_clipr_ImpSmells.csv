Implementation smell,Namespace,Class,File,Method,Description
Long Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The method has 82 lines of code.
Long Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The method has 111 lines of code.
Long Method,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,The method has 65 lines of code.
Complex Method,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,InitializeTriggers,Cyclomatic complexity of the method is 7
Complex Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseOptionalArgument,Cyclomatic complexity of the method is 7
Complex Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,GetArgument,Cyclomatic complexity of the method is 7
Complex Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,Cyclomatic complexity of the method is 35
Complex Method,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,Cyclomatic complexity of the method is 17
Complex Method,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,Cyclomatic complexity of the method is 19
Complex Method,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,Cyclomatic complexity of the method is 8
Complex Method,clipr.Utils,StringExtensions,D:\newReposJune17\nemec_clipr\clipr\Utils\StringExtensions.cs,ReflowWords,Cyclomatic complexity of the method is 14
Long Parameter List,clipr,CliParser,D:\newReposJune17\nemec_clipr\clipr\CliParser.cs,CliParser,The method has 4 parameters.
Long Parameter List,clipr.Core,IndexerValueStore,D:\newReposJune17\nemec_clipr\clipr\Core\IndexerValueStore.cs,IndexerValueStore,The method has 5 parameters.
Long Parameter List,clipr.Core,VerbParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\VerbParserConfig.cs,VerbParserConfig,The method has 4 parameters.
Long Parameter List,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseOptionalArgument,The method has 4 parameters.
Long Parameter List,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseOptionalArgument,The method has 4 parameters.
Long Parameter List,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseOptionalArgument,The method has 4 parameters.
Long Parameter List,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The method has 4 parameters.
Long Parameter List,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The method has 5 parameters.
Long Parameter List,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,AppendNamedArgumentList,The method has 6 parameters.
Long Parameter List,clipr.Utils,StringExtensions,D:\newReposJune17\nemec_clipr\clipr\Utils\StringExtensions.cs,FindPreviousSeparator,The method has 4 parameters.
Long Parameter List,clipr.Utils,StringExtensions,D:\newReposJune17\nemec_clipr\clipr\Utils\StringExtensions.cs,FindPreviousNonSeparator,The method has 4 parameters.
Long Statement,clipr,CliParserBuilder,D:\newReposJune17\nemec_clipr\clipr\CliParserBuilder.cs,HasVerb,The length of the statement  "		subConfig = new AttributeParserConfig<TArg> (Options' null/* TODO process triggers in verb */' FluentConfig.VerbFactory); " is 121.
Long Statement,clipr,CliParserBuilder,D:\newReposJune17\nemec_clipr\clipr\CliParserBuilder.cs,HasVerb,The length of the statement  "	FluentConfig.Verbs.Add (verbName' new VerbParserConfig<TArg> (subConfig' GetDefinitionFromExpression (expr)' Options' subConfig.VerbFactory ?? FluentConfig.VerbFactory)); " is 170.
Long Statement,clipr,CliParserBuilder,D:\newReposJune17\nemec_clipr\clipr\CliParserBuilder.cs,GetDefinitionFromExpression,The length of the statement  "		var converters = getter.ReturnType.GetTypeInfo ().GetCustomAttributes<TypeConverterAttribute> ().Select (a => Activator.CreateInstance (Type.GetType (a.ConverterTypeName))).OfType<TypeConverter> ().ToArray (); " is 209.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,EnsureAttributeIntegrity,The length of the statement  "	var properties = typeof(T).GetTypeInfo ().GetProperties ().Where (p => p.GetCustomAttributes<ArgumentAttribute> ().Any ()); " is 123.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,EnsureAttributeIntegrity,The length of the statement  "			integrityExceptions.Add (new ArgumentIntegrityException ("Cannot provide multiple ArgumentAttributes on a " + "single property."' e)); " is 134.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,NumArgsGreaterThanZeroCheck,The length of the statement  "		return new ArgumentIntegrityException ("A NumArgs value of zero may only be the lower bound " + "on the number of arguments (NumArgsConstraint.AtLeast). " + "Any actions that do not require arguments will " + "ignore this property regardless of its value."); " is 258.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,VarArgsConvertibleToIEnumerableCheck,The length of the statement  "		return new ArgumentIntegrityException ("Arguments with a variable number of values or " + "more than one required value must be attached " + "to a parameter assignable to IEnumerable."); " is 186.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,OptionalConstraintMustIncludeConstIfNonNullable,The length of the statement  "		return new ArgumentIntegrityException ("Non-nullable arguments with an Optional constraint must include" + "a const value in case value is not provided at runtime."); " is 166.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ShortNameArgumentMustBeValidCharacter,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Invalid argument {0}: {1}"' sh.ShortName' ArgumentValidation.IsAllowedShortNameExplanation)); " is 148.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,LongNameArgumentMustBeValidCharacter,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Invalid argument {0}: {1}"' sh.LongName' ArgumentValidation.IsAllowedLongNameExplanation)); " is 146.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PositionalArgumentsCannotStoreConstValues,The length of the statement  "	if (attr is PositionalArgumentAttribute && (attr.Action == ParseAction.StoreConst || attr.Action == ParseAction.AppendConst)) { " is 127.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PositionalArgumentsCannotStoreConstValues,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Positional argument {0} cannot store " + "const values because the argument will always " + "be required."' attr.Name)); " is 175.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PositionalArgumentsCannotAppendValues,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Positional argument {0} cannot " + @"""append"" values."' attr.Name)); " is 125.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PositionalArgumentsCannotStoreCount,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Positional argument {0} cannot store " + "a count."' attr.Name)); " is 120.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,AppendConvertibleToIEnumerable,The length of the statement  "	if ((attr.Action == ParseAction.Append || attr.Action == ParseAction.AppendConst) && !attr.Store.Type.IsValidEnumerable ()) { " is 125.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,AppendConvertibleToIEnumerable,The length of the statement  "		return new ArgumentIntegrityException ("Arguments with a ParseAction of 'Append' " + "or 'AppendConst' must be attached to a " + "parameter assignable to IEnumerable<>."); " is 171.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,CountActionConvertibleToIntCheck,The length of the statement  "		return new ArgumentIntegrityException ("Arguments with a ParseAction of 'Count' must be " + "attached to a property with a type assignable to int."); " is 149.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,StoreTrueFalseConvertibleToBoolCheck,The length of the statement  "	if ((attr.Action == ParseAction.StoreTrue || attr.Action == ParseAction.StoreFalse) && !attr.Store.Type.IsValid<bool> ()) { " is 123.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,StoreTrueFalseConvertibleToBoolCheck,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Argument {0} with a" + "ParseAction of 'StoreTrue' or " + "'StoreFalse' must be attached to a property with " + "a type assignable to bool."' attr.Name)); " is 209.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConstActionsCannotHaveNullValueCheck,The length of the statement  "	if ((attr.Action == ParseAction.StoreConst || attr.Action == ParseAction.AppendConst) && attr.Const == attr.Store.Type.GetDefaultValue ()) { " is 140.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConstActionsCannotHaveNullValueCheck,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Argument {0} with a const action " + "must be provided with a non-null Const value."' attr.Name)); " is 153.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConvertibleConstValuesCheck,The length of the statement  "	if ((attr.Action == ParseAction.StoreConst && !attr.Store.Type.ValueIsConvertible (attr.Const)) || (attr.Action == ParseAction.AppendConst && !attr.Store.Type.ValueIsConvertibleGeneric (attr.Const))) { " is 201.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConvertibleConstValuesCheck,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Argument {0} with a const action " + "must be convertible to the property's type."' attr.Name)); " is 151.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,LastPositionalArgumentCanTakeMultipleValuesCheck,The length of the statement  "	var props = typeof(T).GetTypeInfo ().GetProperties ().Where (p => p.GetCustomAttribute<PositionalArgumentAttribute> () != null).OrderBy (p => p.GetCustomAttribute<PositionalArgumentAttribute> ().Index).ToList (); " is 212.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,LastPositionalArgumentCanTakeMultipleValuesCheck,The length of the statement  "			return new ArgumentIntegrityException (String.Format ("Positional argument {0} is not the " + "last positional argument so it must take " + "a constant number of values."' prop.Name)); " is 184.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConfigMayNotContainBothPositionalArgumentsAndVerbs,The length of the statement  "	var positionalCount = typeof(T).GetTypeInfo ().GetProperties ().Count (p => p.GetCustomAttribute<PositionalArgumentAttribute> () != null); " is 138.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConfigMayNotContainBothPositionalArgumentsAndVerbs,The length of the statement  "		return new ArgumentIntegrityException ("Configuration object may not contain both " + "Positional arguments and Verbs."); " is 121.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,VerbMustHaveFactoryDefined,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("Verb '{0}' has no default constructor or factory defined for its type. Use a custom IVerbFactory for this parser."' verbProp.Name)); " is 187.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,CannotDefineDuplicateVerbs,The length of the statement  "	var verbs = typeof(T).GetTypeInfo ().GetProperties ().SelectMany (p => p.GetCustomAttributes<VerbAttribute> ().Select (a => new { " is 129.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PostParseZeroParametersCheck,The length of the statement  "	var invalidPostParseMethods = typeof(T).GetTypeInfo ().GetMethods ().Where (m => m.GetCustomAttribute<PostParseAttribute> () != null).Where (m => m.GetParameters ().Length != 0); " is 178.
Long Statement,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,PostParseZeroParametersCheck,The length of the statement  "		return new ArgumentIntegrityException (String.Format ("The PostParse method {0} must have " + "zero parameters."' method.Name)); " is 128.
Long Statement,clipr.Core,AttributeParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\AttributeParserConfig.cs,InitializeRequiredMutuallyExclusiveArguments,The length of the statement  "	RequiredMutuallyExclusiveArguments.UnionWith (typeof(T).GetTypeInfo ().GetProperties ().SelectMany (p => p.GetCustomAttributes<MutuallyExclusiveGroupAttribute> ().Where (a => a.Required).Select (a => a.Name))); " is 210.
Long Statement,clipr.Core,AttributeParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\AttributeParserConfig.cs,InitializePositionalArguments,The length of the statement  "	PositionalArguments.AddRange (typeof(T).GetTypeInfo ().GetProperties ().Where (p => p.GetCustomAttribute<PositionalArgumentAttribute> () != null).OrderBy (p => p.GetCustomAttribute<PositionalArgumentAttribute> ().Index).Select (p => p.ToPositionalArgument ())); " is 261.
Long Statement,clipr.Core,AttributeParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\AttributeParserConfig.cs,InitializeNamedArguments,The length of the statement  "	var props = typeof(T).GetTypeInfo ().GetProperties ().Where (p => p.GetCustomAttribute<NamedArgumentAttribute> () != null); " is 123.
Long Statement,clipr.Core,AttributeParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\AttributeParserConfig.cs,InitializeVerbs,The length of the statement  "	foreach (var prop in typeof(T).GetTypeInfo ().GetProperties ().Where (p => p.GetCustomAttributes<VerbAttribute> ().Any ())) { " is 125.
Long Statement,clipr.Core,AttributeParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\AttributeParserConfig.cs,InitializePostParseMethods,The length of the statement  "	PostParseMethods.AddRange (typeof(T).GetTypeInfo ().GetMethods ().Where (p => p.GetCustomAttribute<PostParseAttribute> () != null)); " is 132.
Long Statement,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,InitializeTriggers,The length of the statement  "		var sn = GetShortName (trigger' String.Format ("Trigger '{0}' argument {1} is not a valid short name. {2}"' trigger.PluginName' trigger.ShortName' ArgumentValidation.IsAllowedShortNameExplanation)); " is 198.
Long Statement,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,InitializeTriggers,The length of the statement  "		var ln = GetLongName (trigger' String.Format ("Trigger '{0}' argument {1} is not a valid long name. {2}"' trigger.PluginName' trigger.LongName' ArgumentValidation.IsAllowedLongNameExplanation)); " is 194.
Long Statement,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,GetShortName,The length of the statement  "	return GetShortName (arg' String.Format ("Short name {0} is not allowed. {1}"' arg.ShortName' ArgumentValidation.IsAllowedShortNameExplanation)); " is 145.
Long Statement,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,GetLongName,The length of the statement  "	return GetLongName (arg' String.Format ("Long name {0} is not allowed. {1}"' arg.LongName' ArgumentValidation.IsAllowedLongNameExplanation)); " is 141.
Long Statement,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,GetLongName,The length of the statement  "			throw new ArgumentIntegrityException (String.Format ("Long argument {0} must have at least two characters."' arg.LongName)); " is 124.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The length of the statement  "				throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter)); " is 204.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The length of the statement  "		throw new ParseException (null' String.Format ("Extra positional arguments found: {0}"' String.Join (" "' positionalArgStack.ToArray ()))); " is 139.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,GetArgument,The length of the statement  "		var cmp = options.HasFlag (ParserOptions.CaseInsensitive) ? StringComparer.CurrentCultureIgnoreCase : StringComparer.CurrentCulture; " is 132.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "						throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' defaultValue' store.Type)); " is 170.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "					throw new ParseException (attrName' String.Format (@"Argument ""{0}"" requires a value but " + "none was provided."' attrName)); " is 128.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "							throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)); " is 163.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "						throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)' e); " is 166.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "						throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)); " is 163.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)' e); " is 166.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type)); " is 169.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type)' e); " is 172.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' arg.Store.Type)); " is 173.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The length of the statement  "				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type)' e); " is 172.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The length of the statement  "				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' arg.Store.Type)); " is 173.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The length of the statement  "			throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' arg.Store.Type)' e); " is 176.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The length of the statement  "		throw new ParseException (attrName' String.Format ("Parameter {0} requires {1} {2} value(s)."' arg.MetaVar ?? arg.Name' arg.Constraint == NumArgsConstraint.Exactly ? "exactly" : "at least"' minArgs)); " is 200.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParsingCleanup,The length of the statement  "	var missingRequiredMutexGroups = Config.RequiredMutuallyExclusiveArguments.Except (_parsedMutuallyExclusiveGroups).ToArray (); " is 126.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParsingCleanup,The length of the statement  "		throw new ParseException (null' String.Format (@"Required mutually exclusive group(s) ""{0}"" were " + "not provided."' String.Join ("' "' missingRequiredMutexGroups))); " is 169.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParsingCleanup,The length of the statement  "		throw new ParseException (null' String.Format (@"Required named argument(s) ""{0}"" were " + "not provided."' String.Join ("' "' missingRequiredNamedArguments))); " is 162.
Long Statement,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,TryConvertFrom,The length of the statement  "	var customConverter = store.Converters != null ? store.Converters.FirstOrDefault (c => c.CanConvertFrom (typeof(string))) : null; " is 129.
Long Statement,clipr.IOC,ParameterlessVerbFactory,D:\newReposJune17\nemec_clipr\clipr\IOC\ParameterlessVerbFactory.cs,GetVerb,The length of the statement  "			throw new ArgumentException (String.Format ("Option or verb type '{0}' has no parameterless constructor. Use a custom IVerbFactory for IOC."' objectType)); " is 155.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,The length of the statement  "	builder.Append (Path.GetFileNameWithoutExtension (assembly != null ? assembly.Location : typeof(AutomaticHelpGenerator<T>).GetTypeInfo ().Assembly.CodeBase)); " is 158.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetUsage,The length of the statement  "	foreach (var arg in config.LongNameArguments.Values.Cast<INamedArgument> ().Concat (config.ShortNameArguments.Values.Cast<INamedArgument> ()).Distinct ()) { " is 156.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "	var namedArgs = config.LongNameArguments.Values.Cast<INamedArgument> ().Concat (config.ShortNameArguments.Values.Cast<INamedArgument> ()).Distinct ().ToList (); " is 160.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "	var tabstop = positionalDisplay.Concat (namedRequiredDisplay).Concat (namedOptionalDisplay).Select (a => a.ArgumentNames.Length).Max () + Indent.Length + Spacing; " is 162.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "	AppendNamedArgumentList (helpDataBuilder' RequiredNamedArgumentsTitle' namedRequiredDisplay' tabstop' lineWidth' prevSection); " is 126.
Long Statement,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,GetHelp,The length of the statement  "	AppendNamedArgumentList (helpDataBuilder' OptionalNamedArgumentsTitle' namedOptionalDisplay' tabstop' lineWidth' prevSection); " is 126.
Long Statement,clipr.Utils,AttributeConverter,D:\newReposJune17\nemec_clipr\clipr\Utils\AttributeConverter.cs,GetConverters,The length of the statement  "	var types = prop.GetCustomAttributes<TypeConverterAttribute> ().Select (attr => Type.GetType (attr.ConverterTypeName)).Where (t => t != null).Select (Activator.CreateInstance); " is 176.
Long Statement,clipr.Utils,AttributeConverter,D:\newReposJune17\nemec_clipr\clipr\Utils\AttributeConverter.cs,GetConverters,The length of the statement  "	var types = typeInfo.GetCustomAttributes<TypeConverterAttribute> ().Select (attr => Type.GetType (attr.ConverterTypeName)).Where (t => t != null).Select (Activator.CreateInstance); " is 180.
Long Statement,clipr.Utils,AttributeConverter,D:\newReposJune17\nemec_clipr\clipr\Utils\AttributeConverter.cs,GetStaticEnumerationConverter,The length of the statement  "	var attr = prop.GetCustomAttribute<StaticEnumerationAttribute> () ?? typeInfo.GetCustomAttribute<StaticEnumerationAttribute> (); " is 128.
Long Statement,clipr.Utils,AttributeConverter,D:\newReposJune17\nemec_clipr\clipr\Utils\AttributeConverter.cs,GetLocalizationInfo,The length of the statement  "			throw new ArgumentException (String.Format ("The property '{0}' or its parent class '{1}' must define a ResourceType in order to be localized."' prop.Name' prop.DeclaringType.Name)); " is 182.
Long Statement,clipr.Utils,AttributeConverter,D:\newReposJune17\nemec_clipr\clipr\Utils\AttributeConverter.cs,GetLocalizationInfo,The length of the statement  "		throw new ArgumentException (String.Format ("The class '{0}' must define a ResourceType in order to be localized."' type.Name)); " is 128.
Long Statement,clipr.Utils,EnumUtils,D:\newReposJune17\nemec_clipr\clipr\Utils\EnumUtils.cs,IsStaticEnum,The length of the statement  "	return (store.GetCustomAttribute<StaticEnumerationAttribute> () ?? store.Type.GetTypeInfo ().GetCustomAttribute<StaticEnumerationAttribute> ()) != null; " is 152.
Long Statement,clipr.Utils,EnumUtils,D:\newReposJune17\nemec_clipr\clipr\Utils\EnumUtils.cs,GetEnumValues,The length of the statement  "		return typeInfo.GetFields (BindingFlags.Public | BindingFlags.Static).Where (f => f.IsInitOnly && typeInfo.IsAssignableFrom (f.FieldType)).Select (f => f.Name).ToArray (); " is 171.
Long Statement,clipr.Utils,PropertyExtensions,D:\newReposJune17\nemec_clipr\clipr\Utils\PropertyExtensions.cs,IsValidEnumerable,The length of the statement  "	return typeInfo.IsGenericType && (typeInfo.GetGenericTypeDefinition () == enumT || typeInfo.GetInterfaces ().Any (t => t.GetTypeInfo ().IsGenericType && t.GetTypeInfo ().GetGenericTypeDefinition () == enumT)); " is 209.
Long Statement,clipr.Utils,PropertyExtensions,D:\newReposJune17\nemec_clipr\clipr\Utils\PropertyExtensions.cs,ValueIsConvertibleGeneric,The length of the statement  "	return obj == null || t.GetTypeInfo ().GetGenericArguments ().First () == obj.GetType () || TypeDescriptor.GetConverter (t).IsValid (obj); " is 138.
Complex Conditional,clipr.Core,IntegrityChecker,D:\newReposJune17\nemec_clipr\clipr\Core\IntegrityChecker.cs,ConvertibleConstValuesCheck,The conditional expression  "(attr.Action == ParseAction.StoreConst && !attr.Store.Type.ValueIsConvertible (attr.Const)) || (attr.Action == ParseAction.AppendConst && !attr.Store.Type.ValueIsConvertibleGeneric (attr.Const))"  is complex.
Complex Conditional,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The conditional expression  "!positionalDelimiterFound && stringValue != null && stringValue.StartsWith (Config.ArgumentPrefix  #if NET35  .ToString (CultureInfo.InvariantCulture)) &&   #else                          .ToString()) && #endif  (stringValue.Length > 1 && !Char.IsDigit (stringValue [1]))"  is complex.
Magic Number,clipr,CliParser,D:\newReposJune17\nemec_clipr\clipr\CliParser.cs,StrictParse,The following statement contains a magic number: try {  	parser = new CliParser<TS> (obj);  } catch (ArgumentIntegrityException e) {  	Console.Error.WriteLine (e.Message);  	if (parser != null && parser.Config != null) {  		Console.Error.WriteLine (new AutomaticHelpGenerator<TS> ().GetUsage (parser.Config));  	}  	Environment.Exit (2);  } catch (Utils.AggregateException ex) {  	if (parser != null && parser.Config != null) {  		Console.Error.WriteLine (new AutomaticHelpGenerator<TS> ().GetUsage (parser.Config));  	}  	ex.Handle (e => {  		Console.Error.WriteLine (e.Message);  		return true;  	});  	Environment.Exit (2);  }  
Magic Number,clipr,CliParser,D:\newReposJune17\nemec_clipr\clipr\CliParser.cs,StrictParse,The following statement contains a magic number: try {  	parser = new CliParser<TS> (obj);  } catch (ArgumentIntegrityException e) {  	Console.Error.WriteLine (e.Message);  	if (parser != null && parser.Config != null) {  		Console.Error.WriteLine (new AutomaticHelpGenerator<TS> ().GetUsage (parser.Config));  	}  	Environment.Exit (2);  } catch (Utils.AggregateException ex) {  	if (parser != null && parser.Config != null) {  		Console.Error.WriteLine (new AutomaticHelpGenerator<TS> ().GetUsage (parser.Config));  	}  	ex.Handle (e => {  		Console.Error.WriteLine (e.Message);  		return true;  	});  	Environment.Exit (2);  }  
Magic Number,clipr,CliParser,D:\newReposJune17\nemec_clipr\clipr\CliParser.cs,StrictParse,The following statement contains a magic number: Environment.Exit (2);  
Magic Number,clipr,CliParser,D:\newReposJune17\nemec_clipr\clipr\CliParser.cs,StrictParse,The following statement contains a magic number: Environment.Exit (2);  
Magic Number,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,GetLongName,The following statement contains a magic number: if (arg.LongName != null) {  	if (arg.LongName.Length < 2) {  		throw new ArgumentIntegrityException (String.Format ("Long argument {0} must have at least two characters."' arg.LongName));  	}  	if (!ArgumentValidation.IsAllowedLongName (arg.LongName)) {  		throw new ArgumentIntegrityException (errorMessage);  	}  	return arg.LongName;  }  
Magic Number,clipr.Core,ParserConfig,D:\newReposJune17\nemec_clipr\clipr\Core\ParserConfig.cs,GetLongName,The following statement contains a magic number: if (arg.LongName.Length < 2) {  	throw new ArgumentIntegrityException (String.Format ("Long argument {0} must have at least two characters."' arg.LongName));  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: while (values.Count > 0) {  	var arg = values.Pop ();  	// Empty arg  	if (string.IsNullOrEmpty (arg)) {  		continue;  	}  	// Rest of arguments are positional  	if (arg == positionalDelimiter) {  		positionalDelimiterFound = true;  		positionalArgumentStore.AddRange (values);  		break;  	}  	if (arg [0] == Config.ArgumentPrefix) {  		if (arg.Length == 1)// myprog.exe -  		 {  			throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  		}  		if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  		 {  			var partition = arg.Substring (2).Split (new[] {  				Config.LongOptionSeparator  			}' 2);  			if (partition.Length > 1) {  				values.Push (partition [1]);  			}  			ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  		} else// myprog.exe -a  		 {  			var shortArg = arg [1];  			if (Char.IsDigit (shortArg))// myprog.exe -1  			 {  				// We're parsing a negative number...  				// Nothing to see here.  				positionalArgumentStore.Add (arg);  				continue;  			}  			if (arg.Length > 2) {  				// Pretend the rest of the argument is a new value  				values.Push (arg.Substring (2));  				var stackSize = values.Count;  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  				// No arguments were used... the arg  				// we just pushed must be a group of  				// short args.  				if (values.Count == stackSize) {  					foreach (var shortName in values.Pop ()) {  						// Arguments in a group cannot consume  						// values from the argStack  						ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  					}  				}  			} else// Just a single argument  			 {  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  		continue;  	}  	// Only first positional argument is eligible to be a verb  	if (!positionalArgumentStore.Any () && Config.Verbs.ContainsKey (arg)) {  		var verbConfig = Config.Verbs [arg];  		var verbObj = Config.VerbFactory.GetVerb (verbConfig.Store.Type);  		var context = ParsingContextFactory.Create (verbObj' verbConfig.Store.Type' verbConfig);  		context.Parse (values.ToArray ());  		verbConfig.Store.SetValue (Object' verbObj);  		break;  	}  	positionalArgumentStore.Add (arg);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: while (values.Count > 0) {  	var arg = values.Pop ();  	// Empty arg  	if (string.IsNullOrEmpty (arg)) {  		continue;  	}  	// Rest of arguments are positional  	if (arg == positionalDelimiter) {  		positionalDelimiterFound = true;  		positionalArgumentStore.AddRange (values);  		break;  	}  	if (arg [0] == Config.ArgumentPrefix) {  		if (arg.Length == 1)// myprog.exe -  		 {  			throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  		}  		if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  		 {  			var partition = arg.Substring (2).Split (new[] {  				Config.LongOptionSeparator  			}' 2);  			if (partition.Length > 1) {  				values.Push (partition [1]);  			}  			ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  		} else// myprog.exe -a  		 {  			var shortArg = arg [1];  			if (Char.IsDigit (shortArg))// myprog.exe -1  			 {  				// We're parsing a negative number...  				// Nothing to see here.  				positionalArgumentStore.Add (arg);  				continue;  			}  			if (arg.Length > 2) {  				// Pretend the rest of the argument is a new value  				values.Push (arg.Substring (2));  				var stackSize = values.Count;  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  				// No arguments were used... the arg  				// we just pushed must be a group of  				// short args.  				if (values.Count == stackSize) {  					foreach (var shortName in values.Pop ()) {  						// Arguments in a group cannot consume  						// values from the argStack  						ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  					}  				}  			} else// Just a single argument  			 {  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  		continue;  	}  	// Only first positional argument is eligible to be a verb  	if (!positionalArgumentStore.Any () && Config.Verbs.ContainsKey (arg)) {  		var verbConfig = Config.Verbs [arg];  		var verbObj = Config.VerbFactory.GetVerb (verbConfig.Store.Type);  		var context = ParsingContextFactory.Create (verbObj' verbConfig.Store.Type' verbConfig);  		context.Parse (values.ToArray ());  		verbConfig.Store.SetValue (Object' verbObj);  		break;  	}  	positionalArgumentStore.Add (arg);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: while (values.Count > 0) {  	var arg = values.Pop ();  	// Empty arg  	if (string.IsNullOrEmpty (arg)) {  		continue;  	}  	// Rest of arguments are positional  	if (arg == positionalDelimiter) {  		positionalDelimiterFound = true;  		positionalArgumentStore.AddRange (values);  		break;  	}  	if (arg [0] == Config.ArgumentPrefix) {  		if (arg.Length == 1)// myprog.exe -  		 {  			throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  		}  		if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  		 {  			var partition = arg.Substring (2).Split (new[] {  				Config.LongOptionSeparator  			}' 2);  			if (partition.Length > 1) {  				values.Push (partition [1]);  			}  			ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  		} else// myprog.exe -a  		 {  			var shortArg = arg [1];  			if (Char.IsDigit (shortArg))// myprog.exe -1  			 {  				// We're parsing a negative number...  				// Nothing to see here.  				positionalArgumentStore.Add (arg);  				continue;  			}  			if (arg.Length > 2) {  				// Pretend the rest of the argument is a new value  				values.Push (arg.Substring (2));  				var stackSize = values.Count;  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  				// No arguments were used... the arg  				// we just pushed must be a group of  				// short args.  				if (values.Count == stackSize) {  					foreach (var shortName in values.Pop ()) {  						// Arguments in a group cannot consume  						// values from the argStack  						ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  					}  				}  			} else// Just a single argument  			 {  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  		continue;  	}  	// Only first positional argument is eligible to be a verb  	if (!positionalArgumentStore.Any () && Config.Verbs.ContainsKey (arg)) {  		var verbConfig = Config.Verbs [arg];  		var verbObj = Config.VerbFactory.GetVerb (verbConfig.Store.Type);  		var context = ParsingContextFactory.Create (verbObj' verbConfig.Store.Type' verbConfig);  		context.Parse (values.ToArray ());  		verbConfig.Store.SetValue (Object' verbObj);  		break;  	}  	positionalArgumentStore.Add (arg);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: while (values.Count > 0) {  	var arg = values.Pop ();  	// Empty arg  	if (string.IsNullOrEmpty (arg)) {  		continue;  	}  	// Rest of arguments are positional  	if (arg == positionalDelimiter) {  		positionalDelimiterFound = true;  		positionalArgumentStore.AddRange (values);  		break;  	}  	if (arg [0] == Config.ArgumentPrefix) {  		if (arg.Length == 1)// myprog.exe -  		 {  			throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  		}  		if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  		 {  			var partition = arg.Substring (2).Split (new[] {  				Config.LongOptionSeparator  			}' 2);  			if (partition.Length > 1) {  				values.Push (partition [1]);  			}  			ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  		} else// myprog.exe -a  		 {  			var shortArg = arg [1];  			if (Char.IsDigit (shortArg))// myprog.exe -1  			 {  				// We're parsing a negative number...  				// Nothing to see here.  				positionalArgumentStore.Add (arg);  				continue;  			}  			if (arg.Length > 2) {  				// Pretend the rest of the argument is a new value  				values.Push (arg.Substring (2));  				var stackSize = values.Count;  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  				// No arguments were used... the arg  				// we just pushed must be a group of  				// short args.  				if (values.Count == stackSize) {  					foreach (var shortName in values.Pop ()) {  						// Arguments in a group cannot consume  						// values from the argStack  						ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  					}  				}  			} else// Just a single argument  			 {  				ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  		continue;  	}  	// Only first positional argument is eligible to be a verb  	if (!positionalArgumentStore.Any () && Config.Verbs.ContainsKey (arg)) {  		var verbConfig = Config.Verbs [arg];  		var verbObj = Config.VerbFactory.GetVerb (verbConfig.Store.Type);  		var context = ParsingContextFactory.Create (verbObj' verbConfig.Store.Type' verbConfig);  		context.Parse (values.ToArray ());  		verbConfig.Store.SetValue (Object' verbObj);  		break;  	}  	positionalArgumentStore.Add (arg);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [0] == Config.ArgumentPrefix) {  	if (arg.Length == 1)// myprog.exe -  	 {  		throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  	}  	if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  	 {  		var partition = arg.Substring (2).Split (new[] {  			Config.LongOptionSeparator  		}' 2);  		if (partition.Length > 1) {  			values.Push (partition [1]);  		}  		ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  	} else// myprog.exe -a  	 {  		var shortArg = arg [1];  		if (Char.IsDigit (shortArg))// myprog.exe -1  		 {  			// We're parsing a negative number...  			// Nothing to see here.  			positionalArgumentStore.Add (arg);  			continue;  		}  		if (arg.Length > 2) {  			// Pretend the rest of the argument is a new value  			values.Push (arg.Substring (2));  			var stackSize = values.Count;  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			// No arguments were used... the arg  			// we just pushed must be a group of  			// short args.  			if (values.Count == stackSize) {  				foreach (var shortName in values.Pop ()) {  					// Arguments in a group cannot consume  					// values from the argStack  					ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  				}  			}  		} else// Just a single argument  		 {  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  	continue;  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [0] == Config.ArgumentPrefix) {  	if (arg.Length == 1)// myprog.exe -  	 {  		throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  	}  	if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  	 {  		var partition = arg.Substring (2).Split (new[] {  			Config.LongOptionSeparator  		}' 2);  		if (partition.Length > 1) {  			values.Push (partition [1]);  		}  		ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  	} else// myprog.exe -a  	 {  		var shortArg = arg [1];  		if (Char.IsDigit (shortArg))// myprog.exe -1  		 {  			// We're parsing a negative number...  			// Nothing to see here.  			positionalArgumentStore.Add (arg);  			continue;  		}  		if (arg.Length > 2) {  			// Pretend the rest of the argument is a new value  			values.Push (arg.Substring (2));  			var stackSize = values.Count;  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			// No arguments were used... the arg  			// we just pushed must be a group of  			// short args.  			if (values.Count == stackSize) {  				foreach (var shortName in values.Pop ()) {  					// Arguments in a group cannot consume  					// values from the argStack  					ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  				}  			}  		} else// Just a single argument  		 {  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  	continue;  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [0] == Config.ArgumentPrefix) {  	if (arg.Length == 1)// myprog.exe -  	 {  		throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  	}  	if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  	 {  		var partition = arg.Substring (2).Split (new[] {  			Config.LongOptionSeparator  		}' 2);  		if (partition.Length > 1) {  			values.Push (partition [1]);  		}  		ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  	} else// myprog.exe -a  	 {  		var shortArg = arg [1];  		if (Char.IsDigit (shortArg))// myprog.exe -1  		 {  			// We're parsing a negative number...  			// Nothing to see here.  			positionalArgumentStore.Add (arg);  			continue;  		}  		if (arg.Length > 2) {  			// Pretend the rest of the argument is a new value  			values.Push (arg.Substring (2));  			var stackSize = values.Count;  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			// No arguments were used... the arg  			// we just pushed must be a group of  			// short args.  			if (values.Count == stackSize) {  				foreach (var shortName in values.Pop ()) {  					// Arguments in a group cannot consume  					// values from the argStack  					ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  				}  			}  		} else// Just a single argument  		 {  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  	continue;  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [0] == Config.ArgumentPrefix) {  	if (arg.Length == 1)// myprog.exe -  	 {  		throw new ParseException (arg' String.Format (@"Cannot use argument prefix ""{0}"" as " + @"argument unless forced into positional " + @"mode using ""{1}""."' Config.ArgumentPrefix' positionalDelimiter));  	}  	if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg  	 {  		var partition = arg.Substring (2).Split (new[] {  			Config.LongOptionSeparator  		}' 2);  		if (partition.Length > 1) {  			values.Push (partition [1]);  		}  		ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  	} else// myprog.exe -a  	 {  		var shortArg = arg [1];  		if (Char.IsDigit (shortArg))// myprog.exe -1  		 {  			// We're parsing a negative number...  			// Nothing to see here.  			positionalArgumentStore.Add (arg);  			continue;  		}  		if (arg.Length > 2) {  			// Pretend the rest of the argument is a new value  			values.Push (arg.Substring (2));  			var stackSize = values.Count;  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  			// No arguments were used... the arg  			// we just pushed must be a group of  			// short args.  			if (values.Count == stackSize) {  				foreach (var shortName in values.Pop ()) {  					// Arguments in a group cannot consume  					// values from the argStack  					ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  				}  			}  		} else// Just a single argument  		 {  			ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  	continue;  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg   {  	var partition = arg.Substring (2).Split (new[] {  		Config.LongOptionSeparator  	}' 2);  	if (partition.Length > 1) {  		values.Push (partition [1]);  	}  	ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  } else// myprog.exe -a   {  	var shortArg = arg [1];  	if (Char.IsDigit (shortArg))// myprog.exe -1  	 {  		// We're parsing a negative number...  		// Nothing to see here.  		positionalArgumentStore.Add (arg);  		continue;  	}  	if (arg.Length > 2) {  		// Pretend the rest of the argument is a new value  		values.Push (arg.Substring (2));  		var stackSize = values.Count;  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		// No arguments were used... the arg  		// we just pushed must be a group of  		// short args.  		if (values.Count == stackSize) {  			foreach (var shortName in values.Pop ()) {  				// Arguments in a group cannot consume  				// values from the argStack  				ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  	} else// Just a single argument  	 {  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	}  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg   {  	var partition = arg.Substring (2).Split (new[] {  		Config.LongOptionSeparator  	}' 2);  	if (partition.Length > 1) {  		values.Push (partition [1]);  	}  	ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  } else// myprog.exe -a   {  	var shortArg = arg [1];  	if (Char.IsDigit (shortArg))// myprog.exe -1  	 {  		// We're parsing a negative number...  		// Nothing to see here.  		positionalArgumentStore.Add (arg);  		continue;  	}  	if (arg.Length > 2) {  		// Pretend the rest of the argument is a new value  		values.Push (arg.Substring (2));  		var stackSize = values.Count;  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		// No arguments were used... the arg  		// we just pushed must be a group of  		// short args.  		if (values.Count == stackSize) {  			foreach (var shortName in values.Pop ()) {  				// Arguments in a group cannot consume  				// values from the argStack  				ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  	} else// Just a single argument  	 {  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	}  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg   {  	var partition = arg.Substring (2).Split (new[] {  		Config.LongOptionSeparator  	}' 2);  	if (partition.Length > 1) {  		values.Push (partition [1]);  	}  	ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  } else// myprog.exe -a   {  	var shortArg = arg [1];  	if (Char.IsDigit (shortArg))// myprog.exe -1  	 {  		// We're parsing a negative number...  		// Nothing to see here.  		positionalArgumentStore.Add (arg);  		continue;  	}  	if (arg.Length > 2) {  		// Pretend the rest of the argument is a new value  		values.Push (arg.Substring (2));  		var stackSize = values.Count;  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		// No arguments were used... the arg  		// we just pushed must be a group of  		// short args.  		if (values.Count == stackSize) {  			foreach (var shortName in values.Pop ()) {  				// Arguments in a group cannot consume  				// values from the argStack  				ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  	} else// Just a single argument  	 {  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	}  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg [1] == Config.ArgumentPrefix)// myprog.exe --arg   {  	var partition = arg.Substring (2).Split (new[] {  		Config.LongOptionSeparator  	}' 2);  	if (partition.Length > 1) {  		values.Push (partition [1]);  	}  	ParseOptionalArgument (partition [0]' Config.LongNameArguments' values' positionalDelimiterFound);  } else// myprog.exe -a   {  	var shortArg = arg [1];  	if (Char.IsDigit (shortArg))// myprog.exe -1  	 {  		// We're parsing a negative number...  		// Nothing to see here.  		positionalArgumentStore.Add (arg);  		continue;  	}  	if (arg.Length > 2) {  		// Pretend the rest of the argument is a new value  		values.Push (arg.Substring (2));  		var stackSize = values.Count;  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  		// No arguments were used... the arg  		// we just pushed must be a group of  		// short args.  		if (values.Count == stackSize) {  			foreach (var shortName in values.Pop ()) {  				// Arguments in a group cannot consume  				// values from the argStack  				ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  			}  		}  	} else// Just a single argument  	 {  		ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	}  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg.Length > 2) {  	// Pretend the rest of the argument is a new value  	values.Push (arg.Substring (2));  	var stackSize = values.Count;  	ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	// No arguments were used... the arg  	// we just pushed must be a group of  	// short args.  	if (values.Count == stackSize) {  		foreach (var shortName in values.Pop ()) {  			// Arguments in a group cannot consume  			// values from the argStack  			ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  } else// Just a single argument   {  	ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: if (arg.Length > 2) {  	// Pretend the rest of the argument is a new value  	values.Push (arg.Substring (2));  	var stackSize = values.Count;  	ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  	// No arguments were used... the arg  	// we just pushed must be a group of  	// short args.  	if (values.Count == stackSize) {  		foreach (var shortName in values.Pop ()) {  			// Arguments in a group cannot consume  			// values from the argStack  			ParseOptionalArgument (shortName' Config.ShortNameArguments' values' positionalDelimiterFound);  		}  	}  } else// Just a single argument   {  	ParseOptionalArgument (shortArg' Config.ShortNameArguments' values' positionalDelimiterFound);  }  
Magic Number,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,Parse,The following statement contains a magic number: values.Push (arg.Substring (2));  
Magic Number,clipr.Usage,AutomaticHelpGenerator,D:\newReposJune17\nemec_clipr\clipr\Usage\AutomaticHelpGenerator.cs,AutomaticHelpGenerator,The following statement contains a magic number: MinDisplayWidth = new DisplayWidth (20);  
Missing Default,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseArgument,The following switch statement is missing a default case: switch (arg.Action) {  case ParseAction.Store: {  	if (!arg.ConsumesMultipleArgs) {  		if (remainingArgs.Count == 0) {  			if (arg.Constraint == NumArgsConstraint.Optional) {  				var defaultValue = arg.Const;  				object converted;  				if (TryConvertFrom (store' defaultValue' out converted)) {  					store.SetValue (Object' converted);  				} else {  					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' defaultValue' store.Type));  				}  				break;  			} else if (!arg.PromptIfValueMissing.Enabled) {  				throw new ParseException (attrName' String.Format (@"Argument ""{0}"" requires a value but " + "none was provided."' attrName));  			} else {  				var value = arg.PromptIfValueMissing.Prompt (attrName);  				try {  					object converted;  					if (TryConvertFrom (store' value' out converted)) {  						store.SetValue (Object' converted);  					} else {  						throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type));  					}  				} catch (Exception e) {  					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)' e);  				}  				break;  			}  		}  		var stringValue = remainingArgs.Pop ();  		if (arg.PromptIfValueMissing.Enabled && stringValue == arg.PromptIfValueMissing.SignalString) {  			var value = arg.PromptIfValueMissing.Prompt (attrName);  			try {  				object converted;  				if (TryConvertFrom (store' value' out converted)) {  					store.SetValue (Object' converted);  				} else {  					throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type));  				}  			} catch (Exception e) {  				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' value' store.Type)' e);  			}  			break;  		}  		try {  			object converted;  			if (TryConvertFrom (store' stringValue' out converted)) {  				store.SetValue (Object' converted);  			} else {  				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type));  			}  		} catch (Exception e) {  			throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type)' e);  		}  	} else {  		var existing = (IEnumerable)store.GetValue (Object);  		var backingList = CreateGenericList (store' existing);  		ParseVarargs (attrName' backingList' arg' remainingArgs' positionalDelimiterFound);  		store.SetValue (Object' backingList);  	}  	break;  }  case ParseAction.StoreConst:  	store.SetValue (Object' arg.Const);  	break;  case ParseAction.StoreTrue:  	store.SetValue (Object' true);  	break;  case ParseAction.StoreFalse:  	store.SetValue (Object' false);  	break;  case ParseAction.Append: {  	var existing = (IEnumerable)store.GetValue (Object);  	var backingList = CreateGenericList (store' existing);  	if (!arg.ConsumesMultipleArgs) {  		if (remainingArgs.Count == 0) {  			throw new ParseException (attrName);  		}  		var stringValue = remainingArgs.Pop ();  		try {  			object converted;  			if (TryConvertFromGeneric (store' stringValue' out converted)) {  				backingList.Add (converted);  			} else {  				throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' arg.Store.Type));  			}  		} catch (Exception e) {  			throw new ParseException (attrName' String.Format (@"Argument {0} value ""{1}"" cannot be converted to the " + "required type {2}."' attrName' stringValue' store.Type)' e);  		}  	} else {  		ParseVarargs (attrName' backingList' arg' remainingArgs' positionalDelimiterFound);  	}  	store.SetValue (Object' backingList);  	break;  }  case ParseAction.AppendConst: {  	var existing = (IEnumerable)store.GetValue (Object);  	var backingList = CreateGenericList (store' existing);  	backingList.Add (arg.Const);  	store.SetValue (Object' backingList);  	break;  }  case ParseAction.Count:  	var cnt = (int)store.GetValue (Object);  	store.SetValue (Object' cnt + 1);  	break;  }  
Missing Default,clipr.Core,ParsingContext,D:\newReposJune17\nemec_clipr\clipr\Core\ParsingContext.cs,ParseVarargs,The following switch statement is missing a default case: switch (arg.Constraint) {  case NumArgsConstraint.Exactly:  	minArgs = arg.NumArgs;  	maxArgs = arg.NumArgs;  	break;  case NumArgsConstraint.AtLeast:  	minArgs = arg.NumArgs;  	maxArgs = uint.MaxValue;  	break;  case NumArgsConstraint.AtMost:  	minArgs = 0;  	maxArgs = arg.NumArgs;  	break;  }  
