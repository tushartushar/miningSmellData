Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.NRefactory.TypeSystem,ReflectionHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ReflectionHelper.cs,ParseReflectionName,The method has 105 lines of code.
Long Method,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The method has 190 lines of code.
Long Method,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The method has 190 lines of code.
Long Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,CreateWriter,The method has 145 lines of code.
Long Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,Deserialize,The method has 126 lines of code.
Long Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,CreateReader,The method has 180 lines of code.
Complex Method,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckTypes,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckNamespace,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,Check,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.Analysis,TypeGraph,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\TypeGraph.cs,TypeGraph,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,GetIdString,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.NRefactory.PatternMatching,Pattern,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\PatternMatching\Pattern.cs,DoMatchCollection,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,GetAttributes,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\InheritanceHelper.cs,GetBaseMembers,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.NRefactory.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\InheritanceHelper.cs,GetDerivedMember,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.NRefactory.TypeSystem,ParameterizedType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterizedType.cs,ParameterizedType,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.TypeSystem,ParameterizedType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterizedType.cs,VisitChildren,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,CecilResolvedAttribute,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\ResolvedAttributeBlob.cs,DecodeBlob,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,CalculateDirectBaseTypes,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetInterfaceImplementation,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedMethod.cs,Resolve,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,SpecializedMethod,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,CreateScanner,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,CreateWriter,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,Deserialize,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,CreateReader,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.NRefactory.Utils,SerializationContext,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,Write,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,Parse,Cyclomatic complexity of the method is 9
Long Parameter List,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ReadTypeName,The method has 5 parameters. Parameters: typeName' pos' allowDottedName' typeParameterCount' typeArguments
Long Parameter List,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConversion,The method has 6 parameters. Parameters: operatorMethod' isImplicit' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConv,The method has 6 parameters. Parameters: isImplicit' method' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous
Long Parameter List,ICSharpCode.NRefactory.Semantics,ForEachResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\ForEachResolveResult.cs,ForEachResolveResult,The method has 8 parameters. Parameters: getEnumeratorCall' collectionType' enumeratorType' elementType' elementVariable' currentProperty' moveNextMethod' voidType
Long Parameter List,ICSharpCode.NRefactory.Semantics,InvocationResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\InvocationResolveResult.cs,InvocationResolveResult,The method has 5 parameters. Parameters: targetResult' member' arguments' initializerStatements' returnTypeOverride
Long Parameter List,ICSharpCode.NRefactory.Semantics,MemberResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 5 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue
Long Parameter List,ICSharpCode.NRefactory.Semantics,MemberResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\MemberResolveResult.cs,MemberResolveResult,The method has 6 parameters. Parameters: targetResult' member' returnType' isConstant' constantValue' isVirtualCall
Long Parameter List,ICSharpCode.NRefactory.Semantics,OperatorResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\OperatorResolveResult.cs,OperatorResolveResult,The method has 5 parameters. Parameters: resultType' operatorType' userDefinedOperatorMethod' isLiftedOperator' operands
Long Parameter List,ICSharpCode.NRefactory.TypeSystem,DomRegion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\DomRegion.cs,DomRegion,The method has 5 parameters. Parameters: fileName' beginLine' beginColumn' endLine' endColumn
Long Parameter List,ICSharpCode.NRefactory.TypeSystem,KnownTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\KnownTypeReference.cs,KnownTypeReference,The method has 5 parameters. Parameters: knownTypeCode' namespaceName' name' typeParameterCount' baseType
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultVariable,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultVariable.cs,DefaultVariable,The method has 5 parameters. Parameters: type' name' region' isConst' constantValue
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,VariableReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultVariable.cs,VariableReference,The method has 5 parameters. Parameters: variableTypeReference' name' region' isConst' constantValue
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractResolvedTypeParameter.cs,AbstractTypeParameter,The method has 6 parameters. Parameters: owner' index' name' variance' attributes' region
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractResolvedTypeParameter.cs,AbstractTypeParameter,The method has 7 parameters. Parameters: compilation' ownerType' index' name' variance' attributes' region
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The method has 6 parameters. Parameters: context' symbolKind' name' explicitInterfaceTypeReference' typeParameterNames' parameterTypeReferences
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultMemberReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultMemberReference.cs,DefaultMemberReference,The method has 5 parameters. Parameters: symbolKind' typeReference' name' typeParameterCount' parameterTypes
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultParameter.cs,DefaultParameter,The method has 10 parameters. Parameters: type' name' owner' region' attributes' isRef' isOut' isParams' isOptional' defaultValue
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,ParameterReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultParameter.cs,ParameterReference,The method has 8 parameters. Parameters: type' name' region' isRef' isOut' isParams' isOptional' defaultValue
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The method has 10 parameters. Parameters: owner' index' name' variance' attributes' region' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints
Long Parameter List,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The method has 11 parameters. Parameters: compilation' ownerType' index' name' variance' attributes' region' hasValueTypeConstraint' hasReferenceTypeConstraint' hasDefaultConstructorConstraint' constraints
Long Parameter List,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,GetAndCheckNumber,The method has 5 parameters. Parameters: format' delimiters' index' numberFieldStart' parsedCharacters
Long Parameter List,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,AddToTable,The method has 6 parameters. Parameters: packageName' assemblyName' table' checkTable' id' ns
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedImplicitConversion,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedImplicitConversion,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedExplicitConversion,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedExplicitConversion,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConversion,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,,The length of the parameter ImplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,,The length of the parameter ExplicitLiftedNumericConversion is 31.
Long Identifier,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,,The length of the parameter ImplicitConstantExpressionConversion is 36.
Long Identifier,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConv,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,,The length of the parameter conversionBeforeUserDefinedOperator is 35.
Long Identifier,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,,The length of the parameter conversionAfterUserDefinedOperator is 34.
Long Identifier,ICSharpCode.NRefactory.TypeSystem,TypeClassificationVisitor,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,,The length of the parameter typeParameterOwnerNestingLevel is 30.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,UnresolvedSecurityDeclarationBlob,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\UnresolvedSecurityDeclarationBlob.cs,,The length of the parameter permissionSetAttributeTypeReference is 35.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedEntity,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedEntity.cs,,The length of the parameter FlagAddDefaultConstructorIfRequired is 35.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedEntity,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedEntity.cs,,The length of the parameter FlagExplicitInterfaceImplementation is 35.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The length of the parameter explicitInterfaceTypeReference is 30.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The length of the parameter addDefaultConstructorIfRequired is 31.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,DefaultTypeParameter,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeParameter.cs,,The length of the parameter hasDefaultConstructorConstraint is 31.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAssembly,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAssembly.cs,,The length of the parameter typeForwardedToAttributeTypeRef is 31.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAssembly,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAssembly.cs,,The length of the parameter unresolvedNamespacesPerNameComparer is 35.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedTypeParameter.cs,,The length of the parameter FlagDefaultConstructorConstraint is 32.
Long Identifier,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,,The length of the parameter substitutionWithoutSpecializedTypeParameters is 44.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckContstraints,The length of the statement  "				OnIncompatibilityFound (new AbiEventArgs (string.Format (TranslateString ("Type parameter constraints of type {0} have changed.")' otype.FullName))); " is 149.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckContstraints,The length of the statement  "				OnIncompatibilityFound (new AbiEventArgs (string.Format (TranslateString ("Type parameter constraints of method {0} have changed.")' omethod.FullName))); " is 153.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckTypes,The length of the statement  "				var newMember = nType.GetMembers (m => member.UnresolvedMember.Name == m.Name && m.IsPublic == member.IsPublic && m.IsProtected == member.IsProtected); " is 151.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckTypes,The length of the statement  "					OnIncompatibilityFound (new AbiEventArgs (string.Format (TranslateString ("Interafce {0} has changed.")' oType.FullName))); " is 123.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckNamespace,The length of the statement  "					OnIncompatibilityFound (new AbiEventArgs (string.Format (TranslateString ("Type definition {0} is missing.")' type.FullName))); " is 127.
Long Statement,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,Check,The length of the statement  "						OnIncompatibilityFound (new AbiEventArgs (string.Format (TranslateString ("Namespace {0} is missing.")' child.FullName))); " is 122.
Long Statement,ICSharpCode.NRefactory.Analysis,SymbolCollector,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\SymbolCollector.cs,CollectTypeRelatedMembers,The length of the statement  "			foreach (var c in type.GetDefinition ().GetMembers (m => !m.IsSynthetic && (m.SymbolKind == SymbolKind.Constructor || m.SymbolKind == SymbolKind.Destructor)' GetMemberOptions.IgnoreInheritedMembers)) { " is 201.
Long Statement,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,GetIdString,The length of the statement  "			if (member.IsExplicitInterfaceImplementation && member.Name.IndexOf('.') < 0 && member.ImplementedInterfaceMembers.Count == 1) { " is 128.
Long Statement,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ReadTypeName,The length of the statement  "			while (pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')) " is 120.
Long Statement,ICSharpCode.NRefactory.PatternMatching,Repeat,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\PatternMatching\Repeat.cs,DoMatchCollection,The length of the statement  "			return false; // never do a normal (single-element) match; always make the caller look at the results on the back-tracking stack. " is 129.
Long Statement,ICSharpCode.NRefactory.Semantics,ByReferenceResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\ByReferenceResolveResult.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} {1} {2}]"' GetType().Name' IsOut ? "out" : "ref"' ElementType); " is 120.
Long Statement,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedImplicitConversion,The length of the statement  "			return new UserDefinedConv(true' operatorMethod' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' false); " is 139.
Long Statement,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedExplicitConversion,The length of the statement  "			return new UserDefinedConv(false' operatorMethod' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' false); " is 140.
Long Statement,ICSharpCode.NRefactory.Semantics,Conversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,UserDefinedConversion,The length of the statement  "			return new UserDefinedConv(isImplicit' operatorMethod' conversionBeforeUserDefinedOperator' conversionAfterUserDefinedOperator' isLifted' isAmbiguous); " is 151.
Long Statement,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,Equals,The length of the statement  "				return o != null && isLifted == o.isLifted && isImplicit == o.isImplicit && isValid == o.isValid && method.Equals(o.method); " is 124.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var classTypeArguments = f.classTypeArguments != null ? GetComposedTypeArguments(f.classTypeArguments' g) : g.classTypeArguments; " is 129.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeParameterSubstitution.cs,Compose,The length of the statement  "			var methodTypeArguments = f.methodTypeArguments != null ? GetComposedTypeArguments(f.methodTypeArguments' g) : g.methodTypeArguments; " is 133.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,CreateResolvedAttributes,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedAttribute' IAttribute>(context' attributes' (c' a) => a.CreateResolvedAttribute(c)); " is 141.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,CreateResolvedTypeParameters,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedTypeParameter' ITypeParameter>(context' typeParameters' (c' a) => a.CreateResolvedTypeParameter(c)); " is 157.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,CreateResolvedParameters,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IUnresolvedParameter' IParameter>(context' parameters' (c' a) => a.CreateResolvedParameter(c)); " is 141.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TypeSystemExtensions,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeSystemExtensions.cs,Resolve,The length of the statement  "				return new ProjectedList<ITypeResolveContext' IConstantValue' ResolveResult>(context' constantValues' (c' t) => t.Resolve(c)); " is 126.
Long Statement,ICSharpCode.NRefactory.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetAccessors(m => m.Name == member.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 145.
Long Statement,ICSharpCode.NRefactory.TypeSystem,InheritanceHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\InheritanceHelper.cs,GetBaseMembers,The length of the statement  "					baseMembers = baseType.GetMembers(m => m.Name == member.Name && !m.IsExplicitInterfaceImplementation' GetMemberOptions.IgnoreInheritedMembers); " is 143.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TopLevelTypeName,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TopLevelTypeName.cs,Equals,The length of the statement  "			return this.namespaceName == other.namespaceName && this.name == other.name && this.typeParameterCount == other.typeParameterCount; " is 131.
Long Statement,ICSharpCode.NRefactory.TypeSystem,TopLevelTypeName,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TopLevelTypeName.cs,GetHashCode,The length of the statement  "			return (name != null ? name.GetHashCode() : 0) ^ (namespaceName != null ? namespaceName.GetHashCode() : 0) ^ typeParameterCount; " is 128.
Long Statement,ICSharpCode.NRefactory.TypeSystem,SpecialType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\SpecialType.cs,Equals,The length of the statement  "			// However' an unknown type with additional information is not considered to be equal to the SpecialType with TypeKind.Unknown. " is 127.
Long Statement,ICSharpCode.NRefactory.TypeSystem,AssemblyLoader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AssemblyLoader.cs,Create,The length of the statement  "					return (AssemblyLoader)Assembly.Load ("ICSharpCode.NRefactory.Cecil").CreateInstance ("ICSharpCode.NRefactory.TypeSystem.CecilLoader"); " is 135.
Long Statement,ICSharpCode.NRefactory.TypeSystem,AssemblyLoader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AssemblyLoader.cs,Create,The length of the statement  "					return (AssemblyLoader)Assembly.Load ("ICSharpCode.NRefactory.IKVM").CreateInstance ("ICSharpCode.NRefactory.TypeSystem.IkvmLoader"); " is 133.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The length of the statement  "			} else if (unresolved.IsStatic || !unresolved.IsPublic || DeclaringTypeDefinition == null || DeclaringTypeDefinition.Kind == TypeKind.Interface) { " is 146.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The length of the statement  "				result = result.Where(item => !otherMembers.Any(m => m.IsExplicitInterfaceImplementation && m.ImplementedInterfaceMembers.Contains(item))).ToArray(); " is 149.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractUnresolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractUnresolvedMember.cs,Resolve,The length of the statement  "			return Resolve(ExtendContextForType(context' this.DeclaringTypeDefinition)' this.SymbolKind' this.Name' interfaceTypeReference); " is 128.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,CurrentAssemblyReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultAssemblyReference.cs,Resolve,The length of the statement  "					throw new ArgumentException("A reference to the current assembly cannot be resolved in the compilation's global type resolve context."); " is 136.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultMemberReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultMemberReference.cs,EqualsForInterning,The length of the statement  "			return o != null && symbolKind == o.symbolKind && typeReference == o.typeReference && name == o.name && parameterTypes == o.parameterTypes; " is 139.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,ParameterReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultParameter.cs,Resolve,The length of the statement  "			return new DefaultParameter(type.Resolve(context)' name' region: region' isRef: isRef' isOut: isOut' isParams: isParams' isOptional: isOptional' defaultValue: defaultValue); " is 173.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The length of the statement  "				if (kind == TypeKind.Class && !this.IsStatic && !unresolvedMembers.Any(m => m.SymbolKind == SymbolKind.Constructor && !m.IsStatic) " is 130.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,ToTypeReference,The length of the statement  "				return new NestedTypeReference(declTypeDef.ToTypeReference()' this.Name' this.TypeParameterCount - declTypeDef.TypeParameterCount); " is 131.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,EqualsForInterning,The length of the statement  "				defaultValue == p.defaultValue && region == p.region && (flags & ~1) == (p.flags & ~1) && ListEquals(attributes' p.attributes); " is 127.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,ListEquals,The length of the statement  "			return (list1 ?? EmptyList<IUnresolvedAttribute>.Instance).SequenceEqual(list2 ?? EmptyList<IUnresolvedAttribute>.Instance); " is 124.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedTypeParameter.cs,CreateResolvedTypeParameter,The length of the statement  "				this.HasValueTypeConstraint' this.HasReferenceTypeConstraint' this.HasDefaultConstructorConstraint' this.Constraints.Resolve(context) " is 133.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,ExplicitInterfaceImplementationMemberReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\ExplicitInterfaceImplementationMemberReference.cs,Resolve,The length of the statement  "			IMember interfaceMember = interfaceMemberReference.Resolve(context.WithCurrentTypeDefinition(declaringType.GetDefinition())); " is 125.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,ExplicitInterfaceImplementationMemberReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\ExplicitInterfaceImplementationMemberReference.cs,Resolve,The length of the statement  "			return members.FirstOrDefault(m => m.ImplementedInterfaceMembers.Count == 1 && interfaceMember.Equals(m.ImplementedInterfaceMembers[0])); " is 137.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\GetMembersHelper.cs,GetNestedTypesImpl,The length of the statement  "				if (totalTypeParameterCount == 0 || (options & GetMemberOptions.ReturnMemberDefinitions) == GetMemberOptions.ReturnMemberDefinitions) { " is 135.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\GetMembersHelper.cs,GetAccessorsImpl,The length of the statement  "			return GetConstructorsOrAccessorsImpl(baseType' baseType.GetAccessors(filter' options | declaredMembers)' filter' options); " is 123.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\GetMembersHelper.cs,GetConstructorsImpl,The length of the statement  "			return GetConstructorsOrAccessorsImpl(baseType' baseType.GetConstructors(filter' options | declaredMembers)' filter' options); " is 126.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,NestedTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\NestedTypeReference.cs,EqualsForInterning,The length of the statement  "			return o != null && declaringTypeRef == o.declaringTypeRef && name == o.name && additionalTypeParameterCount == o.additionalTypeParameterCount; " is 143.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,ToReference,The length of the statement  "			//   If this member is specialized using open generic types' the resulting member reference will need to be looked up in an appropriate generic context. " is 152.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "			return this.baseMember.Equals(other.baseMember) && this.substitutionWithoutSpecializedTypeParameters.Equals(other.substitutionWithoutSpecializedTypeParameters); " is 160.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,Specialize,The length of the statement  "			return methodDefinition.Specialize(TypeParameterSubstitution.Compose(newSubstitution' substitutionWithoutSpecializedTypeParameters)); " is 133.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedTypeParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,Equals,The length of the statement  "				// Compare the owner' not the substitution' because the substitution may contain this specialized type parameter recursively " is 124.
Long Statement,ICSharpCode.NRefactory.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\TypeParameterReference.cs,Create,The length of the statement  "				TypeParameterReference[] arr = (ownerType == SymbolKind.TypeDefinition) ? classTypeParameterReferences : methodTypeParameterReferences; " is 135.
Long Statement,ICSharpCode.NRefactory.Utils,FastSerializer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,GetSerializableFields,The length of the statement  "				FieldInfo[] declFields = baseType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly); " is 142.
Long Statement,ICSharpCode.NRefactory.Utils,DeserializationContext,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,DeserializeTypeDescriptions,The length of the statement  "						throw new SerializationException("Type '" + type.FullName + "' was serialized with version " + versionNumber + "' but is version " + FastSerializerVersionAttribute.GetVersionNumber(type)); " is 188.
Long Statement,ICSharpCode.NRefactory.Utils,DeserializationContext,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,DeserializeTypeDescriptions,The length of the statement  "							throw new SerializationException("Type '" + type.FullName + "' was serialized as special type' but isn't special now."); " is 120.
Long Statement,ICSharpCode.NRefactory.Utils,DeserializationContext,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,DeserializeTypeDescriptions,The length of the statement  "							throw new SerializationException("Type '" + type.FullName + "' wasn't serialized as special type' but is special now."); " is 120.
Long Statement,ICSharpCode.NRefactory.Utils,DeserializationContext,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\FastSerializer.cs,DeserializeTypeDescriptions,The length of the statement  "								throw new SerializationException(type.FullName + "." + fieldName + " was serialized as " + this.Types[fieldTypeID] + "' but now is " + fieldInfo.FieldType); " is 156.
Long Statement,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,GetAndCheckNumber,The length of the statement  "				AddInvalidNumberFormatError (numberFieldStart' format.Substring (numberFieldStart' index - numberFieldStart)' suggestedNumber); " is 127.
Long Statement,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,ToString,The length of the statement  "			return string.Format ("[FormatItem: Index={0}' Alignment={1}' FormatString={2}' StartLocation={3}' EndLocation={4}]"' Index' Alignment' FormatString' StartLocation' EndLocation); " is 178.
Long Statement,ICSharpCode.NRefactory.Utils,DefaultFormatStringError,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\IFormatStringError.cs,ToString,The length of the statement  "			return string.Format ("[DefaultFormatStringError: StartLocation={0}' EndLocation={1}' Message={2}' OriginalText={3}' SuggestedReplacementText={4}]"' StartLocation' EndLocation' Message' OriginalText' SuggestedReplacementText); " is 226.
Long Statement,ICSharpCode.NRefactory.Completion,CompletionExtensionMethods,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\CompletionExtensionMethods.cs,GetEditorBrowsableState,The length of the statement  "			var browsableState = entity.Attributes.FirstOrDefault(attr => attr.AttributeType.Name == "EditorBrowsableAttribute" && attr.AttributeType.Namespace == "System.ComponentModel"); " is 176.
Long Statement,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetExtensionMethodLookups,The length of the statement  "			return GetLookup (resolveResult.MemberName' extLookupTable' headerSize + assemblyListTable.Length * 4 + typeLookupTable.Length * 8); " is 132.
Long Statement,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookup,The length of the statement  "			using (var reader = new BinaryReader (File.Open (fileName' FileMode.Open' FileAccess.Read' FileShare.Read)' Encoding.UTF8)) { " is 125.
Long Statement,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookup,The length of the statement  "						throw new InvalidDataException ("Assembly lookup was " + assembly + " but only " + assemblyListTable.Length + " are known."); " is 125.
Long Statement,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,AddLookup,The length of the statement  "							AddToTable (packageName' fullAssemblyName' extensionMethodLookup' methodCheck' method.Name' method.DeclaringTypeDefinition.Namespace); " is 134.
Complex Conditional,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckContstraints,The conditional expression  "p1.DirectBaseTypes.Count () != p2.DirectBaseTypes.Count () ||  			    p1.HasReferenceTypeConstraint != p2.HasReferenceTypeConstraint ||  			    p1.HasValueTypeConstraint != p2.HasValueTypeConstraint ||  			    p1.HasDefaultConstructorConstraint != p2.HasDefaultConstructorConstraint"  is complex.
Complex Conditional,ICSharpCode.NRefactory.Analysis,AbiComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Analysis\AbiComparer.cs,CheckContstraints,The conditional expression  "p1.DirectBaseTypes.Count () != p2.DirectBaseTypes.Count () ||  			    p1.HasReferenceTypeConstraint != p2.HasReferenceTypeConstraint ||  			    p1.HasValueTypeConstraint != p2.HasValueTypeConstraint ||  			    p1.HasDefaultConstructorConstraint != p2.HasDefaultConstructorConstraint"  is complex.
Complex Conditional,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ReadTypeName,The conditional expression  "pos < typeName.Length && !IsIDStringSpecialCharacter(typeName[pos]) && (allowDottedName || typeName[pos] != '.')"  is complex.
Complex Conditional,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterLength,The conditional expression  "curChar == LF || curChar == NEL || curChar == VT || curChar == FF || curChar == LS || curChar == PS"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem,SignatureComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterListComparer.cs,Equals,The conditional expression  "x == null || y == null || x.SymbolKind != y.SymbolKind || !nameComparer.Equals(x.Name' y.Name)"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,AbstractResolvedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\AbstractResolvedMember.cs,FindImplementedInterfaceMembers,The conditional expression  "unresolved.IsStatic || !unresolved.IsPublic || DeclaringTypeDefinition == null || DeclaringTypeDefinition.Kind == TypeKind.Interface"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,BaseTypeCollector,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BaseTypeCollector.cs,CollectBaseTypes,The conditional expression  "SkipImplementedInterfaces && def != null && def.Kind != TypeKind.Interface && def.Kind != TypeKind.TypeParameter"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,GetMemberList,The conditional expression  "kind == TypeKind.Class && !this.IsStatic && !unresolvedMembers.Any(m => m.SymbolKind == SymbolKind.Constructor && !m.IsStatic)  				    || kind == TypeKind.Enum || kind == TypeKind.Struct"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultResolvedTypeDefinition,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultResolvedTypeDefinition.cs,CalculateDirectBaseTypes,The conditional expression  "!hasNonInterface && !(this.Name == "Object" && this.Namespace == "System" && this.TypeParameterCount == 0)"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,GetMembersHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\GetMembersHelper.cs,GetMethodsImpl,The conditional expression  "(options & GetMemberOptions.ReturnMemberDefinitions) == 0  			    && (pt != null || (methodTypeArguments != null && methodTypeArguments.Count > 0))"  is complex.
Complex Conditional,ICSharpCode.NRefactory.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\TypeParameterReference.cs,Create,The conditional expression  "index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)"  is complex.
Complex Conditional,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,Parse,The conditional expression  "i == formatItemStart + 1 && (i == length || (i < length && format[i] != '}'))"  is complex.
Magic Number,ICSharpCode.NRefactory.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following statement contains a magic number: while (reader.Read()) {  				switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}  			}
Magic Number,ICSharpCode.NRefactory.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\XmlDocumentationProvider.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int h = 0;  				foreach (char c in key) {  					h = (h << 5) - h + c;  				}  				return h;  			}
Magic Number,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: if (memberIdString.Length < 2 || memberIdString[1] != ':')  				throw new ReflectionNameParseException(0' "Missing type tag");
Magic Number,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ParseMemberIdString,The following statement contains a magic number: int pos = 2;
Magic Number,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,ParseTypeName,The following statement contains a magic number: if (typeName.StartsWith("T:"' StringComparison.Ordinal))  				pos = 2;
Magic Number,ICSharpCode.NRefactory.Documentation,IdStringProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\IdStringProvider.cs,FindEntity,The following statement contains a magic number: if (idString.StartsWith("T:"' StringComparison.Ordinal)) {  				return ParseTypeName(idString.Substring(2)).Resolve(context).GetDefinition();  			} else {  				return ParseMemberIdString(idString).Resolve(context);  			}
Magic Number,ICSharpCode.NRefactory,AbstractAnnotatable,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\IAnnotatable.cs,AddAnnotation,The following statement contains a magic number: if (list == null) {  				// we need to transform the old annotation into a list  				list = new AnnotationList (4);  				list.Add (oldAnnotation);  				list.Add (annotation);  				if (Interlocked.CompareExchange (ref this.annotations' list' oldAnnotation) != oldAnnotation) {  					// the transformation failed (some other thread wrote to this.annotations first)  					goto retry;  				}  			} else {  				// once there's a list' use simple locking  				lock (list) {  					list.Add (annotation);  				}  			}
Magic Number,ICSharpCode.NRefactory,TextLocation,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (191 * column.GetHashCode() ^ line.GetHashCode());
Magic Number,ICSharpCode.NRefactory,TextLocationConverter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TextLocation.cs,ConvertFrom,The following statement contains a magic number: if (value is string) {  				string[] parts = ((string)value).Split(';'' ''');  				if (parts.Length == 2) {  					return new TextLocation(int.Parse(parts[0])' int.Parse(parts[1]));  				}  			}
Magic Number,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar != null && nextChar () == LF)  					return 2;  				return 1;  			}
Magic Number,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterLength,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar == LF)  					return 2;  				return 1;  			}
Magic Number,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar != null && nextChar () == LF) {  					length = 2;  					type = UnicodeNewline.CRLF;  				} else {  					length = 1;  					type = UnicodeNewline.CR;    				}  				return true;  			}
Magic Number,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following statement contains a magic number: if (curChar == CR) {  				if (nextChar == LF) {  					length = 2;  					type = UnicodeNewline.CRLF;  				} else {  					length = 1;  					type = UnicodeNewline.CR;    				}  				return true;  			}
Magic Number,ICSharpCode.NRefactory.Semantics,NumericOrEnumerationConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.NRefactory.Semantics,NumericOrEnumerationConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return (isImplicit ? 1 : 0) + (isLifted ? 2 : 0) + (isEnumeration ? 4 : 0);
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following statement contains a magic number: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.Semantics,UserDefinedConv,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,GetHashCode,The following statement contains a magic number: return unchecked(method.GetHashCode() + (isLifted ? 31 : 27) + (isImplicit ? 71 : 61) + (isValid ? 107 : 109));
Magic Number,ICSharpCode.NRefactory.TypeSystem,AnonymousType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = resolvedProperties.Count;  				foreach (var p in resolvedProperties) {  					hashCode *= 31;  					hashCode += p.Name.GetHashCode() ^ p.ReturnType.GetHashCode();  				}  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,AnonymousTypeProperty,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: return declaringType.GetHashCode() ^ unchecked(27 * this.Name.GetHashCode());
Magic Number,ICSharpCode.NRefactory.TypeSystem,AnonymousTypeAccessor,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AnonymousType.cs,GetHashCode,The following statement contains a magic number: return owner.DeclaringType.GetHashCode() ^ unchecked(27 * this.Name.GetHashCode());
Magic Number,ICSharpCode.NRefactory.TypeSystem,ArrayType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ArrayType.cs,GetHashCode,The following statement contains a magic number: return unchecked(elementType.GetHashCode() * 71681 + dimensions);
Magic Number,ICSharpCode.NRefactory.TypeSystem,AssemblyQualifiedTypeName,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\AssemblyQualifiedTypeName.cs,GetHashCode,The following statement contains a magic number: unchecked {  				if (AssemblyName != null)  					hashCode += 1000000007 * AssemblyName.GetHashCode();  				hashCode += TypeName.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,ByReferenceType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ByReferenceType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725813;
Magic Number,ICSharpCode.NRefactory.TypeSystem,ByReferenceTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ByReferenceType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725814;
Magic Number,ICSharpCode.NRefactory.TypeSystem,DomRegion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,DomRegion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,DomRegion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\DomRegion.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hashCode = fileName != null ? fileName.GetHashCode() : 0;  				hashCode ^= beginColumn + 1100009 * beginLine + 1200007 * endLine + 1300021 * endColumn;  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeParameterSubstitution.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1124131 * TypeListHashCode(classTypeArguments) + 1821779 * TypeListHashCode(methodTypeArguments);  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,TypeParameterSubstitution,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\TypeParameterSubstitution.cs,TypeListHashCode,The following statement contains a magic number: unchecked {  				int hashCode = 1;  				foreach (var element in obj) {  					hashCode *= 27;  					hashCode += element.GetHashCode();  				}  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,FullTypeNameComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\FullTypeName.cs,GetHashCode,The following statement contains a magic number: unchecked {  				for (int i = 0; i < obj.NestingLevel; i++) {  					hash *= 31;  					hash += NameComparer.GetHashCode(obj.Name) ^ obj.TypeParameterCount;  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,IntersectionType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\IntersectionType.cs,IntersectionType,The following statement contains a magic number: Debug.Assert(types.Length >= 2);
Magic Number,ICSharpCode.NRefactory.TypeSystem,IntersectionType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\IntersectionType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var t in types) {  					hashCode *= 7137517;  					hashCode += t.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,ParameterizedType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var ta in typeArguments) {  					hashCode *= 1000000007;  					hashCode += 1000000009 * ta.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,ParameterizedType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterizedType.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (var ta in typeArguments) {  					hashCode *= 1000000007;  					hashCode += 1000000009 * ta.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,ParameterizedTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterizedType.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				foreach (ITypeReference t in typeArguments) {  					hashCode *= 27;  					hashCode += t.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,ParameterListComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				foreach (IParameter p in obj) {  					hashCode *= 27;  					IType type = p.Type.AcceptVisitor(normalizationVisitor);  					hashCode += type.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,SignatureComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);  				IParameterizedMember pm = obj as IParameterizedMember;  				if (pm != null) {  					hash *= 27;  					hash += ParameterListComparer.Instance.GetHashCode(pm.Parameters);  					IMethod m = pm as IMethod;  					if (m != null)  						hash += m.TypeParameters.Count;  				}  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,SignatureComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ParameterListComparer.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = (int)obj.SymbolKind * 33 + nameComparer.GetHashCode(obj.Name);  				IParameterizedMember pm = obj as IParameterizedMember;  				if (pm != null) {  					hash *= 27;  					hash += ParameterListComparer.Instance.GetHashCode(pm.Parameters);  					IMethod m = pm as IMethod;  					if (m != null)  						hash += m.TypeParameters.Count;  				}  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem,PointerType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\PointerType.cs,GetHashCode,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725811;
Magic Number,ICSharpCode.NRefactory.TypeSystem,PointerTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\PointerType.cs,GetHashCodeForInterning,The following statement contains a magic number: return elementType.GetHashCode() ^ 91725812;
Magic Number,ICSharpCode.NRefactory.TypeSystem,SpecialType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\SpecialType.cs,GetHashCode,The following statement contains a magic number: return 81625621 ^ (int)kind;
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,GetBlobHashCode,The following statement contains a magic number: unchecked {  				int hash = 0;  				foreach (byte b in blob) {  					hash *= 257;  					hash += b;  				}  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt16,The following statement contains a magic number: unchecked {  				ushort value =(ushort)(buffer[position]  				                       |(buffer[position + 1] << 8));  				position += 2;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt16,The following statement contains a magic number: unchecked {  				ushort value =(ushort)(buffer[position]  				                       |(buffer[position + 1] << 8));  				position += 2;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt32,The following statement contains a magic number: unchecked {  				uint value =(uint)(buffer[position]  				                   |(buffer[position + 1] << 8)  				                   |(buffer[position + 2] << 16)  				                   |(buffer[position + 3] << 24));  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadUInt64,The following statement contains a magic number: unchecked {  				uint low = ReadUInt32();  				uint high = ReadUInt32();    				return(((ulong) high) << 32) | low;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadCompressedUInt32,The following statement contains a magic number: unchecked {  				byte first = ReadByte();  				if((first & 0x80) == 0)  					return first;    				if((first & 0x40) == 0)  					return((uint)(first & ~0x80) << 8)  						| ReadByte();    				return((uint)(first & ~0xc0) << 24)  					|(uint) ReadByte() << 16  					|(uint) ReadByte() << 8  					| ReadByte();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadSingle,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(4);  					Array.Reverse(bytes);  					return BitConverter.ToSingle(bytes' 0);  				}    				float value = BitConverter.ToSingle(buffer' position);  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadSingle,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(4);  					Array.Reverse(bytes);  					return BitConverter.ToSingle(bytes' 0);  				}    				float value = BitConverter.ToSingle(buffer' position);  				position += 4;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadDouble,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(8);  					Array.Reverse(bytes);  					return BitConverter.ToDouble(bytes' 0);  				}    				double value = BitConverter.ToDouble(buffer' position);  				position += 8;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,BlobReader,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\BlobReader.cs,ReadDouble,The following statement contains a magic number: unchecked {  				if(!BitConverter.IsLittleEndian) {  					var bytes = ReadBytes(8);  					Array.Reverse(bytes);  					return BitConverter.ToDouble(bytes' 0);  				}    				double value = BitConverter.ToDouble(buffer' position);  				position += 8;  				return value;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedAttribute,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedAttribute.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				if (constructorParameterTypes != null) {  					foreach (var type in constructorParameterTypes) {  						hash *= 27;  						hash += type.GetHashCode();  					}  				}  				if (positionalArguments != null) {  					foreach (var arg in positionalArguments) {  						hash *= 31;  						hash += arg.GetHashCode();  					}  				}  				if (namedArguments != null) {  					foreach (var pair in namedArguments) {  						hash *= 71;  						hash += pair.Key.GetHashCode() + pair.Value.GetHashCode() * 73;  					}  				}  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,DefaultUnresolvedParameter,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\DefaultUnresolvedParameter.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				int hashCode = 1919191 ^ (flags & ~1);  				hashCode *= 31;  				hashCode += type.GetHashCode();  				hashCode *= 31;  				hashCode += name.GetHashCode();  				if (attributes != null) {  					foreach (var attr in attributes)  						hashCode ^= attr.GetHashCode ();  				}  				if (defaultValue != null)  					hashCode ^= defaultValue.GetHashCode ();  				return hashCode;  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,GetClassTypeReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\GetClassTypeReference.cs,GetHashCodeForInterning,The following statement contains a magic number: unchecked {  				return 33 * assembly.GetHashCode() + fullTypeName.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,ListComparer,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SimpleInterningProvider.cs,GetHashCode,The following statement contains a magic number: unchecked {  					foreach (object o in obj) {  						hashCode *= 27;  						hashCode += RuntimeHelpers.GetHashCode(o);  					}  				}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMember,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMember.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000007 * baseMember.GetHashCode() + 1000000009 * substitution.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,SpecializedMethod,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\SpecializedMethod.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return 1000000013 * baseMember.GetHashCode() + 1000000009 * substitutionWithoutSpecializedTypeParameters.GetHashCode();  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,TypeParameterReference,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\TypeParameterReference.cs,Create,The following statement contains a magic number: if (index >= 0 && index < 8 && (ownerType == SymbolKind.TypeDefinition || ownerType == SymbolKind.Method)) {  				TypeParameterReference[] arr = (ownerType == SymbolKind.TypeDefinition) ? classTypeParameterReferences : methodTypeParameterReferences;  				TypeParameterReference result = LazyInit.VolatileRead(ref arr[index]);  				if (result == null) {  					result = LazyInit.GetOrSet(ref arr[index]' new TypeParameterReference(ownerType' index));  				}  				return result;  			} else {  				return new TypeParameterReference(ownerType' index);  			}
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,UnknownType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Magic Number,ICSharpCode.NRefactory.TypeSystem.Implementation,UnknownType,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\Implementation\UnknownType.cs,GetHashCode,The following statement contains a magic number: return (namespaceKnown ? 812571 : 12651) ^ fullTypeName.GetHashCode();
Magic Number,ICSharpCode.NRefactory.Utils,BinaryReaderWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,ReadUInt64,The following statement contains a magic number: while (shift < 64) {  				byte b = this.ReadByte();  				num |= (ulong)(b & 127) << shift;  				shift += 7;  				if ((b & 128) == 0) {  					return num;  				}  			}
Magic Number,ICSharpCode.NRefactory.Utils,BinaryReaderWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,ReadUInt64,The following statement contains a magic number: while (shift < 64) {  				byte b = this.ReadByte();  				num |= (ulong)(b & 127) << shift;  				shift += 7;  				if ((b & 128) == 0) {  					return num;  				}  			}
Magic Number,ICSharpCode.NRefactory.Utils,BinaryReaderWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,ReadUInt64,The following statement contains a magic number: while (shift < 64) {  				byte b = this.ReadByte();  				num |= (ulong)(b & 127) << shift;  				shift += 7;  				if ((b & 128) == 0) {  					return num;  				}  			}
Magic Number,ICSharpCode.NRefactory.Utils,BinaryReaderWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,ReadUInt64,The following statement contains a magic number: while (shift < 64) {  				byte b = this.ReadByte();  				num |= (ulong)(b & 127) << shift;  				shift += 7;  				if ((b & 128) == 0) {  					return num;  				}  			}
Magic Number,ICSharpCode.NRefactory.Utils,BinaryWriterWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,Write,The following statement contains a magic number: while (value >= 128) {  				this.Write(unchecked((byte)(value | 128u)));  				value >>= 7;  			}
Magic Number,ICSharpCode.NRefactory.Utils,BinaryWriterWith7BitEncodedInts,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\7BitEncodedInts.cs,Write,The following statement contains a magic number: while (value >= 128) {  				this.Write(unchecked((byte)(value | 128u)));  				value >>= 7;  			}
Magic Number,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,CheckForMissingEndBrace,The following statement contains a magic number: if (i == length) {  				int j;  				for (j = i - 1; format[j] == '}'; j--);  				var oddEndBraceCount = (i - j) % 2 == 1;  				if (oddEndBraceCount) {  					AddMissingEndBraceError(i' i' "Missing '}'"' "");  				}  				return;  			}
Magic Number,ICSharpCode.NRefactory.Utils,CompositeFormatStringParser,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\CompositeFormatStringParser.cs,GetNumber,The following statement contains a magic number: while (i < format.Length && format[i] >= '0' && format[i] <= '9') {  				sum = 10 * sum + format [i] - '0';  				++i;  			}
Magic Number,ICSharpCode.NRefactory.Utils,TextSegment,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\TextSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Text.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,TextSegment,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\TextSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Text.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,TextSegment,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\TextSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Text.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,TextSegment,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\TextSegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Text.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,FormatItem,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CompositeFormatStringParser\FormatItem.cs,GetHashCode,The following statement contains a magic number: unchecked {  				int hash = 23;  				hash = hash * 37 + Index.GetHashCode ();  				hash = hash * 37 + Alignment.GetHashCode ();  				hash = hash * 37 + FormatString.GetHashCode ();  				hash = hash * 37 + StartLocation.GetHashCode ();  				hash = hash * 37 + EndLocation.GetHashCode ();  				return hash;  			}
Magic Number,ICSharpCode.NRefactory.Utils,ComparableList<T>,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\ComparableList.cs,GetHashCode,The following statement contains a magic number: int hash = 19;
Magic Number,ICSharpCode.NRefactory.Utils,ComparableList<T>,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\ComparableList.cs,GetHashCode,The following statement contains a magic number: foreach (var item in this) {  				unchecked {  					hash *= 31;  					hash += item.GetHashCode();  				}  			}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetExtensionMethodLookups,The following statement contains a magic number: return GetLookup (resolveResult.MemberName' extLookupTable' headerSize + assemblyListTable.Length * 4 + typeLookupTable.Length * 8);
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetExtensionMethodLookups,The following statement contains a magic number: return GetLookup (resolveResult.MemberName' extLookupTable' headerSize + assemblyListTable.Length * 4 + typeLookupTable.Length * 8);
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookups,The following statement contains a magic number: return GetLookup (identifier' typeLookupTable' headerSize + assemblyListTable.Length * 4);
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookups,The following statement contains a magic number: foreach (var lookup in GetLookup (identifier' typeLookupTable' headerSize + assemblyListTable.Length * 4)) {  				if (fullMemberName.StartsWith (lookup.Namespace' StringComparison.Ordinal))  					yield return lookup;  			}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookup,The following statement contains a magic number: using (var reader = new BinaryReader (File.Open (fileName' FileMode.Open' FileAccess.Read' FileShare.Read)' Encoding.UTF8)) {  				reader.BaseStream.Seek (tableOffset + index * 8 + 4' SeekOrigin.Begin);  				int listPtr = reader.ReadInt32 ();    				reader.BaseStream.Seek (listPtr' SeekOrigin.Begin);  				var b = reader.ReadInt32 ();  				var assemblies = new List<ushort> ();  				while (b-- > 0) {  					var assembly = reader.ReadUInt16 ();  					if (assembly < 0 || assembly >= assemblyListTable.Length)  						throw new InvalidDataException ("Assembly lookup was " + assembly + " but only " + assemblyListTable.Length + " are known.");  					assemblies.Add (assembly);  				}  				foreach (var assembly in assemblies) {  					reader.BaseStream.Seek (assemblyListTable [assembly]' SeekOrigin.Begin);    					var package = reader.ReadString ();  					var fullName = reader.ReadString ();  					var ns = reader.ReadString ();  					yield return new AssemblyLookup (package' fullName' ns);  				}  			}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetLookup,The following statement contains a magic number: using (var reader = new BinaryReader (File.Open (fileName' FileMode.Open' FileAccess.Read' FileShare.Read)' Encoding.UTF8)) {  				reader.BaseStream.Seek (tableOffset + index * 8 + 4' SeekOrigin.Begin);  				int listPtr = reader.ReadInt32 ();    				reader.BaseStream.Seek (listPtr' SeekOrigin.Begin);  				var b = reader.ReadInt32 ();  				var assemblies = new List<ushort> ();  				while (b-- > 0) {  					var assembly = reader.ReadUInt16 ();  					if (assembly < 0 || assembly >= assemblyListTable.Length)  						throw new InvalidDataException ("Assembly lookup was " + assembly + " but only " + assemblyListTable.Length + " are known.");  					assemblies.Add (assembly);  				}  				foreach (var assembly in assemblies) {  					reader.BaseStream.Seek (assemblyListTable [assembly]' SeekOrigin.Begin);    					var package = reader.ReadString ();  					var fullName = reader.ReadString ();  					var ns = reader.ReadString ();  					yield return new AssemblyLookup (package' fullName' ns);  				}  			}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkLookup,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,GetStableHashCode,The following statement contains a magic number: unchecked {  				int h = 0;  				foreach (char c in text) {  					h = (h << 5) - h + c;  				}  				return h;  			}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,Dispose,The following statement contains a magic number: using (var stream = new BinaryWriter (File.OpenWrite (fileName)' Encoding.UTF8)) {  					stream.Write ((byte)CurrentVersion.Major);  					stream.Write ((byte)CurrentVersion.Minor);  					stream.Write ((byte)CurrentVersion.Build);    					stream.Write (typeLookupList.Count);  					stream.Write (extMethodLookuplist.Count);  					stream.Write (assemblyLookups.Count);    					var typeBuffer = typeLookupMemory.ToArray ();  					var extMethodBuffer = extMethodLookupMemory.ToArray ();    					int dataOffset =   						headerSize +   						assemblyLookups.Count * 4 +   						typeLookupList.Count * (4 + 4) +   						extMethodLookuplist.Count * (4 + 4);    					for (int i = 0; i < assemblyLookups.Count; i++) {  						stream.Write ((int)(dataOffset + typeBuffer.Length + extMethodBuffer.Length + assemblyPositionTable[i]));  					}    					for (int i = 0; i < typeLookupList.Count; i++) {  						stream.Write (typeLookupList [i].Key);  						stream.Write (dataOffset + typeTable[i]);  					}    					for (int i = 0; i < extMethodLookuplist.Count; i++) {  						stream.Write (extMethodLookuplist [i].Key);  						stream.Write (dataOffset + typeBuffer.Length + extMethodTable[i]);  					}    					stream.Write (typeBuffer);  					stream.Write (extMethodBuffer);  					stream.Write (assemblyLookupMemory.ToArray ());  					stream.Flush ();  				}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,Dispose,The following statement contains a magic number: using (var stream = new BinaryWriter (File.OpenWrite (fileName)' Encoding.UTF8)) {  					stream.Write ((byte)CurrentVersion.Major);  					stream.Write ((byte)CurrentVersion.Minor);  					stream.Write ((byte)CurrentVersion.Build);    					stream.Write (typeLookupList.Count);  					stream.Write (extMethodLookuplist.Count);  					stream.Write (assemblyLookups.Count);    					var typeBuffer = typeLookupMemory.ToArray ();  					var extMethodBuffer = extMethodLookupMemory.ToArray ();    					int dataOffset =   						headerSize +   						assemblyLookups.Count * 4 +   						typeLookupList.Count * (4 + 4) +   						extMethodLookuplist.Count * (4 + 4);    					for (int i = 0; i < assemblyLookups.Count; i++) {  						stream.Write ((int)(dataOffset + typeBuffer.Length + extMethodBuffer.Length + assemblyPositionTable[i]));  					}    					for (int i = 0; i < typeLookupList.Count; i++) {  						stream.Write (typeLookupList [i].Key);  						stream.Write (dataOffset + typeTable[i]);  					}    					for (int i = 0; i < extMethodLookuplist.Count; i++) {  						stream.Write (extMethodLookuplist [i].Key);  						stream.Write (dataOffset + typeBuffer.Length + extMethodTable[i]);  					}    					stream.Write (typeBuffer);  					stream.Write (extMethodBuffer);  					stream.Write (assemblyLookupMemory.ToArray ());  					stream.Flush ();  				}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,Dispose,The following statement contains a magic number: using (var stream = new BinaryWriter (File.OpenWrite (fileName)' Encoding.UTF8)) {  					stream.Write ((byte)CurrentVersion.Major);  					stream.Write ((byte)CurrentVersion.Minor);  					stream.Write ((byte)CurrentVersion.Build);    					stream.Write (typeLookupList.Count);  					stream.Write (extMethodLookuplist.Count);  					stream.Write (assemblyLookups.Count);    					var typeBuffer = typeLookupMemory.ToArray ();  					var extMethodBuffer = extMethodLookupMemory.ToArray ();    					int dataOffset =   						headerSize +   						assemblyLookups.Count * 4 +   						typeLookupList.Count * (4 + 4) +   						extMethodLookuplist.Count * (4 + 4);    					for (int i = 0; i < assemblyLookups.Count; i++) {  						stream.Write ((int)(dataOffset + typeBuffer.Length + extMethodBuffer.Length + assemblyPositionTable[i]));  					}    					for (int i = 0; i < typeLookupList.Count; i++) {  						stream.Write (typeLookupList [i].Key);  						stream.Write (dataOffset + typeTable[i]);  					}    					for (int i = 0; i < extMethodLookuplist.Count; i++) {  						stream.Write (extMethodLookuplist [i].Key);  						stream.Write (dataOffset + typeBuffer.Length + extMethodTable[i]);  					}    					stream.Write (typeBuffer);  					stream.Write (extMethodBuffer);  					stream.Write (assemblyLookupMemory.ToArray ());  					stream.Flush ();  				}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,Dispose,The following statement contains a magic number: using (var stream = new BinaryWriter (File.OpenWrite (fileName)' Encoding.UTF8)) {  					stream.Write ((byte)CurrentVersion.Major);  					stream.Write ((byte)CurrentVersion.Minor);  					stream.Write ((byte)CurrentVersion.Build);    					stream.Write (typeLookupList.Count);  					stream.Write (extMethodLookuplist.Count);  					stream.Write (assemblyLookups.Count);    					var typeBuffer = typeLookupMemory.ToArray ();  					var extMethodBuffer = extMethodLookupMemory.ToArray ();    					int dataOffset =   						headerSize +   						assemblyLookups.Count * 4 +   						typeLookupList.Count * (4 + 4) +   						extMethodLookuplist.Count * (4 + 4);    					for (int i = 0; i < assemblyLookups.Count; i++) {  						stream.Write ((int)(dataOffset + typeBuffer.Length + extMethodBuffer.Length + assemblyPositionTable[i]));  					}    					for (int i = 0; i < typeLookupList.Count; i++) {  						stream.Write (typeLookupList [i].Key);  						stream.Write (dataOffset + typeTable[i]);  					}    					for (int i = 0; i < extMethodLookuplist.Count; i++) {  						stream.Write (extMethodLookuplist [i].Key);  						stream.Write (dataOffset + typeBuffer.Length + extMethodTable[i]);  					}    					stream.Write (typeBuffer);  					stream.Write (extMethodBuffer);  					stream.Write (assemblyLookupMemory.ToArray ());  					stream.Flush ();  				}
Magic Number,ICSharpCode.NRefactory.Completion,FrameworkBuilder,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Completion\FrameworkLookup.cs,Dispose,The following statement contains a magic number: using (var stream = new BinaryWriter (File.OpenWrite (fileName)' Encoding.UTF8)) {  					stream.Write ((byte)CurrentVersion.Major);  					stream.Write ((byte)CurrentVersion.Minor);  					stream.Write ((byte)CurrentVersion.Build);    					stream.Write (typeLookupList.Count);  					stream.Write (extMethodLookuplist.Count);  					stream.Write (assemblyLookups.Count);    					var typeBuffer = typeLookupMemory.ToArray ();  					var extMethodBuffer = extMethodLookupMemory.ToArray ();    					int dataOffset =   						headerSize +   						assemblyLookups.Count * 4 +   						typeLookupList.Count * (4 + 4) +   						extMethodLookuplist.Count * (4 + 4);    					for (int i = 0; i < assemblyLookups.Count; i++) {  						stream.Write ((int)(dataOffset + typeBuffer.Length + extMethodBuffer.Length + assemblyPositionTable[i]));  					}    					for (int i = 0; i < typeLookupList.Count; i++) {  						stream.Write (typeLookupList [i].Key);  						stream.Write (dataOffset + typeTable[i]);  					}    					for (int i = 0; i < extMethodLookuplist.Count; i++) {  						stream.Write (extMethodLookuplist [i].Key);  						stream.Write (dataOffset + typeBuffer.Length + extMethodTable[i]);  					}    					stream.Write (typeBuffer);  					stream.Write (extMethodBuffer);  					stream.Write (assemblyLookupMemory.ToArray ());  					stream.Flush ();  				}
Missing Default,ICSharpCode.NRefactory.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\XmlDocumentationProvider.cs,ReadXmlDoc,The following switch statement is missing a default case: switch (reader.LocalName) {  							case "members":  								ReadMembersSection(reader' linePosMapper' indexList);  								break;  						}
Missing Default,ICSharpCode.NRefactory.Documentation,XmlDocumentationProvider,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Documentation\XmlDocumentationProvider.cs,ReadMembersSection,The following switch statement is missing a default case: switch (reader.NodeType) {  					case XmlNodeType.EndElement:  						if (reader.LocalName == "members") {  							return;  						}  						break;  					case XmlNodeType.Element:  						if (reader.LocalName == "member") {  							int pos = linePosMapper.GetPositionForLine(reader.LineNumber) + Math.Max(reader.LinePosition - 2' 0);  							string memberAttr = reader.GetAttribute("name");  							if (memberAttr != null)  								indexList.Add(new IndexEntry(GetHashCode(memberAttr)' pos));  							reader.Skip();  						}  						break;  				}
Missing Default,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,TryGetDelimiterLengthAndType,The following switch statement is missing a default case: switch (curChar) {  			case LF:  				type = UnicodeNewline.LF;  				length = 1;  				return true;  			case NEL:  				type = UnicodeNewline.NEL;  				length = 1;  				return true;  			case VT:  				type = UnicodeNewline.VT;  				length = 1;  				return true;  			case FF:  				type = UnicodeNewline.FF;  				length = 1;  				return true;  			case LS:  				type = UnicodeNewline.LS;  				length = 1;  				return true;  			case PS:  				type = UnicodeNewline.PS;  				length = 1;  				return true;  			}
Missing Default,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  				case CR:  				if (nextChar != null && nextChar () == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  				case LF:  				return UnicodeNewline.LF;  				case NEL:  				return UnicodeNewline.NEL;  				case VT:  				return UnicodeNewline.VT;  				case FF:  				return UnicodeNewline.FF;  				case LS:  				return UnicodeNewline.LS;  				case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.NRefactory,NewLine,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Editor\UnicodeNewline.cs,GetDelimiterType,The following switch statement is missing a default case: switch (curChar) {  			case CR:  				if (nextChar == LF)  					return UnicodeNewline.CRLF;  				return UnicodeNewline.CR;  			case LF:  				return UnicodeNewline.LF;  			case NEL:  				return UnicodeNewline.NEL;  			case VT:  				return UnicodeNewline.VT;  			case FF:  				return UnicodeNewline.FF;  			case LS:  				return UnicodeNewline.LS;  			case PS:  				return UnicodeNewline.PS;  			}
Missing Default,ICSharpCode.NRefactory.Semantics,BuiltinConversion,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\Conversion.cs,ToString,The following switch statement is missing a default case: switch (type) {  					case 0:  						return "identity conversion";  					case 1:  						return "null-literal conversion";  					case 2:  						name = "constant-expression";  						break;  					case 3:  						name = "reference";  						break;  					case 4:  						name = "dynamic";  						break;  					case 5:  						name = "nullable";  						break;  					case 6:  						name = "pointer";  						break;  					case 7:  						return "boxing conversion";  					case 8:  						return "unboxing conversion";  					case 9:  						return "try cast";  				}
Missing Default,ICSharpCode.NRefactory.Semantics,MemberResolveResult,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Semantics\MemberResolveResult.cs,ComputeType,The following switch statement is missing a default case: switch (member.SymbolKind) {  				case SymbolKind.Constructor:  					return member.DeclaringType ?? SpecialType.UnknownType;  				case SymbolKind.Field:  					if (((IField)member).IsFixed)  						return new PointerType(member.ReturnType);  					break;  			}
Missing Default,ICSharpCode.NRefactory.TypeSystem,ReflectionHelper,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\TypeSystem\ReflectionHelper.cs,SkipAheadAndReadAssemblyName,The following switch statement is missing a default case: switch (reflectionTypeName[pos++]) {  					case '[':  						nestingLevel++;  						break;  					case ']':  						if (nestingLevel == 0)  							return null;  						nestingLevel--;  						break;  					case ''':  						if (nestingLevel == 0) {  							// first skip the whitespace  							while (pos < reflectionTypeName.Length && reflectionTypeName[pos] == ' ')  								pos++;  							// everything up to the end/next ']' is the assembly name  							int endPos = pos;  							while (endPos < reflectionTypeName.Length && reflectionTypeName[endPos] != ']')  								endPos++;  							return reflectionTypeName.Substring(pos' endPos - pos);  						}  						break;  				}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}  						break;  				}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastChecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (targetType) {  					case TypeCode.Char:  						switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}  						break;  					case TypeCode.SByte:  						switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}  						break;  					case TypeCode.Byte:  						switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}  						break;  					case TypeCode.Int16:  						switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}  						break;  					case TypeCode.UInt16:  						switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}  						break;  					case TypeCode.Int32:  						switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}  						break;  					case TypeCode.UInt32:  						switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}  						break;  					case TypeCode.Int64:  						switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}  						break;  					case TypeCode.UInt64:  						switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}  						break;  					case TypeCode.Single:  						switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}  						break;  					case TypeCode.Double:  						switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}  						break;  					case TypeCode.Decimal:  						switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}  						break;  				}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.SByte:   return (char)(sbyte)input;  								case TypeCode.Byte:    return (char)(byte)input;  								case TypeCode.Int16:   return (char)(short)input;  								case TypeCode.UInt16:  return (char)(ushort)input;  								case TypeCode.Int32:   return (char)(int)input;  								case TypeCode.UInt32:  return (char)(uint)input;  								case TypeCode.Int64:   return (char)(long)input;  								case TypeCode.UInt64:  return (char)(ulong)input;  								case TypeCode.Single:  return (char)(float)input;  								case TypeCode.Double:  return (char)(double)input;  								case TypeCode.Decimal: return (char)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (sbyte)(char)input;  								case TypeCode.Byte:    return (sbyte)(byte)input;  								case TypeCode.Int16:   return (sbyte)(short)input;  								case TypeCode.UInt16:  return (sbyte)(ushort)input;  								case TypeCode.Int32:   return (sbyte)(int)input;  								case TypeCode.UInt32:  return (sbyte)(uint)input;  								case TypeCode.Int64:   return (sbyte)(long)input;  								case TypeCode.UInt64:  return (sbyte)(ulong)input;  								case TypeCode.Single:  return (sbyte)(float)input;  								case TypeCode.Double:  return (sbyte)(double)input;  								case TypeCode.Decimal: return (sbyte)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (byte)(char)input;  								case TypeCode.SByte:   return (byte)(sbyte)input;  								case TypeCode.Int16:   return (byte)(short)input;  								case TypeCode.UInt16:  return (byte)(ushort)input;  								case TypeCode.Int32:   return (byte)(int)input;  								case TypeCode.UInt32:  return (byte)(uint)input;  								case TypeCode.Int64:   return (byte)(long)input;  								case TypeCode.UInt64:  return (byte)(ulong)input;  								case TypeCode.Single:  return (byte)(float)input;  								case TypeCode.Double:  return (byte)(double)input;  								case TypeCode.Decimal: return (byte)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (short)(char)input;  								case TypeCode.SByte:   return (short)(sbyte)input;  								case TypeCode.Byte:    return (short)(byte)input;  								case TypeCode.UInt16:  return (short)(ushort)input;  								case TypeCode.Int32:   return (short)(int)input;  								case TypeCode.UInt32:  return (short)(uint)input;  								case TypeCode.Int64:   return (short)(long)input;  								case TypeCode.UInt64:  return (short)(ulong)input;  								case TypeCode.Single:  return (short)(float)input;  								case TypeCode.Double:  return (short)(double)input;  								case TypeCode.Decimal: return (short)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ushort)(char)input;  								case TypeCode.SByte:   return (ushort)(sbyte)input;  								case TypeCode.Byte:    return (ushort)(byte)input;  								case TypeCode.Int16:   return (ushort)(short)input;  								case TypeCode.Int32:   return (ushort)(int)input;  								case TypeCode.UInt32:  return (ushort)(uint)input;  								case TypeCode.Int64:   return (ushort)(long)input;  								case TypeCode.UInt64:  return (ushort)(ulong)input;  								case TypeCode.Single:  return (ushort)(float)input;  								case TypeCode.Double:  return (ushort)(double)input;  								case TypeCode.Decimal: return (ushort)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (int)(char)input;  								case TypeCode.SByte:   return (int)(sbyte)input;  								case TypeCode.Byte:    return (int)(byte)input;  								case TypeCode.Int16:   return (int)(short)input;  								case TypeCode.UInt16:  return (int)(ushort)input;  								case TypeCode.UInt32:  return (int)(uint)input;  								case TypeCode.Int64:   return (int)(long)input;  								case TypeCode.UInt64:  return (int)(ulong)input;  								case TypeCode.Single:  return (int)(float)input;  								case TypeCode.Double:  return (int)(double)input;  								case TypeCode.Decimal: return (int)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (uint)(char)input;  								case TypeCode.SByte:   return (uint)(sbyte)input;  								case TypeCode.Byte:    return (uint)(byte)input;  								case TypeCode.Int16:   return (uint)(short)input;  								case TypeCode.UInt16:  return (uint)(ushort)input;  								case TypeCode.Int32:   return (uint)(int)input;  								case TypeCode.Int64:   return (uint)(long)input;  								case TypeCode.UInt64:  return (uint)(ulong)input;  								case TypeCode.Single:  return (uint)(float)input;  								case TypeCode.Double:  return (uint)(double)input;  								case TypeCode.Decimal: return (uint)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (long)(char)input;  								case TypeCode.SByte:   return (long)(sbyte)input;  								case TypeCode.Byte:    return (long)(byte)input;  								case TypeCode.Int16:   return (long)(short)input;  								case TypeCode.UInt16:  return (long)(ushort)input;  								case TypeCode.Int32:   return (long)(int)input;  								case TypeCode.UInt32:  return (long)(uint)input;  								case TypeCode.UInt64:  return (long)(ulong)input;  								case TypeCode.Single:  return (long)(float)input;  								case TypeCode.Double:  return (long)(double)input;  								case TypeCode.Decimal: return (long)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (ulong)(char)input;  								case TypeCode.SByte:   return (ulong)(sbyte)input;  								case TypeCode.Byte:    return (ulong)(byte)input;  								case TypeCode.Int16:   return (ulong)(short)input;  								case TypeCode.UInt16:  return (ulong)(ushort)input;  								case TypeCode.Int32:   return (ulong)(int)input;  								case TypeCode.UInt32:  return (ulong)(uint)input;  								case TypeCode.Int64:   return (ulong)(long)input;  								case TypeCode.Single:  return (ulong)(float)input;  								case TypeCode.Double:  return (ulong)(double)input;  								case TypeCode.Decimal: return (ulong)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (float)(char)input;  								case TypeCode.SByte:   return (float)(sbyte)input;  								case TypeCode.Byte:    return (float)(byte)input;  								case TypeCode.Int16:   return (float)(short)input;  								case TypeCode.UInt16:  return (float)(ushort)input;  								case TypeCode.Int32:   return (float)(int)input;  								case TypeCode.UInt32:  return (float)(uint)input;  								case TypeCode.Int64:   return (float)(long)input;  								case TypeCode.UInt64:  return (float)(ulong)input;  								case TypeCode.Double:  return (float)(double)input;  								case TypeCode.Decimal: return (float)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (double)(char)input;  								case TypeCode.SByte:   return (double)(sbyte)input;  								case TypeCode.Byte:    return (double)(byte)input;  								case TypeCode.Int16:   return (double)(short)input;  								case TypeCode.UInt16:  return (double)(ushort)input;  								case TypeCode.Int32:   return (double)(int)input;  								case TypeCode.UInt32:  return (double)(uint)input;  								case TypeCode.Int64:   return (double)(long)input;  								case TypeCode.UInt64:  return (double)(ulong)input;  								case TypeCode.Single:  return (double)(float)input;  								case TypeCode.Decimal: return (double)(decimal)input;  						}
Missing Default,ICSharpCode.NRefactory.Utils,CSharpPrimitiveCast,C:\repos\icsharpcode_NRefactory\ICSharpCode.NRefactory\Utils\CSharpPrimitiveCast.cs,CSharpPrimitiveCastUnchecked,The following switch statement is missing a default case: switch (sourceType) {  								case TypeCode.Char:    return (decimal)(char)input;  								case TypeCode.SByte:   return (decimal)(sbyte)input;  								case TypeCode.Byte:    return (decimal)(byte)input;  								case TypeCode.Int16:   return (decimal)(short)input;  								case TypeCode.UInt16:  return (decimal)(ushort)input;  								case TypeCode.Int32:   return (decimal)(int)input;  								case TypeCode.UInt32:  return (decimal)(uint)input;  								case TypeCode.Int64:   return (decimal)(long)input;  								case TypeCode.UInt64:  return (decimal)(ulong)input;  								case TypeCode.Single:  return (decimal)(float)input;  								case TypeCode.Double:  return (decimal)(double)input;  						}
