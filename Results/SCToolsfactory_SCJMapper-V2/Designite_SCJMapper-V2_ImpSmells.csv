Implementation smell,Namespace,Class,File,Method,Description
Long Method,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The method has 112 lines of code.
Long Method,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The method has 1411 lines of code.
Long Method,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The method has 494 lines of code.
Long Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The method has 122 lines of code.
Long Method,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,The method has 162 lines of code.
Long Method,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The method has 602 lines of code.
Long Method,SCJMapper_V2.Options,OptionTree,C:\repos\SCToolsfactory_SCJMapper-V2\Options\OptionTree.cs,fromXML,The method has 144 lines of code.
Long Method,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The method has 332 lines of code.
Long Method,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The method has 411 lines of code.
Long Method,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The method has 586 lines of code.
Long Method,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The method has 450 lines of code.
Long Method,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The method has 120 lines of code.
Long Method,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The method has 1874 lines of code.
Long Method,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The method has 326 lines of code.
Complex Method,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,Cyclomatic complexity of the method is 10
Complex Method,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,Cyclomatic complexity of the method is 14
Complex Method,SCJMapper_V2,ActionMapsCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionMapsCls.cs,toXML,Cyclomatic complexity of the method is 11
Complex Method,SCJMapper_V2,ActionMapsCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionMapsCls.cs,fromXML,Cyclomatic complexity of the method is 8
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FilterTree,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateActivationModeSelectedItem,Cyclomatic complexity of the method is 8
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateSelectedItem,Cyclomatic complexity of the method is 8
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAndSelectCtrl,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAndSelectCtrlByName,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActions,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,Cyclomatic complexity of the method is 10
Complex Method,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,Cyclomatic complexity of the method is 16
Complex Method,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,Cyclomatic complexity of the method is 28
Complex Method,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_fromXML,Cyclomatic complexity of the method is 14
Complex Method,SCJMapper_V2.Options,Deviceoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Deviceoptions.cs,fromXML,Cyclomatic complexity of the method is 12
Complex Method,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,CollectActions,Cyclomatic complexity of the method is 11
Complex Method,SCJMapper_V2.SC,SCLogExtract,C:\repos\SCToolsfactory_SCJMapper-V2\SC\SCLogExtract.cs,ExtractValuableInfo,Cyclomatic complexity of the method is 15
Complex Method,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,ComposeFilter,Cyclomatic complexity of the method is 9
Complex Method,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GamepadCls,Cyclomatic complexity of the method is 17
Complex Method,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GetLastChange,Cyclomatic complexity of the method is 22
Complex Method,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateControls,Cyclomatic complexity of the method is 11
Complex Method,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,Cyclomatic complexity of the method is 16
Complex Method,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,EvalChartInput,Cyclomatic complexity of the method is 10
Complex Method,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,Cyclomatic complexity of the method is 25
Complex Method,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,Cyclomatic complexity of the method is 8
Long Parameter List,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,DefineShowOptions,The method has 5 parameters. Parameters: showJoystick' showGamepad' showKeyboard' showMouse' showMappedOnly
Long Parameter List,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,AddT_ActionRow,The method has 10 parameters. Parameters: ID_Action' parentT_ActionMapRowByT_ActionMap_T_Action' ActionName' Device' Def_Binding' Def_Modifier' AddBind' Usr_Binding' Usr_Modifier' Disabled
Long Parameter List,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JoystickCls,The method has 5 parameters. Parameters: device' hwnd' joystickNum' panel' tabIndex
Long Parameter List,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,CubicSpline,The method has 5 parameters. Parameters: x' y' startSlope' endSlope' debug
Long Parameter List,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,FitAndEval,The method has 5 parameters. Parameters: x' y' xs' startSlope' endSlope
Long Parameter List,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Compute,The method has 5 parameters. Parameters: x' y' xs' startSlope' endSlope
Long Parameter List,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,FitGeometric,The method has 5 parameters. Parameters: x' y' nOutputPoints' xs' ys
Long Parameter List,SCJMapper_V2.OGL,RK4Integrator,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\RK4Integrator.cs,Evaluate,The method has 5 parameters. Parameters: initial' dt' d' dampK' dampB
Long Identifier,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,,The length of the parameter resetDefaultsToolStripMenuItem is 30.
Long Identifier,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,,The length of the parameter resetLoadAndGrabToolStripMenuItem is 33.
Long Identifier,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,,The length of the parameter defaultsLoadAndGrabToolStripMenuItem is 36.
Long Identifier,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,AddT_ActionRow,The length of the parameter parentT_ActionMapRowByT_ActionMap_T_Action is 42.
Long Statement,SCJMapper_V2,ActionCommandCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCommandCls.cs,ReassignJsN,The length of the statement  "          if ( newJsList.ContainsOldJs( oldJsN ) ) newAc.DevID = JoystickCls.ReassignJSTag( this.DevID' newJsList.newJsFromOldJs( oldJsN ) ); " is 131.
Long Statement,SCJMapper_V2,ActionCommandCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCommandCls.cs,toXML,The length of the statement  "        r += string.Format( "input=\"{0}_{1}\" {2} "' DevID' DeviceCls.toXML( Input )' DeviceCls.toXMLBlendExtension(Input) ); // add multitap override if needed " is 153.
Long Statement,SCJMapper_V2,DeviceCls,C:\repos\SCToolsfactory_SCJMapper-V2\DeviceCls.cs,toXMLBlendExtension,The length of the statement  "      return (IsBlendedInput(blendedInput) ? string.Format( "multiTap=\"1\"") : "" ); // blending needs to overwrite potential multitaps (2+) " is 135.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The length of the statement  "        MessageBox.Show( "Initializing DirectXInput failed - program exits now"' "ERROR"' MessageBoxButtons.OK' MessageBoxIcon.Information ); " is 133.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The length of the statement  "          ToolStripMenuItem ts = new ToolStripMenuItem( "Button " + ( i + 1 ).ToString( )' null' new EventHandler( tmeItem_Click ) ); " is 123.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitActionTree,The length of the statement  "      m_AT.DefineShowOptions( cbxShowJoystick.Checked' cbxShowGamepad.Checked' cbxShowKeyboard.Checked' cbxShowMouse.Checked' cbxShowMappedOnly.Checked ); " is 148.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The length of the statement  "        foreach ( DeviceInstance instance in directInput.GetDevices( DeviceClass.GameControl' DeviceEnumerationFlags.AttachedOnly ) ) { " is 127.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The length of the statement  "                log.InfoFormat( "Scan Input {0} for gamepad - {1}"' i' dxGamepad.GetCapabilities( SharpDX.XInput.DeviceQueryType.Gamepad ).ToString( ) ); " is 137.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The length of the statement  "        DeviceInst.GamepadInst = new GamepadCls( dxGamepad' uUC_GpadPanelNew' tabs ); // does all device related activities for that particular item " is 140.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The length of the statement  "        js = new JoystickCls( myJs.js' this' nJs' uUC_JoyPanelNew' tabs ); // does all device related activities for that particular item " is 129.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitDirectInput,The length of the statement  "        MessageBox.Show( "Unable to create a joystick device. Program will exit."' "No joystick found"' MessageBoxButtons.OK' MessageBoxIcon.Information ); " is 147.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Grab,The length of the statement  "      m_AT.DefineShowOptions( cbxShowJoystick.Checked' cbxShowGamepad.Checked' cbxShowKeyboard.Checked' cbxShowMouse.Checked' cbxShowMappedOnly.Checked ); " is 148.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Grab,The length of the statement  "      btDump.BackColor = btClear.BackColor; btDump.UseVisualStyleBackColor = btClear.UseVisualStyleBackColor; // neutral again " is 120.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Grab,The length of the statement  "      btGrab.BackColor = btClear.BackColor; btGrab.UseVisualStyleBackColor = btClear.UseVisualStyleBackColor; // neutral again " is 120.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Dump,The length of the statement  "      rtb.Text = string.Format( "<!-- {0} - SC Joystick Mapping - {1} -->\n{2}"' DateTime.Now' txMappingName.Text' m_AT.toXML( txMappingName.Text ) ); " is 144.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Dump,The length of the statement  "      btDump.BackColor = btClear.BackColor; btDump.UseVisualStyleBackColor = btClear.UseVisualStyleBackColor; // neutral again " is 120.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,Dump,The length of the statement  "      btGrab.BackColor = btClear.BackColor; btGrab.UseVisualStyleBackColor = btClear.UseVisualStyleBackColor; // neutral again " is 120.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,cbxShowTreeOptions_CheckedChanged,The length of the statement  "      m_AT.DefineShowOptions( cbxShowJoystick.Checked' cbxShowGamepad.Checked' cbxShowKeyboard.Checked' cbxShowMouse.Checked' cbxShowMappedOnly.Checked ); " is 148.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btFind_Click,The length of the statement  "      m_AT.FindAndSelectCtrl( JoystickCls.MakeThrottle( lblLastJ.Text' cbxThrottle.Checked ) ' ""); // find the action for a Control (joystick input) " is 143.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btDumpList_Click,The length of the statement  "        rtb.Text = string.Format( "-- {0} - SC Joystick Mapping --\n{1}"' DateTime.Now' m_AT.ReportActionsCSV( m_AppSettings.ListModifiers ) ); " is 135.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btDumpLog_Click,The length of the statement  "      rtb.Text = string.Format( "-- {0} - SC Joystick AC Log Controller Detection --\n{1}"' DateTime.Now' SCLogExtract.ExtractLog( ) ); " is 129.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,tdiCbxActivation_Click,The length of the statement  "      if ( !string.IsNullOrEmpty( m_prevActivationMode.Name ) && ( m_prevActivationMode.Name != (string)tdiCbxActivation.SelectedItem ) ) { " is 133.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btSaveMyMapping_Click,The length of the statement  "          cancel = ( MessageBox.Show( "File exists' shall we overwrite ?"' "Save XML"' MessageBoxButtons.YesNo ) == System.Windows.Forms.DialogResult.No ); " is 145.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btSaveMyMapping_Click,The length of the statement  "          rtb.SaveFile( TheUser.MappingFileName( txMappingName.Text )' RichTextBoxStreamType.PlainText ); // also save the new one in the user space " is 138.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,btJsReassign_Click,The length of the statement  "        m_AT.DefineShowOptions( cbxShowJoystick.Checked' cbxShowGamepad.Checked' cbxShowKeyboard.Checked' cbxShowMouse.Checked' cbxShowMappedOnly.Checked ); " is 148.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The length of the statement  "        log.ErrorFormat( "UpdateOptionItem - Tuning item for device not found - dev: {0} - option: {1}"' dev.DevName' optionName ); " is 123.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The length of the statement  "        if ( nodeText.ToLowerInvariant( ).EndsWith( "_x" ) || nodeText.ToLowerInvariant( ).EndsWith( "_rotx" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttlex" ) " is 159.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The length of the statement  "          || nodeText.ToLowerInvariant( ).EndsWith( "_y" ) || nodeText.ToLowerInvariant( ).EndsWith( "_roty" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttley" ) " is 157.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The length of the statement  "          || nodeText.ToLowerInvariant( ).EndsWith( "_Z" ) || nodeText.ToLowerInvariant( ).EndsWith( "_rotz" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttlez" ) " is 157.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,FTAB_UpdateEditEvent,The length of the statement  "        m_AT.DefineShowOptions( cbxShowJoystick.Checked' cbxShowGamepad.Checked' cbxShowKeyboard.Checked' cbxShowMouse.Checked' cbxShowMappedOnly.Checked ); " is 148.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm)); " is 128.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.rtb.Font = new System.Drawing.Font("Lucida Console"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 147.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btGrab.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 142.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.lblAssigned.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.lblAction.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.treeView1.NodeMouseClick += new System.Windows.Forms.TreeNodeMouseClickEventHandler(this.treeView1_NodeMouseClick); " is 120.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tc1.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.linkLblReleases.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLblReleases_LinkClicked); " is 128.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.lblTitle.Font = new System.Drawing.Font("Segoe UI"' 14.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.buttonExit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 146.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 50F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 50F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btOptions.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btJSTuning.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 146.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btTable.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 143.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 50F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 50F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btJsReassign.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 150.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute' 240F)); " is 124.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.btSaveMyMapping.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.lblPTU.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 20F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 20F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 20F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 20F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 20F)); " is 122.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.lblProfileUsed.Font = new System.Drawing.Font("Segoe UI"' 6.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 152.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.label3.Font = new System.Drawing.Font("Segoe UI"' 6.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tcXML.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 140.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel6.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.toolStripStatusLabel2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.toolStripStatusLabel3.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 159.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.toolStripStatusLabel1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.tsDDbtMappings.DropDownItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.tsDDbtMappings_DropDownItemClicked); " is 142.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.defaultsLoadAndGrabToolStripMenuItem.Click += new System.EventHandler(this.defaultsLoadAndGrabToolStripMenuItem_Click); " is 124.
Long Statement,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The length of the statement  "      this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,SaveSettings,The length of the statement  "        MessageBox.Show( "Changing the Gamepad option needs a restart of the application !!"' "Settings Notification"' MessageBoxButtons.OK' MessageBoxIcon.Information ); " is 162.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,SaveSettings,The length of the statement  "        MessageBox.Show( "Changing to / from PTU folders needs a restart of the application !!"' "Settings Notification"' MessageBoxButtons.OK' MessageBoxIcon.Information ); " is 165.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormSettings)); " is 132.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      this.groupBox1.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      this.groupBox2.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      this.groupBox3.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      this.groupBox4.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The length of the statement  "      this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2,ActionCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCls.cs,ADevice,The length of the statement  "        case MouseCls.DeviceClass: return ActionDevice.AD_Mouse;   // 20151220BM: add mouse device (from AC 2.0 defaultProfile usage) " is 125.
Long Statement,SCJMapper_V2,ActionCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCls.cs,UpdateCommandFromInput,The length of the statement  "        this.inputList[accIndex].ActivationMode = new ActivationMode( ActivationMode.Default ); // reset activation mode if the input is empty " is 134.
Long Statement,SCJMapper_V2,ActionCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCls.cs,fromXML,The length of the statement  "          reader.ReadStartElement( "action" ); // Checks that the current content node is an element with the given Name and advances the reader to the next node " is 151.
Long Statement,SCJMapper_V2,ActionCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCls.cs,fromXML,The length of the statement  "              actMode = ActivationModes.Instance.ActivationModeByName( actModeName ); // should be a valid ActivationMode for this action " is 123.
Long Statement,SCJMapper_V2,ActionCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionCls.cs,fromXML,The length of the statement  "              actMode = ActivationModes.Instance.ActivationModeByName( actModeName ); // should be a valid ActivationMode for this action " is 123.
Long Statement,SCJMapper_V2,ActionMapsCls,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionMapsCls.cs,toXML,The length of the statement  "      r += string.Format( " profileName=\"{0}\" \n"' fileName.Replace( SCMappings.c_MapStartsWith' "" ) ); //AC2 add profilename " is 122.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateMasterNode,The length of the statement  "      if ( masterNode.Length == 0 ) throw new IndexOutOfRangeException( "ActionTree ERROR - cannot find synched node in master" ); // OUT OF SYNC " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateMasterNode,The length of the statement  "      if ( masterNode.Length == 0 ) throw new IndexOutOfRangeException( "ActionTree ERROR - cannot find synched node in master" ); // OUT OF SYNC " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindMasterAction,The length of the statement  "      if ( masterNode.Length == 0 ) throw new IndexOutOfRangeException( "ActionTree ERROR - cannot find synched node in master" ); // OUT OF SYNC " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindMasterAction,The length of the statement  "      if ( masterNode.Length == 0 ) throw new IndexOutOfRangeException( "ActionTree ERROR - cannot find synched node in master" ); // OUT OF SYNC " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ApplyFilter,The length of the statement  "              ActionTreeInputNode tnActionInput = new ActionTreeInputNode( istn ); tnAction.Nodes.Add( tnActionInput ); // copy level 2 nodes " is 127.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The length of the statement  "              for ( int ei = 1; ei < elem.Length; ei += 4 ) { // step 2  - action;defaultBinding;defaultActivationMode;defMultiTap come in as quadrupples " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The length of the statement  "                  cn = new ActionTreeNode( "UNDEF" ); cn.Name = elem[ei]; cn.Action = action; cn.BackColor = Color.White;  // name with the key it to find it..                 " is 141.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The length of the statement  "                  ac = new ActionCls( ); ac.key = cn.Name; ac.name = action; ac.device = device; ac.actionDevice = ActionCls.ADevice( device ); " is 125.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The length of the statement  "                  else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Mouse ) {  // 20151220BM: add mouse device (from AC 2.0 defaultProfile usage) " is 132.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The length of the statement  "      ActivationModes am = new ActivationModes( ActivationMode.Default' ActivationMode.Default );// policy: get the default first' then the attached one - dummy answer " is 161.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The length of the statement  "        ActionCommandCls acc = ac.FindActionInputObject( ActionTreeNode.CommandFromNodeText( atn.Text ) ); if ( acc == null ) return am; // ERROR exit " is 142.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The length of the statement  "        am = new ActivationModes( ac.defActivationMode' acc.ActivationMode ); // policy: get the default first' then the attached one " is 125.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The length of the statement  "        am = new ActivationModes( ac.defActivationMode' acc.ActivationMode );// policy: get the default first' then the attached one " is 124.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateActivationModeSelectedItem,The length of the statement  "        ActionCommandCls acc = ac.FindActionInputObject( ActionTreeNode.CommandFromNodeText( atn.Text ) ); if ( acc == null ) return; // ERROR exit " is 139.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateSelectedItem,The length of the statement  "            if ( ( inKind != ActionCls.ActionDevice.AD_Keyboard ) && ( inKind != ActionCls.ActionDevice.AD_Mouse ) ) return false; // ERROR exit " is 132.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The length of the statement  "      rtf.Write( "Location" ); rtf.WriteTab( "Action" ); rtf.WriteTab( "Actionmap" ); rtf.WriteTab( "Activation Mode".PadRight( 40 ) ); rtf.WriteLn( ); " is 145.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The length of the statement  "              rtf.Write( "mapped" ); rtf.WriteTab( ac.name ); rtf.WriteTab( acm.name ); rtf.WriteTab( aMode.PadRight( 80 ) ); rtf.WriteLn( ); " is 127.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateFromDataSet,The length of the statement  "      nTree.ActionMaps = this.ActionMaps.ReassignJsN( new JsReassingList( ) ); // re-use this method with no reassign for full copy of the tree " is 137.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateFromDataSet,The length of the statement  "          ActionCommandCls acc = FindActionInputObject( nTree' DS_ActionMap.ActionMap( ar )' DS_ActionMap.ActionKey( ar )' DS_ActionMap.ActionCommandIndex( ar ) ); " is 153.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateFromDataSet,The length of the statement  "            acc.UpdateCommandFromInput( ActionCls.DevInput( DS_ActionMap.DevInput( ar )' ActionCls.ADevice( ar.Device ) )' ActionCls.ADevice( ar.Device ) ); " is 144.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The length of the statement  "        if ( !string.IsNullOrEmpty( ActionMaps.jsN[i] ) ) repList += string.Format( "** js{0} = {1}\n"' i + 1' ActionMaps.jsN[i] ); " is 123.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The length of the statement  "      repList += string.Format( " {0}+- {1} _ {2}#-[{4}] {3}\n\n"' "Action".PadRight( padAction )' "Dev".PadRight( padDevice )' "Binding".PadRight( padInput )' "Activation"' "T" ); // col description line " is 198.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The length of the statement  "                  rep = string.Format( " {0} . {1} _ {2}"' ac.name.PadRight( padAction )' acc.DevID.PadRight( padDevice )' acc.Input.PadRight( padInput ) ); " is 138.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The length of the statement  "                  rep = string.Format( " {0} + {1} _ {2}"' ac.name.PadRight( padAction )' acc.DevID.PadRight( padDevice )' acc.Input.PadRight( padInput ) ); // my binding " is 152.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The length of the statement  "        if ( !string.IsNullOrEmpty( ActionMaps.jsN[i] ) ) repList += string.Format( "** js{0} = {1}\n"' i + 1' ActionMaps.jsN[i] ); " is 123.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The length of the statement  "              rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] ); // should be one line now " is 129.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The length of the statement  "                if ( acc.ActivationMode == ActivationMode.Default ) aMode = string.Format( "default;{0};{1}"' ac.defActivationMode.Name' ac.defActivationMode.MultiTap ); " is 153.
Long Statement,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The length of the statement  "      rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] ); // should be one line now " is 129.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,The length of the statement  "          lvi = new ListViewItem( option' lvg ); lvi.Name = option; lvi.Name = option; lview.Items.Add( lvi ); ListViewItemSetup( lvi ); " is 126.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,The length of the statement  "        option = "flight_move_strafe_vertical"; tuning = m_tuningRef.TuningItem( (string)lview.Tag' option ); m_live.Load( tuning ); " is 124.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,The length of the statement  "        option = "flight_move_strafe_lateral"; tuning = m_tuningRef.TuningItem( (string)lview.Tag' option ); m_live.Load( tuning ); " is 123.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,OptionTreeSetup,The length of the statement  "        option = "flight_move_strafe_longitudinal"; tuning = m_tuningRef.TuningItem( (string)lview.Tag' option ); m_live.Load( tuning ); " is 128.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "        lblLiveOutSaturation.Text = "1.000"; cbxUseSaturation.Checked = false; tbSaturation.Enabled = false; cbxUseSaturation.Enabled = false; " is 134.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "        lblLiveIn1.Text = "0.250"; lblLiveOut1.Text = "0.250"; lblLiveIn2.Text = "0.500"; lblLiveOut2.Text = "0.500"; lblLiveIn3.Text = "0.750"; lblLiveOut3.Text = "0.750"; " is 164.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "      //      pnlDevOptionInput.Visible = !lv.AcceptGameDevice; // cannot assign DevOptions to Tuning parameters without Action (will just dumped the Option only) " is 156.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "        lblLiveIn1.Text = lv.nonLinCurve.Pt( 0 ).X.ToString( "0.000" ); lblLiveOut1.Text = lv.nonLinCurve.Pt( 0 ).Y.ToString( "0.000" ); " is 128.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "        lblLiveIn2.Text = lv.nonLinCurve.Pt( 1 ).X.ToString( "0.000" ); lblLiveOut2.Text = lv.nonLinCurve.Pt( 1 ).Y.ToString( "0.000" ); " is 128.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The length of the statement  "        lblLiveIn3.Text = lv.nonLinCurve.Pt( 2 ).X.ToString( "0.000" ); lblLiveOut3.Text = lv.nonLinCurve.Pt( 2 ).Y.ToString( "0.000" ); " is 128.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The length of the statement  "          lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3 " is 144.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The length of the statement  "          lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3 " is 132.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea(); " is 135.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series(); " is 126.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormOptions)); " is 131.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute' 670F)); " is 124.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbUsePts.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 155.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbUseExpo.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 156.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbUseNone.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 156.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbLivePtExponent.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 148.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOutExponent.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveIn1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOut1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.cbxLiveInvert.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 160.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveIn2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOut2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveIn3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbLivePt3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOut3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbLivePt2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.label32.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.rbLivePt1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.label33.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblGraphSaturation.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblGraphDeadzone.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 151.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveNodetext.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 150.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      chartArea1.AxisX.MajorTickMark.IntervalType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 122.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      chartArea1.AxisX.MinorTickMark.IntervalOffsetType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 128.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      chartArea1.AxisY.MajorTickMark.IntervalType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 122.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0))))); " is 122.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.cbxUseSaturation.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 163.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.cbxUseDeadzone.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 161.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOutSaturation.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 155.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.lblLiveOutDeadzone.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The length of the statement  "      this.btExit.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Load,The length of the statement  "            string[] e = nodetext.Split( new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries ); " is 140.
Long Statement,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Update,The length of the statement  "        pts.Add( nonLinCurve.Pt( 0 ).X.ToString( "0.000" ) ); pts.Add( nonLinCurve.Pt( 1 ).X.ToString( "0.000" ) ); pts.Add( nonLinCurve.Pt( 2 ).X.ToString( "0.000" ) ); " is 161.
Long Statement,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Update,The length of the statement  "        pts.Add( nonLinCurve.Pt( 0 ).Y.ToString( "0.000" ) ); pts.Add( nonLinCurve.Pt( 1 ).Y.ToString( "0.000" ) ); pts.Add( nonLinCurve.Pt( 2 ).Y.ToString( "0.000" ) ); " is 161.
Long Statement,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,PtS,The length of the statement  "          return nonLinCurve.Pt( ptIndex - 1 ).X.ToString( "0.000" ) + " / " + nonLinCurve.Pt( ptIndex - 1 ).Y.ToString( "0.000" ); " is 121.
Long Statement,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,CheckClone,The length of the statement  "          ret &= ( !object.ReferenceEquals( this.ElementAt( i ).Value' clone.ElementAt( i ).Value ) );  // shall not be the same object !! " is 128.
Long Statement,SCJMapper_V2.Options,DeviceOptionParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceOptionParameter.cs,Deviceoptions_toXML,The length of the statement  "        if ( SaturationSupported && SaturationUsed ) tmp += string.Format( "\t\t<option input=\"{0}\" saturation=\"{1}\" />\n"' m_cmdCtrl' m_saturation ); " is 146.
Long Statement,SCJMapper_V2.Options,Deviceoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Deviceoptions.cs,DevOptionID,The length of the statement  "      return string.Format( "{0}{1}{2}"' ( GamepadCls.IsDeviceClass( deviceClass ) ) ? GamepadCls.DevNameCIG : devName' ID_Delimiter' cmd ); " is 134.
Long Statement,SCJMapper_V2.Options,Deviceoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Deviceoptions.cs,CheckClone,The length of the statement  "          ret &= ( !object.ReferenceEquals( this.ElementAt( i ).Value' clone.ElementAt( i ).Value ) );  // shall not be the same object !! " is 128.
Long Statement,SCJMapper_V2.Options,Deviceoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Deviceoptions.cs,fromXML,The length of the statement  "        string devClass = ( name == GamepadCls.DevNameCIG ) ? GamepadCls.DeviceClass : JoystickCls.DeviceClass;// have to trick this one... " is 131.
Long Statement,SCJMapper_V2.Options,Deviceoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Deviceoptions.cs,fromXML,The length of the statement  "                    //this.Add( doID' new DeviceOptionParameter( devClass' name' input' deadzone' saturation ) ); // actually not supported.. " is 121.
Long Statement,SCJMapper_V2.Options,OptionTree,C:\repos\SCToolsfactory_SCJMapper-V2\Options\OptionTree.cs,CheckClone,The length of the statement  "          ret &= ( !object.ReferenceEquals( this.m_tuning.ElementAt( i ).Value' clone.m_tuning.ElementAt( i ).Value ) );  // shall not be the same object !! " is 146.
Long Statement,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,CollectActions,The length of the statement  "      ActivationMode actMode = new ActivationMode( actModeName' int.Parse( multiTap ) ); // should be a valid ActivationMode for this action " is 134.
Long Statement,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,ReadActionSub,The length of the statement  "          <action name = "v_throttle_100" onPress = "1" xboxpad = " " joystick = " " UILabel = "@ui_CIThrottleMax" UIDescription = "@ui_CIThrottleMaxDesc" > " is 146.
Long Statement,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,ReadElement,The length of the statement  "                if ( !m_aMap.ContainsKey( mapName ) ) { //20170325 - fix multiple map names - don't add the second' third etc. (CIG bug..) " is 122.
Long Statement,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,fromXML,The length of the statement  "      if ( ActionMapsCls.ActionMaps.Length == 0 ) ActionMapsCls.LoadSupportedActionMaps( ActionMapList( xml ) ); // make sure we have them loaded ( refactoring to get a singleton or so...) " is 182.
Long Statement,SCJMapper_V2.SC,SCDefaultProfile,C:\repos\SCToolsfactory_SCJMapper-V2\SC\SCDefaultProfile.cs,ExtractDefaultBinProfile,The length of the statement  "            ICollection<ZipEntry> gdpak = zip.SelectEntries( "name = " + "'" + defaultProfileName + "'"' SCPath.DefaultProfilePath_rel ); " is 125.
Long Statement,SCJMapper_V2.SC,SCDefaultProfile,C:\repos\SCToolsfactory_SCJMapper-V2\SC\SCDefaultProfile.cs,ExtractDefaultProfile,The length of the statement  "            ICollection<ZipEntry> gdpak = zip.SelectEntries( "name = " + "'" + defaultProfileName + "'"' SCPath.DefaultProfilePath_rel ); " is 125.
Long Statement,SCJMapper_V2.SC,SCMappings,C:\repos\SCToolsfactory_SCJMapper-V2\SC\SCMappings.cs,IsValidMappingName,The length of the statement  "      retVal &= ( mapName.IndexOfAny( new char[] { ' '' '\t'' '\n'' '\r'' '\0' } ) < 0 ); // make sure we don't have spaces etc. " is 122.
Long Statement,SCJMapper_V2.Table,DS_ActionMaps,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "            this.relationT_ActionMap_T_Action = new global::System.Data.DataRelation("T_ActionMap_T_Action"' new global::System.Data.DataColumn[] { " is 135.
Long Statement,SCJMapper_V2.Table,DS_ActionMaps,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,GetTypedDataSetSchema,The length of the statement  "                    for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) { " is 131.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnID_Action = new global::System.Data.DataColumn("ID_Action"' typeof(string)' null' global::System.Data.MappingType.Element); " is 134.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnREF_ActionMap = new global::System.Data.DataColumn("REF_ActionMap"' typeof(string)' null' global::System.Data.MappingType.Element); " is 142.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnActionName = new global::System.Data.DataColumn("ActionName"' typeof(string)' null' global::System.Data.MappingType.Element); " is 136.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnDevice = new global::System.Data.DataColumn("Device"' typeof(string)' null' global::System.Data.MappingType.Element); " is 128.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnDef_Binding = new global::System.Data.DataColumn("Def_Binding"' typeof(string)' null' global::System.Data.MappingType.Element); " is 138.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnDef_Modifier = new global::System.Data.DataColumn("Def_Modifier"' typeof(string)' null' global::System.Data.MappingType.Element); " is 140.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnAddBind = new global::System.Data.DataColumn("AddBind"' typeof(bool)' null' global::System.Data.MappingType.Element); " is 128.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnUsr_Binding = new global::System.Data.DataColumn("Usr_Binding"' typeof(string)' null' global::System.Data.MappingType.Element); " is 138.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnUsr_Modifier = new global::System.Data.DataColumn("Usr_Modifier"' typeof(string)' null' global::System.Data.MappingType.Element); " is 140.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,InitClass,The length of the statement  "                this.columnDisabled = new global::System.Data.DataColumn("Disabled"' typeof(bool)' null' global::System.Data.MappingType.Element); " is 130.
Long Statement,SCJMapper_V2.Table,T_ActionDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.cs,GetTypedTableSchema,The length of the statement  "                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) { " is 131.
Long Statement,SCJMapper_V2.Table,T_ActionMapDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.Designer.cs,InitClass,The length of the statement  "                this.columnID_ActionMap = new global::System.Data.DataColumn("ID_ActionMap"' typeof(string)' null' global::System.Data.MappingType.Element); " is 140.
Long Statement,SCJMapper_V2.Table,T_ActionMapDataTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMaps.Designer.cs,GetTypedTableSchema,The length of the statement  "                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) { " is 131.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,ComposeFilter,The length of the statement  "      if ( ( chkJoystick.Checked == false ) && ( chkGamepad.Checked == false ) && ( chkMouse.Checked == false ) && ( chkKbd.Checked == false ) ) { " is 140.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,DGV_CurrentCellDirtyStateChanged,The length of the statement  "        DGV.Rows[DGV.CurrentCell.RowIndex].Cells[DGV.Columns["Disabled"].Index].Value = true; // toggle value - triggers the ValueChanged Event below " is 141.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormTable)); " is 129.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      dataGridViewCellStyle1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224))))); " is 137.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.DGV.CellMouseDoubleClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.DGV_CellMouseDoubleClick); " is 123.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.DGV.RowHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.DGV_RowHeaderMouseClick); " is 121.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Absolute' 300F)); " is 124.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.tableLayoutPanel2.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 100F)); " is 123.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.btCancelEdit.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 147.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.chkEditBlend.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 147.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.btUpdateFromEdit.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 151.
Long Statement,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The length of the statement  "      this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GetLastChange,The length of the statement  "          && ( Math.Abs( (Int32)m_state.Gamepad.LeftThumbX ) > Math.Abs( (Int32)m_state.Gamepad.LeftThumbY ) ) ) m_lastItem = "xi_thumblx+"; " is 130.
Long Statement,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GetLastChange,The length of the statement  "          && ( Math.Abs( (Int32)m_state.Gamepad.LeftThumbY ) > Math.Abs( (Int32)m_state.Gamepad.LeftThumbX ) ) ) m_lastItem = "xi_thumbly+"; " is 130.
Long Statement,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GetLastChange,The length of the statement  "          && ( Math.Abs( (Int32)m_state.Gamepad.RightThumbX ) > Math.Abs( (Int32)m_state.Gamepad.RightThumbY ) ) ) m_lastItem = "xi_thumbrx+"; " is 132.
Long Statement,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,GetLastChange,The length of the statement  "          && ( Math.Abs( (Int32)m_state.Gamepad.RightThumbY ) > Math.Abs( (Int32)m_state.Gamepad.RightThumbX ) ) ) m_lastItem = "xi_thumbry+"; " is 132.
Long Statement,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,btDone_Click,The length of the statement  "        MessageBox.Show( "the same jsN was assigned to more than one Joystick - either fix it or exit with Cancel"' "Accept Reassignment"' MessageBoxButtons.OK ); " is 154.
Long Statement,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The length of the statement  "      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormReassign)); " is 132.
Long Statement,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The length of the statement  "      this.groupBox1.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The length of the statement  "      this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 134.
Long Statement,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The length of the statement  "          if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse) " is 146.
Long Statement,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The length of the statement  "        if ( DidAxisChange2( (int)axisProperty.GetValue( this.m_state' null )' (int)axisProperty.GetValue( this.m_prevState' null ) ) ) " is 127.
Long Statement,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The length of the statement  "      this.lblJsAssignment.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 162.
Long Statement,SCJMapper_V2.Joystick,UICustHeader,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UICustHeader.cs,toXML,The length of the statement  "      r += string.Format( "\t<CustomisationUIHeader label=\"{0}\" description=\"{1}\" image=\"{2}\">\n"' m_label' m_description' m_image ); " is 133.
Long Statement,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,DXKeyboardCmd,The length of the statement  "            if ( ( ( int )k >= ( int )Key.Q ) && ( ( int )k <= ( int )Key.P ) ) key += k.ToString( ).ToLowerInvariant( ) + "+"; // ranges are based on the enum values... " is 157.
Long Statement,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,DXKeyboardCmd,The length of the statement  "            else if ( ( ( int )k >= ( int )Key.A ) && ( ( int )k <= ( int )Key.L ) ) key += k.ToString( ).ToLowerInvariant( ) + "+"; // ranges are based on the enum values... " is 162.
Long Statement,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,DXKeyboardCmd,The length of the statement  "            else if ( ( ( int )k >= ( int )Key.Z ) && ( ( int )k <= ( int )Key.M ) ) key += k.ToString( ).ToLowerInvariant( ) + "+"; // ranges are based on the enum values... " is 162.
Long Statement,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,DXKeyboardCmd,The length of the statement  "            else if ( ( ( int )k >= ( int )Key.F1 ) && ( ( int )k <= ( int )Key.F10 ) ) key += k.ToString( ).ToLowerInvariant( ) + "+"; // ranges are based on the enum values... " is 165.
Long Statement,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,DXKeyboardCmd,The length of the statement  "            else if ( ( ( int )k >= ( int )Key.F11 ) && ( ( int )k <= ( int )Key.F15 ) ) key += k.ToString( ).ToLowerInvariant( ) + "+"; // ranges are based on the enum values... " is 166.
Long Statement,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,GetLastChange,The length of the statement  "        if ( DidAxisChange2( ( int )axisProperty.GetValue( this.m_state' null )' ( int )axisProperty.GetValue( this.m_prevState' null )' true ) ) { " is 139.
Long Statement,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,GetLastChange,The length of the statement  "        else if ( DidAxisChange2( ( int )axisProperty.GetValue( this.m_state' null )' ( int )axisProperty.GetValue( this.m_prevState' null )' false ) ) { " is 145.
Long Statement,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,CalcCurve,The length of the statement  "          cout[segIdx].X = ( float )( m_points[i].X * B0[k] + ( m_points[i].X + d[i].X ) * B1[k] + ( m_points[i + 1].X - d[i + 1].X ) * B2[k] + m_points[i + 1].X * B3[k] ); " is 162.
Long Statement,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,CalcCurve,The length of the statement  "          cout[segIdx].Y = ( float )( m_points[i].Y * B0[k] + ( m_points[i].Y + d[i].Y ) * B1[k] + ( m_points[i + 1].Y - d[i + 1].Y ) * B2[k] + m_points[i + 1].Y * B3[k] ); " is 162.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,glControl1_Load,The length of the statement  "                log.ErrorFormat("glControl1_Load - This program requires OpenGL 2.0. Found {0}. Aborting."' GL.GetString(StringName.Version).Substring(0' 3)); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_YPR,The length of the statement  "                m.Y = m_livePitch.InvertedSign * ((!cbPuse.Checked) ? -fout : 0) * m_msElapsed * DegPerMS; // 20170801: fix - Must use inverted out value " is 137.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea(); " is 135.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series(); " is 126.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormJSCalCurve)); " is 134.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblYCmd.Font = new System.Drawing.Font("Segoe UI"' 6.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblYaw.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblPCmd.Font = new System.Drawing.Font("Segoe UI"' 6.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblPitch.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 143.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblRCmd.Font = new System.Drawing.Font("Segoe UI"' 6.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblRoll.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 153.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 58.79447F)); " is 128.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 41.20553F)); " is 128.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.panel9.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label6.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label16.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.panel6.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPtDeadzone.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblGraphSaturation.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 153.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblGraphDeadzone.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 151.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblNodetext.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label12.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label10.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblROutput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblRInput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblPOutput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblPInput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblLiveRoll.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 143.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblLivePitch.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblLiveYaw.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblYOutput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblYInput.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPtExponent.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPtSaturation.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 146.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPt3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPt2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbPt1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label33.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.label32.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblOut3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblIn3.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblOut2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblIn2.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblOut1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblIn1.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            chartArea1.AxisX.MajorTickMark.IntervalType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 122.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            chartArea1.AxisX.MinorTickMark.IntervalOffsetType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 128.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            chartArea1.AxisY.MajorTickMark.IntervalType = System.Windows.Forms.DataVisualization.Charting.DateTimeIntervalType.Number; " is 122.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0))))); " is 122.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblOutSlider.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 147.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.lblOutExponent.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 149.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.flowLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 151.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 156.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 68.66029F)); " is 128.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.tableLayoutPanel3.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent' 31.33971F)); " is 128.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.btDone.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 142.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.btDone.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbP.Font = new System.Drawing.Font("Segoe UI"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbY.Font = new System.Drawing.Font("Segoe UI"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbR.Font = new System.Drawing.Font("Segoe UI"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 138.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbTuneStrafe.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.rbTuneYPR.Font = new System.Drawing.Font("Segoe UI"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The length of the statement  "            this.Font = new System.Drawing.Font("Segoe UI"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 137.
Long Statement,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Load,The length of the statement  "                    string[] e = nodetext.Split(new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries); " is 138.
Long Statement,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Update,The length of the statement  "                pts.Add(nonLinCurve.Pt(0).X.ToString("0.000")); pts.Add(nonLinCurve.Pt(1).X.ToString("0.000")); pts.Add(nonLinCurve.Pt(2).X.ToString("0.000")); " is 143.
Long Statement,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Update,The length of the statement  "                pts.Add(nonLinCurve.Pt(0).Y.ToString("0.000")); pts.Add(nonLinCurve.Pt(1).Y.ToString("0.000")); pts.Add(nonLinCurve.Pt(2).Y.ToString("0.000")); " is 143.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool ..... " is 121.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                    throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." ); " is 142.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5 " is 160.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) ); " is 130.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) ); " is 130.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." ); " is 140.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width ); " is 126.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height ); " is 128.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat ); " is 144.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed ); " is 136.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height ); " is 207.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) ); " is 130.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) ); " is 177.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) ); " is 154.
Long Statement,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The length of the statement  "            return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] ); " is 122.
Long Statement,SCJMapper_V2.CryXMLlib,Conversions,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\Conversions.cs,ByteToType,The length of the statement  "      byte[] _bytes = bytes.SliceL( offset' ( UInt32 )Marshal.SizeOf( typeof( T ) ) ); // lets see if this works with Alloc below.. " is 125.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "      CryXMLHeader header = Conversions.ByteToType<CryXMLHeader>( fileContents ); // reads the header' mapping from binary to struct " is 126.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "      // map file content to binary.. here we really allocate arrays of elements and copy rather than the original which worked well with ptrs in c++ " is 143.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "        pData.pAttributes = ( CryXMLAttribute[] )Array.CreateInstance( typeof( CryXMLAttribute )' header.nAttributeCount ); // alloc enough " is 131.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "          pData.pAttributes[aIdx] = Conversions.ByteToType<CryXMLAttribute>( fileContents' header.nAttributeTablePosition + aIdx * incr ); " is 128.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "        pData.pChildIndices = ( CryXMLNodeIndex[] )Array.CreateInstance( typeof( CryXMLNodeIndex )' header.nChildCount ); // alloc enough " is 129.
Long Statement,SCJMapper_V2.CryXMLlib,CryXmlBinReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\CryXMLlib\CryXmlBinReader.cs,Create,The length of the statement  "          pData.pChildIndices[aIdx] = Conversions.ByteToType<CryXMLNodeIndex>( fileContents' header.nChildTablePosition + aIdx * incr ); " is 126.
Complex Conditional,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The conditional expression  "nodeText.ToLowerInvariant( ).EndsWith( "_x" ) || nodeText.ToLowerInvariant( ).EndsWith( "_rotx" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttlex" )            || nodeText.ToLowerInvariant( ).EndsWith( "_y" ) || nodeText.ToLowerInvariant( ).EndsWith( "_roty" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttley" )            || nodeText.ToLowerInvariant( ).EndsWith( "_Z" ) || nodeText.ToLowerInvariant( ).EndsWith( "_rotz" ) || nodeText.ToLowerInvariant( ).EndsWith( "_throttlez" )            || nodeText.ToLowerInvariant( ).EndsWith( "_slider1" ) || nodeText.ToLowerInvariant( ).EndsWith( "_slider2" )"  is complex.
Complex Conditional,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,UpdateOptionItem,The conditional expression  "nodeText.ToLowerInvariant( ).Contains( "_thumblx" ) || nodeText.ToLowerInvariant( ).Contains( "_thumbrx" )                 || nodeText.ToLowerInvariant( ).Contains( "_thumbly" ) || nodeText.ToLowerInvariant( ).Contains( "_thumbry" )"  is complex.
Complex Conditional,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,ComposeFilter,The conditional expression  "( chkJoystick.Checked == false ) && ( chkGamepad.Checked == false ) && ( chkMouse.Checked == false ) && ( chkKbd.Checked == false )"  is complex.
Complex Conditional,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The conditional expression  "idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )"  is complex.
Complex Conditional,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The conditional expression  "TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes"  is complex.
Complex Conditional,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The conditional expression  "GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0"  is complex.
Empty Catch Block,SCJMapper_V2,AppSettings,C:\repos\SCToolsfactory_SCJMapper-V2\AppSettings.cs,AppSettings,The method has an empty catch block.
Empty Catch Block,SCJMapper_V2,Program,C:\repos\SCToolsfactory_SCJMapper-V2\Program.cs,SetDefaultCulture,The method has an empty catch block.
Empty Catch Block,SCJMapper_V2,Program,C:\repos\SCToolsfactory_SCJMapper-V2\Program.cs,SetDefaultCulture,The method has an empty catch block.
Magic Number,SCJMapper_V2,ActionTreeNode,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTreeNode.cs,UpdateAction,The following statement contains a magic number: if ( String.IsNullOrEmpty( actionCmd.Input ) ) {          // new unmapped          this.Command = ""; this.BackColor = MyColors.UnassignedColor;          if ( this.Level == 2 ) this.Action = "UNDEF"; // apply UNDEF - 20160525 fix addbind not showing UNDEF if assigned        }        // blended mapped ones - can only get a Blend Background        else if ( actionCmd.Input == DeviceCls.BlendedInput ) {          this.Command = actionCmd.DevInput; this.BackColor = MyColors.BlendedColor;        }        else {          // mapped ( regular ones )          this.Command = actionCmd.DevInput;          //if ( this.Level == 2 ) this.Action = ""; // remove UNDEF - 20160525 fix addbind not showing UNDEF if assigned          // background is along the input           this.BackColor = ActionCls.DeviceColor( actionCmd.DevInput );        }
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,MainForm_Load,The following statement contains a magic number: rtb.SelectionTabs = new int[] { 10' 20' 30' 40' 50' 60 };
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,tc1_DrawItem,The following statement contains a magic number: try {          //This line of code will help you to change the apperance like size'name'style.          Font f;          //For background color          Brush backBrush = new SolidBrush( MyColors.TabColor[e.Index] );          //For forground color          Brush foreBrush = new SolidBrush( Color.Black );              //This construct will hell you to deside which tab page have current focus          //to change the style.          if ( e.Index == this.tc1.SelectedIndex ) {            //This line of code will help you to change the apperance like size'name'style.            f = new Font( e.Font' FontStyle.Bold | FontStyle.Bold );            f = new Font( e.Font' FontStyle.Bold );              Rectangle tabRect = tc1.Bounds;            Region tabRegion = new Region( tabRect );            Rectangle TabItemRect = new Rectangle( 0' 0' 0' 0 );            for ( int nTanIndex = 0; nTanIndex < tc1.TabCount; nTanIndex++ ) {              TabItemRect = Rectangle.Union( TabItemRect' tc1.GetTabRect( nTanIndex ) );            }            tabRegion.Exclude( TabItemRect );            e.Graphics.FillRegion( backBrush' tabRegion );          }          else {            f = e.Font;            foreBrush = new SolidBrush( e.ForeColor );          }            //To set the alignment of the caption.          string tabName = this.tc1.TabPages[e.Index].Text;          StringFormat sf = new StringFormat( );          sf.Alignment = StringAlignment.Center;            //Thsi will help you to fill the interior portion of          //selected tabpage.          e.Graphics.FillRectangle( backBrush' e.Bounds );          Rectangle r = e.Bounds;          r = new Rectangle( r.X' r.Y + 3' r.Width' r.Height - 3 );          e.Graphics.DrawString( tabName' f' foreBrush' r' sf );            sf.Dispose( );          if ( e.Index == this.tc1.SelectedIndex ) {            f.Dispose( );            backBrush.Dispose( );          }          else {            backBrush.Dispose( );            foreBrush.Dispose( );          }        } catch ( Exception Ex ) {          log.Error( "Ex DrawItem"' Ex );          MessageBox.Show( Ex.Message.ToString( )' "Error Occured"' MessageBoxButtons.OK' MessageBoxIcon.Information );        }
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,tc1_DrawItem,The following statement contains a magic number: try {          //This line of code will help you to change the apperance like size'name'style.          Font f;          //For background color          Brush backBrush = new SolidBrush( MyColors.TabColor[e.Index] );          //For forground color          Brush foreBrush = new SolidBrush( Color.Black );              //This construct will hell you to deside which tab page have current focus          //to change the style.          if ( e.Index == this.tc1.SelectedIndex ) {            //This line of code will help you to change the apperance like size'name'style.            f = new Font( e.Font' FontStyle.Bold | FontStyle.Bold );            f = new Font( e.Font' FontStyle.Bold );              Rectangle tabRect = tc1.Bounds;            Region tabRegion = new Region( tabRect );            Rectangle TabItemRect = new Rectangle( 0' 0' 0' 0 );            for ( int nTanIndex = 0; nTanIndex < tc1.TabCount; nTanIndex++ ) {              TabItemRect = Rectangle.Union( TabItemRect' tc1.GetTabRect( nTanIndex ) );            }            tabRegion.Exclude( TabItemRect );            e.Graphics.FillRegion( backBrush' tabRegion );          }          else {            f = e.Font;            foreBrush = new SolidBrush( e.ForeColor );          }            //To set the alignment of the caption.          string tabName = this.tc1.TabPages[e.Index].Text;          StringFormat sf = new StringFormat( );          sf.Alignment = StringAlignment.Center;            //Thsi will help you to fill the interior portion of          //selected tabpage.          e.Graphics.FillRectangle( backBrush' e.Bounds );          Rectangle r = e.Bounds;          r = new Rectangle( r.X' r.Y + 3' r.Width' r.Height - 3 );          e.Graphics.DrawString( tabName' f' foreBrush' r' sf );            sf.Dispose( );          if ( e.Index == this.tc1.SelectedIndex ) {            f.Dispose( );            backBrush.Dispose( );          }          else {            backBrush.Dispose( );            foreBrush.Dispose( );          }        } catch ( Exception Ex ) {          log.Error( "Ex DrawItem"' Ex );          MessageBox.Show( Ex.Message.ToString( )' "Error Occured"' MessageBoxButtons.OK' MessageBoxIcon.Information );        }
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,timer1_Tick,The following statement contains a magic number: if ( DeviceInst.JoystickRef == null ) {          // no active joystick - may be a gamepad          if ( DeviceInst.GamepadRef != null ) {            // poll Gamepad if active            DeviceInst.GamepadRef.GetData( );            ctrl = DeviceInst.GamepadRef.GetLastChange( );            timer1.Interval = 750; // allow more time to release buttons [msec]          }        }        else {          // poll active Joystick          DeviceInst.JoystickRef.GetData( );  // poll the device          // add keyboard modifier - if there are ..          if ( DeviceInst.KeyboardRef == null ) {            // no keyboard => no modifier             ctrl = JSStr( ) + DeviceInst.JoystickRef.GetLastChange( ); // show last handled JS control          }          else {            UpdateModifiers( );   // get the last keyboard modifer to compose the command' also handles the modifier lifetime            ctrl = JSStr( ) + m_persistentMods + DeviceInst.JoystickRef.GetLastChange( ); // show last handled JS control          }          timer1.Interval = 150; // standard polling [msec]        }
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,timer1_Tick,The following statement contains a magic number: if ( DeviceInst.JoystickRef == null ) {          // no active joystick - may be a gamepad          if ( DeviceInst.GamepadRef != null ) {            // poll Gamepad if active            DeviceInst.GamepadRef.GetData( );            ctrl = DeviceInst.GamepadRef.GetLastChange( );            timer1.Interval = 750; // allow more time to release buttons [msec]          }        }        else {          // poll active Joystick          DeviceInst.JoystickRef.GetData( );  // poll the device          // add keyboard modifier - if there are ..          if ( DeviceInst.KeyboardRef == null ) {            // no keyboard => no modifier             ctrl = JSStr( ) + DeviceInst.JoystickRef.GetLastChange( ); // show last handled JS control          }          else {            UpdateModifiers( );   // get the last keyboard modifer to compose the command' also handles the modifier lifetime            ctrl = JSStr( ) + m_persistentMods + DeviceInst.JoystickRef.GetLastChange( ); // show last handled JS control          }          timer1.Interval = 150; // standard polling [msec]        }
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpList.Location = new System.Drawing.Point(3' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpList.Location = new System.Drawing.Point(3' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpList.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpList.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpList.TabIndex = 24;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.rtb.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.rtb.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.rtb.Size = new System.Drawing.Size(348' 654);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.rtb.Size = new System.Drawing.Size(348' 654);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.rtb.TabIndex = 21;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmCopyPaste.Size = new System.Drawing.Size(170' 142);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmCopyPaste.Size = new System.Drawing.Size(170' 142);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiCopy.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiCopy.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiPaste.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiPaste.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiPReplace.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiPReplace.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiSelAll.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiSelAll.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(166' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(166' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiOpen.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiOpen.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiSaveAs.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsiSaveAs.Size = new System.Drawing.Size(169' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btGrab.Location = new System.Drawing.Point(181' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btGrab.Location = new System.Drawing.Point(181' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btGrab.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btGrab.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btGrab.TabIndex = 19;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDump.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDump.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDump.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDump.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDump.TabIndex = 20;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(3' 379);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(3' 379);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(298' 167);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(298' 167);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel2.TabIndex = 17;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(4' 41);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(4' 41);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 18;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAssigned.Location = new System.Drawing.Point(64' 40);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAssigned.Location = new System.Drawing.Point(64' 40);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAssigned.Size = new System.Drawing.Size(224' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAssigned.Size = new System.Drawing.Size(224' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAssigned.TabIndex = 17;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsKbd.Location = new System.Drawing.Point(107' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsKbd.Location = new System.Drawing.Point(107' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsKbd.Size = new System.Drawing.Size(79' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsKbd.Size = new System.Drawing.Size(79' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsKbd.TabIndex = 16;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(2' "J");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(3' "K");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(4' "M");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(5' "X");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(6' "P");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(7' "Z");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.IL.Images.SetKeyName(8' "Add");
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btBlend.Location = new System.Drawing.Point(9' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btBlend.Location = new System.Drawing.Point(9' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btBlend.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btBlend.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btBlend.TabIndex = 16;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblLastJ.Location = new System.Drawing.Point(64' 74);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblLastJ.Location = new System.Drawing.Point(64' 74);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblLastJ.Size = new System.Drawing.Size(224' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblLastJ.Size = new System.Drawing.Size(224' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblLastJ.TabIndex = 14;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmMouseEntry.Size = new System.Drawing.Size(172' 132);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmMouseEntry.Size = new System.Drawing.Size(172' 132);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeK_Tab.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeK_Tab.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator7.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator7.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeXAxis.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeXAxis.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeYAxis.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeYAxis.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeWUp.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeWUp.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeWDown.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tmeWDown.Size = new System.Drawing.Size(171' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator4.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator4.Size = new System.Drawing.Size(168' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxThrottle.Location = new System.Drawing.Point(89' 108);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxThrottle.Location = new System.Drawing.Point(89' 108);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxThrottle.Size = new System.Drawing.Size(66' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxThrottle.Size = new System.Drawing.Size(66' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxThrottle.TabIndex = 13;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btFind.Location = new System.Drawing.Point(215' 103);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btFind.Location = new System.Drawing.Point(215' 103);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btFind.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btFind.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btFind.TabIndex = 12;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(4' 77);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(4' 77);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(50' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(50' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(4' 18);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(4' 18);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(50' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(50' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClear.Location = new System.Drawing.Point(215' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClear.Location = new System.Drawing.Point(215' 134);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClear.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClear.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClear.TabIndex = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAction.Location = new System.Drawing.Point(64' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAction.Location = new System.Drawing.Point(64' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAction.Size = new System.Drawing.Size(224' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblAction.Size = new System.Drawing.Size(224' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btAssign.Location = new System.Drawing.Point(9' 103);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btAssign.Location = new System.Drawing.Point(9' 103);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btAssign.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btAssign.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btAssign.TabIndex = 15;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btMakeMod.Location = new System.Drawing.Point(155' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btMakeMod.Location = new System.Drawing.Point(155' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btMakeMod.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btMakeMod.Size = new System.Drawing.Size(73' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btMakeMod.TabIndex = 17;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.treeView1.Location = new System.Drawing.Point(6' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.treeView1.Location = new System.Drawing.Point(6' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.SetRowSpan(this.treeView1' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.treeView1.Size = new System.Drawing.Size(364' 686);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.treeView1.Size = new System.Drawing.Size(364' 686);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.treeView1.TabIndex = 16;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmAddDel.Size = new System.Drawing.Size(221' 457);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cmAddDel.Size = new System.Drawing.Size(221' 457);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCollapseAll.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCollapseAll.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiExpandAll.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiExpandAll.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup1.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup1.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAssignBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAssignBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiBlendBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiBlendBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiClearBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiClearBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup2.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup2.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiDelBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiDelBinding.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup3.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup3.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiTxDefActivationMode.Size = new System.Drawing.Size(160' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiTxDefActivationMode.Size = new System.Drawing.Size(160' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCbxActivation.DropDownHeight = 140;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCbxActivation.DropDownWidth = 160;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCbxActivation.MaxDropDownItems = 10;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCbxActivation.Size = new System.Drawing.Size(160' 180);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiCbxActivation.Size = new System.Drawing.Size(160' 180);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup4.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiSGroup4.Size = new System.Drawing.Size(217' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod1.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod1.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod2.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod2.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod3.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tdiAddMod3.Size = new System.Drawing.Size(220' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.ItemSize = new System.Drawing.Size(62' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.ItemSize = new System.Drawing.Size(62' 20);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.Size = new System.Drawing.Size(298' 370);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.Size = new System.Drawing.Size(298' 370);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tc1.TabIndex = 15;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tabJS1.Location = new System.Drawing.Point(4' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tabJS1.Location = new System.Drawing.Point(4' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tabJS1.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tabJS1.Size = new System.Drawing.Size(290' 342);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tabJS1.Size = new System.Drawing.Size(290' 342);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.UC_JoyPanel.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.UC_JoyPanel.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.UC_JoyPanel.Size = new System.Drawing.Size(284' 336);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.UC_JoyPanel.Size = new System.Drawing.Size(284' 336);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.SetColumnSpan(this.panel1' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(6' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(6' 6);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(1042' 66);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(1042' 66);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.panel1.TabIndex = 14;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClip.Location = new System.Drawing.Point(984' 8);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClip.Location = new System.Drawing.Point(984' 8);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClip.Size = new System.Drawing.Size(52' 55);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClip.Size = new System.Drawing.Size(52' 55);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClip.TabIndex = 55;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txRebind.Location = new System.Drawing.Point(603' 39);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txRebind.Location = new System.Drawing.Point(603' 39);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txRebind.Size = new System.Drawing.Size(361' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txRebind.Size = new System.Drawing.Size(361' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txRebind.TabIndex = 4;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.linkLblReleases.Location = new System.Drawing.Point(672' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.linkLblReleases.Location = new System.Drawing.Point(672' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.linkLblReleases.Size = new System.Drawing.Size(259' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.linkLblReleases.Size = new System.Drawing.Size(259' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.linkLblReleases.TabIndex = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(353' 42);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(353' 42);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(58' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(58' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(226' 8);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Location = new System.Drawing.Point(226' 8);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(185' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblTitle.Size = new System.Drawing.Size(185' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(220' 66);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(220' 66);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonExit.Location = new System.Drawing.Point(181' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonExit.Location = new System.Drawing.Point(181' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonExit.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonExit.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.buttonExit.TabIndex = 13;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.timer1.Interval = 150;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.ColumnCount = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tableLayoutPanel1' 1' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tableLayoutPanel2' 1' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tableLayoutPanel3' 2' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tableLayoutPanel3' 2' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tableLayoutPanel5' 0' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Controls.Add(this.tcXML' 2' 1);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.RowCount = 5;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Size = new System.Drawing.Size(1054' 892);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.Size = new System.Drawing.Size(1054' 892);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.TabIndex = 25;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.btOptions' 1' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.btDumpLog' 0' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.btJSTuning' 1' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.btDumpProfile' 0' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(376' 648);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(376' 648);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 4;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(304' 119);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(304' 119);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.TabIndex = 23;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btOptions.Location = new System.Drawing.Point(181' 63);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btOptions.Location = new System.Drawing.Point(181' 63);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btOptions.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btOptions.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btOptions.TabIndex = 28;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpLog.Location = new System.Drawing.Point(3' 63);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpLog.Location = new System.Drawing.Point(3' 63);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpLog.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpLog.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpLog.TabIndex = 25;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJSTuning.Location = new System.Drawing.Point(181' 93);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJSTuning.Location = new System.Drawing.Point(181' 93);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJSTuning.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJSTuning.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJSTuning.TabIndex = 17;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpProfile.Location = new System.Drawing.Point(3' 93);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpProfile.Location = new System.Drawing.Point(3' 93);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpProfile.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpProfile.Size = new System.Drawing.Size(120' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btDumpProfile.TabIndex = 26;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btTable.Location = new System.Drawing.Point(181' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btTable.Location = new System.Drawing.Point(181' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btTable.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btTable.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btTable.TabIndex = 27;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.ColumnCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point(376' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point(376' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.RowCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size(304' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size(304' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.TabIndex = 24;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSettings.Location = new System.Drawing.Point(3' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSettings.Location = new System.Drawing.Point(3' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSettings.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSettings.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSettings.TabIndex = 14;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsReassign.Location = new System.Drawing.Point(3' 21);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsReassign.Location = new System.Drawing.Point(3' 21);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsReassign.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsReassign.Size = new System.Drawing.Size(120' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btJsReassign.TabIndex = 16;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.ColumnCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Location = new System.Drawing.Point(686' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Location = new System.Drawing.Point(686' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.RowCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Size = new System.Drawing.Size(362' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Size = new System.Drawing.Size(362' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.TabIndex = 25;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSaveMyMapping.Location = new System.Drawing.Point(154' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSaveMyMapping.Location = new System.Drawing.Point(154' 51);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSaveMyMapping.Size = new System.Drawing.Size(205' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSaveMyMapping.Size = new System.Drawing.Size(205' 24);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btSaveMyMapping.TabIndex = 15;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txMappingName.Location = new System.Drawing.Point(125' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txMappingName.Location = new System.Drawing.Point(125' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txMappingName.Size = new System.Drawing.Size(234' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txMappingName.Size = new System.Drawing.Size(234' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(31' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(31' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(88' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(88' 13);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 16;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPTU.Location = new System.Drawing.Point(3' 48);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPTU.Location = new System.Drawing.Point(3' 48);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPTU.Size = new System.Drawing.Size(116' 30);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPTU.Size = new System.Drawing.Size(116' 30);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblPTU.TabIndex = 17;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.Location = new System.Drawing.Point(376' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.Location = new System.Drawing.Point(376' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.RowCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.Size = new System.Drawing.Size(304' 549);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.Size = new System.Drawing.Size(304' 549);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel4.TabIndex = 28;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.ColumnCount = 5;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.lblProfileUsed' 1' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.label3' 0' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.btClearFilter' 4' 1);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.cbxShowMappedOnly' 4' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.cbxShowMouse' 3' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.cbxShowKeyboard' 2' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Controls.Add(this.txFilter' 2' 1);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Location = new System.Drawing.Point(6' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Location = new System.Drawing.Point(6' 773);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.RowCount = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Size = new System.Drawing.Size(364' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.Size = new System.Drawing.Size(364' 78);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.TabIndex = 29;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.SetColumnSpan(this.lblProfileUsed' 4);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.Location = new System.Drawing.Point(75' 61);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.Location = new System.Drawing.Point(75' 61);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.Margin = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.Size = new System.Drawing.Size(286' 14);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.Size = new System.Drawing.Size(286' 14);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lblProfileUsed.TabIndex = 29;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(3' 61);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(3' 61);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.Margin = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(39' 14);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(39' 14);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 30;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClearFilter.Location = new System.Drawing.Point(291' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClearFilter.Location = new System.Drawing.Point(291' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClearFilter.Size = new System.Drawing.Size(70' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClearFilter.Size = new System.Drawing.Size(70' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.btClearFilter.TabIndex = 26;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.SetColumnSpan(this.label2' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.Margin = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(83' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(83' 23);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 27;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMappedOnly.Location = new System.Drawing.Point(291' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMappedOnly.Location = new System.Drawing.Point(291' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMappedOnly.Size = new System.Drawing.Size(69' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMappedOnly.Size = new System.Drawing.Size(69' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMouse.Location = new System.Drawing.Point(219' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMouse.Location = new System.Drawing.Point(219' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMouse.Size = new System.Drawing.Size(61' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMouse.Size = new System.Drawing.Size(61' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowMouse.TabIndex = 28;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowKeyboard.Location = new System.Drawing.Point(147' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowKeyboard.Location = new System.Drawing.Point(147' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowKeyboard.Size = new System.Drawing.Size(53' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowKeyboard.Size = new System.Drawing.Size(53' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowJoystick.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowJoystick.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowJoystick.Size = new System.Drawing.Size(65' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowJoystick.Size = new System.Drawing.Size(65' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowGamepad.Location = new System.Drawing.Point(75' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowGamepad.Location = new System.Drawing.Point(75' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowGamepad.Size = new System.Drawing.Size(66' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxShowGamepad.Size = new System.Drawing.Size(66' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel5.SetColumnSpan(this.txFilter' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txFilter.Location = new System.Drawing.Point(147' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txFilter.Location = new System.Drawing.Point(147' 32);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txFilter.Size = new System.Drawing.Size(138' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txFilter.Size = new System.Drawing.Size(138' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.txFilter.TabIndex = 25;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tcXML.Location = new System.Drawing.Point(686' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tcXML.Location = new System.Drawing.Point(686' 81);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tlpanel.SetRowSpan(this.tcXML' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tcXML.Size = new System.Drawing.Size(362' 686);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tcXML.Size = new System.Drawing.Size(362' 686);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tcXML.TabIndex = 30;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageDump.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageDump.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageDump.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageDump.Size = new System.Drawing.Size(354' 660);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageDump.Size = new System.Drawing.Size(354' 660);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageOther.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageOther.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageOther.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageOther.Size = new System.Drawing.Size(354' 660);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tPageOther.Size = new System.Drawing.Size(354' 660);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel6.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel6.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel6.RowCount = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel6.Size = new System.Drawing.Size(348' 654);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel6.Size = new System.Drawing.Size(348' 654);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Size = new System.Drawing.Size(233' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Size = new System.Drawing.Size(233' 17);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.TabIndex = 2;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel2.Size = new System.Drawing.Size(52' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel2.Size = new System.Drawing.Size(52' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtReset.Size = new System.Drawing.Size(100' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtReset.Size = new System.Drawing.Size(100' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetDefaultsToolStripMenuItem.Size = new System.Drawing.Size(153' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetDefaultsToolStripMenuItem.Size = new System.Drawing.Size(153' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetEmptyToolStripMenuItem.Size = new System.Drawing.Size(153' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetEmptyToolStripMenuItem.Size = new System.Drawing.Size(153' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Margin = new System.Windows.Forms.Padding(5' 3' 5' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Margin = new System.Windows.Forms.Padding(5' 3' 5' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Margin = new System.Windows.Forms.Padding(5' 3' 5' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Margin = new System.Windows.Forms.Padding(5' 3' 5' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Size = new System.Drawing.Size(450' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel3.Size = new System.Drawing.Size(450' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Margin = new System.Windows.Forms.Padding(5' 3' 0' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Margin = new System.Windows.Forms.Padding(5' 3' 0' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Margin = new System.Windows.Forms.Padding(5' 3' 0' 2);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(63' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(63' 25);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsDDbtMappings.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsDDbtMappings.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsDDbtMappings.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsDDbtMappings.Size = new System.Drawing.Size(220' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsDDbtMappings.Size = new System.Drawing.Size(220' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtLoad.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtLoad.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtLoad.Margin = new System.Windows.Forms.Padding(5' 2' 5' 0);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtLoad.Size = new System.Drawing.Size(100' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.tsBtLoad.Size = new System.Drawing.Size(100' 28);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.defaultsLoadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.defaultsLoadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetLoadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.resetLoadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.loadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.loadAndGrabToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.loadToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.loadToolStripMenuItem.Size = new System.Drawing.Size(206' 22);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 862);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(1054' 30);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(1054' 30);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.TabIndex = 26;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lbxOther.Location = new System.Drawing.Point(3' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lbxOther.Location = new System.Drawing.Point(3' 33);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lbxOther.Size = new System.Drawing.Size(342' 618);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lbxOther.Size = new System.Drawing.Size(342' 618);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.lbxOther.TabIndex = 3;
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1054' 892);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1054' 892);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(1070' 930);
Magic Number,SCJMapper_V2,MainForm,C:\repos\SCToolsfactory_SCJMapper-V2\FormMain.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(1070' 930);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(658' 423);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(658' 423);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(93' 31);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(93' 31);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txSCPath.Location = new System.Drawing.Point(27' 24);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txSCPath.Location = new System.Drawing.Point(27' 24);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txSCPath.Size = new System.Drawing.Size(479' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txSCPath.Size = new System.Drawing.Size(479' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btChooseSCDir.Location = new System.Drawing.Point(512' 24);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btChooseSCDir.Location = new System.Drawing.Point(512' 24);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btChooseSCDir.Size = new System.Drawing.Size(33' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btChooseSCDir.Size = new System.Drawing.Size(33' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btChooseSCDir.TabIndex = 4;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxUsePath.Location = new System.Drawing.Point(6' 27);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxUsePath.Location = new System.Drawing.Point(6' 27);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxUsePath.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxUsePath.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxUsePath.TabIndex = 5;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Location = new System.Drawing.Point(66' 46);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Location = new System.Drawing.Point(66' 46);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.TabIndex = 6;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 49);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 49);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 7;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 77);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 77);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 9;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Location = new System.Drawing.Point(66' 74);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Location = new System.Drawing.Point(66' 74);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.TabIndex = 8;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 11;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Location = new System.Drawing.Point(66' 102);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Location = new System.Drawing.Point(66' 102);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.TabIndex = 10;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 133);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 133);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 13;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Location = new System.Drawing.Point(66' 130);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Location = new System.Drawing.Point(66' 130);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.TabIndex = 12;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 161);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 161);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 15;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Location = new System.Drawing.Point(66' 158);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Location = new System.Drawing.Point(66' 158);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.TabIndex = 14;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 189);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(6' 189);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 17;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Location = new System.Drawing.Point(66' 186);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Location = new System.Drawing.Point(66' 186);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.TabIndex = 16;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(271' 49);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(271' 49);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 19;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Location = new System.Drawing.Point(340' 46);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Location = new System.Drawing.Point(340' 46);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.TabIndex = 18;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(271' 77);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(271' 77);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 21;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Location = new System.Drawing.Point(340' 74);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Location = new System.Drawing.Point(340' 74);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.TabIndex = 20;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(561' 226);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(561' 226);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 22;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Location = new System.Drawing.Point(340' 158);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Location = new System.Drawing.Point(340' 158);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.TabIndex = 26;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(271' 189);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(271' 189);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 29;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Location = new System.Drawing.Point(340' 186);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Location = new System.Drawing.Point(340' 186);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.TabIndex = 28;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(271' 161);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(271' 161);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 27;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(271' 133);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(271' 133);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 25;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Location = new System.Drawing.Point(340' 130);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Location = new System.Drawing.Point(340' 130);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.TabIndex = 24;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(271' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(271' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label13.TabIndex = 23;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Location = new System.Drawing.Point(340' 102);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Location = new System.Drawing.Point(340' 102);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Size = new System.Drawing.Size(199' 22);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.TabIndex = 22;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(15' 244);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(15' 244);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(561' 59);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(561' 59);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.TabIndex = 23;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(579' 12);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(579' 12);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(274' 405);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(274' 405);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.TabIndex = 24;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkLbActionMaps.Location = new System.Drawing.Point(3' 18);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkLbActionMaps.Location = new System.Drawing.Point(3' 18);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkLbActionMaps.Size = new System.Drawing.Size(268' 384);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.chkLbActionMaps.Size = new System.Drawing.Size(268' 384);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Location = new System.Drawing.Point(757' 423);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Location = new System.Drawing.Point(757' 423);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Size = new System.Drawing.Size(93' 31);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Size = new System.Drawing.Size(93' 31);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.TabIndex = 25;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 426);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 426);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(401' 26);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(401' 26);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 26;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Location = new System.Drawing.Point(15' 309);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Location = new System.Drawing.Point(15' 309);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Size = new System.Drawing.Size(561' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.Size = new System.Drawing.Size(561' 105);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.groupBox4.TabIndex = 27;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Location = new System.Drawing.Point(9' 44);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Location = new System.Drawing.Point(9' 44);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Size = new System.Drawing.Size(233' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.Size = new System.Drawing.Size(233' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxAutoTabXML.TabIndex = 10;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxListModifiers.Location = new System.Drawing.Point(420' 44);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxListModifiers.Location = new System.Drawing.Point(420' 44);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxListModifiers.Size = new System.Drawing.Size(97' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxListModifiers.Size = new System.Drawing.Size(97' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxListModifiers.TabIndex = 9;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxCSVListing.Location = new System.Drawing.Point(400' 21);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxCSVListing.Location = new System.Drawing.Point(400' 21);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxCSVListing.Size = new System.Drawing.Size(106' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxCSVListing.Size = new System.Drawing.Size(106' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxCSVListing.TabIndex = 8;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxPTU.Location = new System.Drawing.Point(9' 67);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxPTU.Location = new System.Drawing.Point(9' 67);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxPTU.Size = new System.Drawing.Size(108' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxPTU.Size = new System.Drawing.Size(108' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxPTU.TabIndex = 7;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxDetectGamepad.Location = new System.Drawing.Point(9' 21);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxDetectGamepad.Location = new System.Drawing.Point(9' 21);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxDetectGamepad.Size = new System.Drawing.Size(98' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxDetectGamepad.Size = new System.Drawing.Size(98' 17);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.cbxDetectGamepad.TabIndex = 6;
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(861' 467);
Magic Number,SCJMapper_V2,FormSettings,C:\repos\SCToolsfactory_SCJMapper-V2\FormSettings.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(861' 467);
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,DelBinding,The following statement contains a magic number: if ( Ctrl.SelectedNode.Level != 2 ) return;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindMasterAction,The following statement contains a magic number: if ( atn.Level != 2 ) return null;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The following statement contains a magic number: using ( TextReader sr = txReader ) {          string buf = sr.ReadLine( );          while ( !string.IsNullOrEmpty( buf ) ) {            string[] elem = buf.Split( new char[] { ';'' ''' }' StringSplitOptions.None );            if ( elem.Length > 1 ) {              if ( !IgnoreMaps.Contains( "'" + elem[0] + "'" ) ) {                // must have 2 elements min                Array.Resize( ref cnl' 0 );                acm = new ActionMapCls( ); acm.name = elem[0]; // get actionmap name                // process items                for ( int ei = 1; ei < elem.Length; ei += 4 ) { // step 2  - action;defaultBinding;defaultActivationMode;defMultiTap come in as quadrupples                  if ( !string.IsNullOrEmpty( elem[ei] ) ) {                    // default assignments                    string action = elem[ei].Substring( 1 );                    string defBinding = elem[ei + 1];                    string defActivationModeName = elem[ei + 2];                    int defMultiTap = int.Parse( elem[ei + 3] );                    // need to create a ActivationMode here                    ActivationMode defActivationMode = new ActivationMode( defActivationModeName' defMultiTap );                      string devID = elem[ei].Substring( 0' 1 );                    string device = ActionCls.DeviceClassFromTag( devID );                      // visual item for the action                    cn = new ActionTreeNode( "UNDEF" ); cn.Name = elem[ei]; cn.Action = action; cn.BackColor = Color.White;  // name with the key it to find it..                                    cn.ImageKey = devID; cn.BackColor = Color.White; // some stuff does not work properly...                    if ( ActivationMode.IsDefault( defActivationModeName ) ) {                      cn.NodeFont = FontAction;                    }                    else {                      cn.NodeFont = FontActionActivated;                    }                    Array.Resize( ref cnl' cnl.Length + 1 ); cnl[cnl.Length - 1] = cn;                      // derive content tree                    ac = new ActionCls( ); ac.key = cn.Name; ac.name = action; ac.device = device; ac.actionDevice = ActionCls.ADevice( device );                    ac.defBinding = defBinding; ac.defActivationMode = defActivationMode;                    acm.Add( ac ); // add to our map                    cn.ActionDevice = ac.actionDevice; // should be known now                    // create just an unmapped ActionCommand item                     acc = ac.AddCommand( ""' -1 ); // profile items are shown in the ActionTreeNode (not in a child)                      // init and apply the default mappings if requested                    if ( ac.actionDevice == ActionCls.ActionDevice.AD_Joystick ) {                      acc.DevID = JoystickCls.DeviceID;                      int jNum = JoystickCls.JSNum( ac.defBinding );                      if ( applyDefaults ) {                        if ( JoystickCls.IsJSValid( jNum ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = JoystickCls.JsNColor( jNum );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Gamepad ) {                      acc.DevID = GamepadCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = GamepadCls.XiColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Keyboard ) {                      acc.DevID = KeyboardCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = KeyboardCls.KbdColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Mouse ) {  // 20151220BM: add mouse device (from AC 2.0 defaultProfile usage)                      acc.DevID = MouseCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = MouseCls.MouseColor( );                        }                      }                    }                  }                }//for                  tn = new ActionTreeNode( acm.name' cnl ); tn.Name = acm.name; tn.Action = acm.name; // name it to find it..                tn.ImageIndex = 0; tn.NodeFont = FontActionmap; // new Font( m_MasterTree.Font' FontStyle.Bold );                m_MasterTree.BackColor = Color.White; // fix for defect TreeView (cut off bold text)                m_MasterTree.Nodes.Add( tn ); // add to control                if ( topNode == null ) topNode = tn; // once to keep the start of list                ActionMaps.Add( acm ); // add to our map              }//not ignored              }// if valid line            buf = sr.ReadLine( );          }//while        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The following statement contains a magic number: using ( TextReader sr = txReader ) {          string buf = sr.ReadLine( );          while ( !string.IsNullOrEmpty( buf ) ) {            string[] elem = buf.Split( new char[] { ';'' ''' }' StringSplitOptions.None );            if ( elem.Length > 1 ) {              if ( !IgnoreMaps.Contains( "'" + elem[0] + "'" ) ) {                // must have 2 elements min                Array.Resize( ref cnl' 0 );                acm = new ActionMapCls( ); acm.name = elem[0]; // get actionmap name                // process items                for ( int ei = 1; ei < elem.Length; ei += 4 ) { // step 2  - action;defaultBinding;defaultActivationMode;defMultiTap come in as quadrupples                  if ( !string.IsNullOrEmpty( elem[ei] ) ) {                    // default assignments                    string action = elem[ei].Substring( 1 );                    string defBinding = elem[ei + 1];                    string defActivationModeName = elem[ei + 2];                    int defMultiTap = int.Parse( elem[ei + 3] );                    // need to create a ActivationMode here                    ActivationMode defActivationMode = new ActivationMode( defActivationModeName' defMultiTap );                      string devID = elem[ei].Substring( 0' 1 );                    string device = ActionCls.DeviceClassFromTag( devID );                      // visual item for the action                    cn = new ActionTreeNode( "UNDEF" ); cn.Name = elem[ei]; cn.Action = action; cn.BackColor = Color.White;  // name with the key it to find it..                                    cn.ImageKey = devID; cn.BackColor = Color.White; // some stuff does not work properly...                    if ( ActivationMode.IsDefault( defActivationModeName ) ) {                      cn.NodeFont = FontAction;                    }                    else {                      cn.NodeFont = FontActionActivated;                    }                    Array.Resize( ref cnl' cnl.Length + 1 ); cnl[cnl.Length - 1] = cn;                      // derive content tree                    ac = new ActionCls( ); ac.key = cn.Name; ac.name = action; ac.device = device; ac.actionDevice = ActionCls.ADevice( device );                    ac.defBinding = defBinding; ac.defActivationMode = defActivationMode;                    acm.Add( ac ); // add to our map                    cn.ActionDevice = ac.actionDevice; // should be known now                    // create just an unmapped ActionCommand item                     acc = ac.AddCommand( ""' -1 ); // profile items are shown in the ActionTreeNode (not in a child)                      // init and apply the default mappings if requested                    if ( ac.actionDevice == ActionCls.ActionDevice.AD_Joystick ) {                      acc.DevID = JoystickCls.DeviceID;                      int jNum = JoystickCls.JSNum( ac.defBinding );                      if ( applyDefaults ) {                        if ( JoystickCls.IsJSValid( jNum ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = JoystickCls.JsNColor( jNum );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Gamepad ) {                      acc.DevID = GamepadCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = GamepadCls.XiColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Keyboard ) {                      acc.DevID = KeyboardCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = KeyboardCls.KbdColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Mouse ) {  // 20151220BM: add mouse device (from AC 2.0 defaultProfile usage)                      acc.DevID = MouseCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = MouseCls.MouseColor( );                        }                      }                    }                  }                }//for                  tn = new ActionTreeNode( acm.name' cnl ); tn.Name = acm.name; tn.Action = acm.name; // name it to find it..                tn.ImageIndex = 0; tn.NodeFont = FontActionmap; // new Font( m_MasterTree.Font' FontStyle.Bold );                m_MasterTree.BackColor = Color.White; // fix for defect TreeView (cut off bold text)                m_MasterTree.Nodes.Add( tn ); // add to control                if ( topNode == null ) topNode = tn; // once to keep the start of list                ActionMaps.Add( acm ); // add to our map              }//not ignored              }// if valid line            buf = sr.ReadLine( );          }//while        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,LoadProfileTree,The following statement contains a magic number: using ( TextReader sr = txReader ) {          string buf = sr.ReadLine( );          while ( !string.IsNullOrEmpty( buf ) ) {            string[] elem = buf.Split( new char[] { ';'' ''' }' StringSplitOptions.None );            if ( elem.Length > 1 ) {              if ( !IgnoreMaps.Contains( "'" + elem[0] + "'" ) ) {                // must have 2 elements min                Array.Resize( ref cnl' 0 );                acm = new ActionMapCls( ); acm.name = elem[0]; // get actionmap name                // process items                for ( int ei = 1; ei < elem.Length; ei += 4 ) { // step 2  - action;defaultBinding;defaultActivationMode;defMultiTap come in as quadrupples                  if ( !string.IsNullOrEmpty( elem[ei] ) ) {                    // default assignments                    string action = elem[ei].Substring( 1 );                    string defBinding = elem[ei + 1];                    string defActivationModeName = elem[ei + 2];                    int defMultiTap = int.Parse( elem[ei + 3] );                    // need to create a ActivationMode here                    ActivationMode defActivationMode = new ActivationMode( defActivationModeName' defMultiTap );                      string devID = elem[ei].Substring( 0' 1 );                    string device = ActionCls.DeviceClassFromTag( devID );                      // visual item for the action                    cn = new ActionTreeNode( "UNDEF" ); cn.Name = elem[ei]; cn.Action = action; cn.BackColor = Color.White;  // name with the key it to find it..                                    cn.ImageKey = devID; cn.BackColor = Color.White; // some stuff does not work properly...                    if ( ActivationMode.IsDefault( defActivationModeName ) ) {                      cn.NodeFont = FontAction;                    }                    else {                      cn.NodeFont = FontActionActivated;                    }                    Array.Resize( ref cnl' cnl.Length + 1 ); cnl[cnl.Length - 1] = cn;                      // derive content tree                    ac = new ActionCls( ); ac.key = cn.Name; ac.name = action; ac.device = device; ac.actionDevice = ActionCls.ADevice( device );                    ac.defBinding = defBinding; ac.defActivationMode = defActivationMode;                    acm.Add( ac ); // add to our map                    cn.ActionDevice = ac.actionDevice; // should be known now                    // create just an unmapped ActionCommand item                     acc = ac.AddCommand( ""' -1 ); // profile items are shown in the ActionTreeNode (not in a child)                      // init and apply the default mappings if requested                    if ( ac.actionDevice == ActionCls.ActionDevice.AD_Joystick ) {                      acc.DevID = JoystickCls.DeviceID;                      int jNum = JoystickCls.JSNum( ac.defBinding );                      if ( applyDefaults ) {                        if ( JoystickCls.IsJSValid( jNum ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = JoystickCls.JsNColor( jNum );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Gamepad ) {                      acc.DevID = GamepadCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = GamepadCls.XiColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Keyboard ) {                      acc.DevID = KeyboardCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = KeyboardCls.KbdColor( );                        }                      }                    }                    else if ( ac.actionDevice == ActionCls.ActionDevice.AD_Mouse ) {  // 20151220BM: add mouse device (from AC 2.0 defaultProfile usage)                      acc.DevID = MouseCls.DeviceID;                      if ( applyDefaults ) {                        if ( !string.IsNullOrEmpty( ac.defBinding ) ) {                          acc.DevInput = ac.defBinding;                          cn.Command = ac.defBinding; cn.BackColor = MouseCls.MouseColor( );                        }                      }                    }                  }                }//for                  tn = new ActionTreeNode( acm.name' cnl ); tn.Name = acm.name; tn.Action = acm.name; // name it to find it..                tn.ImageIndex = 0; tn.NodeFont = FontActionmap; // new Font( m_MasterTree.Font' FontStyle.Bold );                m_MasterTree.BackColor = Color.White; // fix for defect TreeView (cut off bold text)                m_MasterTree.Nodes.Add( tn ); // add to control                if ( topNode == null ) topNode = tn; // once to keep the start of list                ActionMaps.Add( acm ); // add to our map              }//not ignored              }// if valid line            buf = sr.ReadLine( );          }//while        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The following statement contains a magic number: if ( ( Ctrl.SelectedNode.Level == 0 ) || ( Ctrl.SelectedNode.Level > 2 ) ) return am;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ActivationModeSelectedItem,The following statement contains a magic number: if ( Ctrl.SelectedNode.Level == 1 ) {          // this is the main node with Action Cmd          ActionTreeNode atn = ( Ctrl.SelectedNode as ActionTreeNode );  // the treenode from a level 1          ActionCls ac = FindActionObject( atn.Parent.Name' atn.Name ); if ( ac == null ) return am; // ERROR exit          ActionCommandCls acc = ac.FindActionInputObject( ActionTreeNode.CommandFromNodeText( atn.Text ) ); if ( acc == null ) return am; // ERROR exit          am = new ActivationModes( ac.defActivationMode' acc.ActivationMode ); // policy: get the default first' then the attached one          return am;        }        else if ( Ctrl.SelectedNode.Level == 2 ) {          // this is a child of an action with further commands          ActionTreeNode patn = ( Ctrl.SelectedNode.Parent as ActionTreeNode );  // the parent treenode          ActionTreeNode atn = ( Ctrl.SelectedNode as ActionTreeNode );  // the treenode from a level 1          // the related action          ActionCls ac = FindActionObject( patn.Parent.Name' patn.Name ); if ( ac == null ) return am; // ERROR exit          ActionCommandCls acc = ac.FindActionInputObject( atn.Index ); if ( acc == null ) return am; // ERROR exit          am = new ActivationModes( ac.defActivationMode' acc.ActivationMode );// policy: get the default first' then the attached one          return am;        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateActivationModeSelectedItem,The following statement contains a magic number: if ( ( Ctrl.SelectedNode.Level == 0 ) || ( Ctrl.SelectedNode.Level > 2 ) ) return;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateActivationModeSelectedItem,The following statement contains a magic number: if ( Ctrl.SelectedNode.Level == 1 ) {          // this is the main node with Action Cmd          ActionTreeNode atn = ( Ctrl.SelectedNode as ActionTreeNode );  // the treenode from a level 1          ActionCls ac = FindActionObject( atn.Parent.Name' atn.Name ); if ( ac == null ) return; // ERROR exit          ActionCommandCls acc = ac.FindActionInputObject( ActionTreeNode.CommandFromNodeText( atn.Text ) ); if ( acc == null ) return; // ERROR exit          // new am is either a named one or the Default from Profile (which is the default from the Action due to multiTaps..)          if ( ActivationMode.IsDefault( newActivationModeName ) ) {            acc.ActivationMode = new ActivationMode( ActivationMode.Default );          }          else {            acc.ActivationMode = ActivationModes.Instance.ActivationModeByName( newActivationModeName );          }          atn.UpdateAction( acc ); UpdateMasterNode( atn );          NodeSelected( ); // virtual event - as the selection does not change          Dirty = true;          }        else if ( Ctrl.SelectedNode.Level == 2 ) {          // this is a child of an action with further commands          ActionTreeNode patn = ( Ctrl.SelectedNode.Parent as ActionTreeNode );  // the parent treenode from a level 2          ActionTreeNode atn = ( Ctrl.SelectedNode as ActionTreeNode );  // the treenode from a level 2          // the related action          ActionCls ac = FindActionObject( patn.Parent.Name' patn.Name ); if ( ac == null ) return; // ERROR exit          // find it in the sublist           ActionCommandCls acc = ac.FindActionInputObject( atn.Index ); if ( acc == null ) return; // ERROR exit          // new am is either a named one or the Default from Profile (which is the default from the Action due to multiTaps..)          if ( ActivationMode.IsDefault( newActivationModeName ) ) {            acc.ActivationMode = new ActivationMode( ActivationMode.Default );          }          else {            acc.ActivationMode = ActivationModes.Instance.ActivationModeByName( newActivationModeName );          }          atn.UpdateAction( acc ); UpdateMasterNode( atn );          NodeSelected( ); // virtual event - as the selection does not change          Dirty = true;        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateSelectedItem,The following statement contains a magic number: if ( ( Ctrl.SelectedNode.Level == 0 ) || ( Ctrl.SelectedNode.Level > 2 ) ) return false;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,UpdateSelectedItem,The following statement contains a magic number: if ( Ctrl.SelectedNode.Level == 1 ) {          // this is the main node with Action Cmd          ActionTreeNode atn = ( Ctrl.SelectedNode as ActionTreeNode );  // the treenode from a level 1          ActionCls ac = FindActionObject( atn.Parent.Name' atn.Name );   // the related action in an actionmap          if ( ac == null ) return false; // ERROR exit          if ( checkKind && ( ac.actionDevice != inKind ) ) return false; // ERROR exit          ActionCommandCls acc = ac.FindActionInputObject( ActionTreeNode.CommandFromNodeText( atn.Text ) );          if ( acc == null ) return false; // ERROR exit          // have it - continue          ac.UpdateCommandFromInput( ActionCls.DevInput( input' inKind )' acc.NodeIndex + 1 );          atn.UpdateAction( acc ); UpdateMasterNode( atn );          NodeSelected( ); // virtual event - as the selection does not change          Dirty = true;          }        else if ( Ctrl.SelectedNode.Level == 2 ) {          // this is a child of an action with further commands          ActionTreeNode patn = ( Ctrl.SelectedNode.Parent as ActionTreeNode );  // the parent treenode from a level 2          ActionTreeInputNode atn = ( Ctrl.SelectedNode as ActionTreeInputNode );  // the treenode from a level 2          if ( string.IsNullOrEmpty( input ) )            atn.Action = "UNDEF"; // apply UNDEF          else            atn.Action = patn.Action; // apply the parent Action           ActionCls ac = FindActionObject( patn.Parent.Name' patn.Name );   // the related action in an actionmap          if ( ac == null ) return false; // ERROR exit          if ( checkKind ) {            if ( ac.actionDevice == ActionCls.ActionDevice.AD_Keyboard ) {              if ( ( inKind != ActionCls.ActionDevice.AD_Keyboard ) && ( inKind != ActionCls.ActionDevice.AD_Mouse ) ) return false; // ERROR exit            }            else {              if ( ac.actionDevice != inKind ) return false; // ERROR exit            }          }          ActionCommandCls acc = ac.FindActionInputObject( atn.Index );          if ( acc == null ) return false; // ERROR exit          // have it - continue          ac.UpdateCommandFromInput( ActionCls.DevInput( input' inKind )' acc.NodeIndex + 1 );          atn.UpdateAction( acc ); UpdateMasterNode( atn );          NodeSelected( ); // virtual event - as the selection does not change          Dirty = true;        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.FontSize( 12 );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.FontSize( 9 );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.SetTab( 852 );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.SetTab( 4260 );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.SetTab( 6532 );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: rtf.WriteTab( "Activation Mode".PadRight( 40 ) );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,FindAllActionsRTF,The following statement contains a magic number: foreach ( ActionMapCls acm in ActionMaps ) {          // have to search Actions in Maps          foreach ( ActionCls ac in acm ) {            if ( ac.defBinding == input ) {              aMode = string.Format( "{0};{1}"' ac.defActivationMode.Name' ac.defActivationMode.MultiTap );              rtf.Write( "profile" ); rtf.WriteTab( ac.name ); rtf.WriteTab( acm.name ); rtf.WriteTab( aMode ); rtf.WriteLn( );              rtf.WriteLn( );            }            foreach ( ActionCommandCls acc in ac.inputList ) {              if ( acc.DevInput == input ) {                aMode = string.Format( "modified;{0};{1}"' acc.ActivationMode.Name' acc.ActivationMode.MultiTap );                if ( acc.ActivationMode == ActivationMode.Default )                  aMode = string.Format( "default" );                rtf.RHighlightColor = RTF.RTFformatter.ERColor.ERC_Green;                rtf.Write( "mapped" ); rtf.WriteTab( ac.name ); rtf.WriteTab( acm.name ); rtf.WriteTab( aMode.PadRight( 80 ) ); rtf.WriteLn( );                rtf.RHighlightColor = RTF.RTFformatter.ERColor.ERC_Black;                rtf.WriteLn( );              }            }          }        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,SelectedActionCtrl,The following statement contains a magic number: if ( Ctrl.SelectedNode.Level == 1 ) {          ActionTreeNode matn = FindMasterAction( (ActionTreeNode)Ctrl.SelectedNode );          action = ActionTreeNode.ActionFromNodeText( matn.Text );          ctrl = ActionTreeNode.CommandFromNodeText( matn.Text );        }        else if ( Ctrl.SelectedNode.Level == 2 ) {          ActionTreeNode matn = FindMasterAction( (ActionTreeInputNode)Ctrl.SelectedNode ); // the parent treenode          action = ActionTreeNode.ActionFromNodeText( matn.Text );          ctrl = ActionTreeNode.CommandFromNodeText( matn.Text );        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The following statement contains a magic number: const int padAction = 42;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The following statement contains a magic number: const int padDevice = 4;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActions,The following statement contains a magic number: const int padInput = 25;
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The following statement contains a magic number: foreach ( ActionMapCls acm in ActionMaps ) {            foreach ( ActionCls ac in acm ) {            // we get an action for each device class here - sort it out            if ( ac.name != action ) {              // dump if not empty              if ( !string.IsNullOrEmpty( action ) ) {                // compose one action                rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] ); // should be one line now                repList += string.Format( "{0}"' rep );  // add to list              }              // action changed - restart collection              action = ac.name;              rep = string.Format( "{0};{1};"' acm.name' ac.name ); // actionmap; action                                                                    // note: don't add trailing semicolons as the are applied in the output formatting              if ( listModifiers ) {                kbA = "n.a.;;;;"; // defaults tag;input;mod-tag;mod-name;mod-mult              }              else {                kbA = "n.a.;"; // defaults tag;input              }              moA = kbA; xbA = kbA;              jsA = new string[] { kbA' kbA' kbA' kbA };            }              foreach ( ActionCommandCls acc in ac.inputList ) {              // this is for add binds              if ( ShowAction( ac.actionDevice' acc.Input ) ) {                if ( !string.IsNullOrEmpty( acc.Input ) ) {                  // set modified  - note: don't add trailing semicolons as the are applied in the output formatting                  string aTag = "modified"; //default or modified                  string aMode = string.Format( "modified;{0};{1}"' acc.ActivationMode.Name' acc.ActivationMode.MultiTap );                  // change if they are default mappings                  if ( acc.DevInput == ac.defBinding ) aTag = "default";                  if ( acc.ActivationMode == ActivationMode.Default ) aMode = string.Format( "default;{0};{1}"' ac.defActivationMode.Name' ac.defActivationMode.MultiTap );                  if ( listModifiers ) {                    switch ( ActionCls.ADeviceFromDevID( acc.DevID ) ) {                      case ActionCls.ActionDevice.AD_Keyboard: kbA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Mouse: moA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Joystick:                        int jsNum = JoystickCls.JSNum( acc.DevInput ) - 1;                        if ( jsNum >= 0 ) jsA[jsNum] = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Gamepad: xbA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      default: break;                    }//switch                  }                  else {                    switch ( ActionCls.ADeviceFromDevID( acc.DevID ) ) {                      case ActionCls.ActionDevice.AD_Keyboard: kbA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Mouse: moA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Joystick:                        int jsNum = JoystickCls.JSNum( acc.DevInput ) - 1;                        if ( jsNum >= 0 ) jsA[jsNum] = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Gamepad: xbA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      default: break;                    }//switch                  }                }              }// show            }// for aCmd          }// for action        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The following statement contains a magic number: foreach ( ActionMapCls acm in ActionMaps ) {            foreach ( ActionCls ac in acm ) {            // we get an action for each device class here - sort it out            if ( ac.name != action ) {              // dump if not empty              if ( !string.IsNullOrEmpty( action ) ) {                // compose one action                rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] ); // should be one line now                repList += string.Format( "{0}"' rep );  // add to list              }              // action changed - restart collection              action = ac.name;              rep = string.Format( "{0};{1};"' acm.name' ac.name ); // actionmap; action                                                                    // note: don't add trailing semicolons as the are applied in the output formatting              if ( listModifiers ) {                kbA = "n.a.;;;;"; // defaults tag;input;mod-tag;mod-name;mod-mult              }              else {                kbA = "n.a.;"; // defaults tag;input              }              moA = kbA; xbA = kbA;              jsA = new string[] { kbA' kbA' kbA' kbA };            }              foreach ( ActionCommandCls acc in ac.inputList ) {              // this is for add binds              if ( ShowAction( ac.actionDevice' acc.Input ) ) {                if ( !string.IsNullOrEmpty( acc.Input ) ) {                  // set modified  - note: don't add trailing semicolons as the are applied in the output formatting                  string aTag = "modified"; //default or modified                  string aMode = string.Format( "modified;{0};{1}"' acc.ActivationMode.Name' acc.ActivationMode.MultiTap );                  // change if they are default mappings                  if ( acc.DevInput == ac.defBinding ) aTag = "default";                  if ( acc.ActivationMode == ActivationMode.Default ) aMode = string.Format( "default;{0};{1}"' ac.defActivationMode.Name' ac.defActivationMode.MultiTap );                  if ( listModifiers ) {                    switch ( ActionCls.ADeviceFromDevID( acc.DevID ) ) {                      case ActionCls.ActionDevice.AD_Keyboard: kbA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Mouse: moA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Joystick:                        int jsNum = JoystickCls.JSNum( acc.DevInput ) - 1;                        if ( jsNum >= 0 ) jsA[jsNum] = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      case ActionCls.ActionDevice.AD_Gamepad: xbA = string.Format( "{0};{1};{2}"' aTag' acc.Input' aMode ); break;                      default: break;                    }//switch                  }                  else {                    switch ( ActionCls.ADeviceFromDevID( acc.DevID ) ) {                      case ActionCls.ActionDevice.AD_Keyboard: kbA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Mouse: moA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Joystick:                        int jsNum = JoystickCls.JSNum( acc.DevInput ) - 1;                        if ( jsNum >= 0 ) jsA[jsNum] = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      case ActionCls.ActionDevice.AD_Gamepad: xbA = string.Format( "{0};{1}"' aTag' acc.Input ); break;                      default: break;                    }//switch                  }                }              }// show            }// for aCmd          }// for action        }
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The following statement contains a magic number: rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] );
Magic Number,SCJMapper_V2,ActionTree,C:\repos\SCToolsfactory_SCJMapper-V2\actions\ActionTree.cs,ReportActionsCSV,The following statement contains a magic number: rep += string.Format( "{0};{1};{2};{3};{4};{5};{6}\n"' kbA' moA' xbA' jsA[0]' jsA[1]' jsA[2]' jsA[3] );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: for ( int i = 0; i < 5; i++ ) {          m_bSeries.BezierPoints.Add( new DataPoint( 0' 0 ) );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.25' 0.25 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.25' 0.25 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.5' 0.5 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.5' 0.5 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.75' 0.75 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,FormOptions,The following statement contains a magic number: chart1.Series[1].Points.AddXY( 0.75' 0.75 );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,DeviceTabsSetup,The following statement contains a magic number: for ( int idx = 0; idx < m_devListRef.Count; idx++ ) {          if ( m_devListRef[idx].XmlInstance > 0 ) {            // only with mapped devices            ListView lview = new ListView( );            Array.Resize( ref lviews' lviews.Length + 1 ); lviews[lviews.Length - 1] = lview;            // copied from Designer.cs            lview.Dock = DockStyle.Fill;            lview.Location = new Point( 3' 3 );            lview.Name = "LV";            lview.Size = new Size( 650' 629 );            lview.TabIndex = 0;            lview.UseCompatibleStateImageBehavior = false;            lview.View = View.Details;            lview.SelectedIndexChanged += new EventHandler( this.lvOptionTree_SelectedIndexChanged );              lview.Tag = Tuningoptions.TuneOptionIDfromJsN( m_devListRef[idx].DevClass' m_devListRef[idx].XmlInstance );            //m_devListRef[idx].DevInstanceGUID; // find an LV              TabPage tab = new TabPage( m_devListRef[idx].DevName );            Array.Resize( ref tabs' tabs.Length + 1 ); tabs[tabs.Length - 1] = tab;              // copied from Designer.cs            tab.Controls.Add( lview );            tab.Location = new Point( 4' 22 );            tab.Name = "Tab";            tab.Padding = new Padding( 3 );            tab.Size = new Size( 656' 635 );            tab.TabIndex = 0;            tab.UseVisualStyleBackColor = true;              tab.Tag = m_devListRef[idx].DevInstanceGUID;    // find a device Tab            tabC.TabPages.Add( tab );              DeviceTabSetup( tabC.TabPages.Count - 1 ); // last added          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Option" + instText' 180' HorizontalAlignment.Left );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Dev Control"' 80' HorizontalAlignment.Left );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Saturation"' 80' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Deadzone"' 80' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Invert"' 50' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Expo."' 50' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Curve P1"' 90' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Curve P2"' 90' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,ListViewSetup,The following statement contains a magic number: lview.Columns.Add( "Curve P3"' 90' HorizontalAlignment.Center );
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The following statement contains a magic number: if ( lv.nonLinCurveUsed ) {          lblLiveIn1.Text = lv.nonLinCurve.Pt( 0 ).X.ToString( "0.000" ); lblLiveOut1.Text = lv.nonLinCurve.Pt( 0 ).Y.ToString( "0.000" );          lblLiveIn2.Text = lv.nonLinCurve.Pt( 1 ).X.ToString( "0.000" ); lblLiveOut2.Text = lv.nonLinCurve.Pt( 1 ).Y.ToString( "0.000" );          lblLiveIn3.Text = lv.nonLinCurve.Pt( 2 ).X.ToString( "0.000" ); lblLiveOut3.Text = lv.nonLinCurve.Pt( 2 ).Y.ToString( "0.000" );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateGUIFromLiveValues,The following statement contains a magic number: if ( lv.nonLinCurveUsed ) {          lblLiveIn1.Text = lv.nonLinCurve.Pt( 0 ).X.ToString( "0.000" ); lblLiveOut1.Text = lv.nonLinCurve.Pt( 0 ).Y.ToString( "0.000" );          lblLiveIn2.Text = lv.nonLinCurve.Pt( 1 ).X.ToString( "0.000" ); lblLiveOut2.Text = lv.nonLinCurve.Pt( 1 ).Y.ToString( "0.000" );          lblLiveIn3.Text = lv.nonLinCurve.Pt( 2 ).X.ToString( "0.000" ); lblLiveOut3.Text = lv.nonLinCurve.Pt( 2 ).Y.ToString( "0.000" );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The following statement contains a magic number: if ( !lval.used ) {          // leave alone.. for next time enabling it          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = "---"; lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          lvi.SubItems[4].Text = "--- / ---"; lvi.SubItems[5].Text = "--- / ---"; lvi.SubItems[6].Text = "--- / ---"; // pt1..3        }        else {          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = m_live.invertS;          if ( m_live.exponentUsed )            lvi.SubItems[LV_Expo].Text = m_live.exponentS; // inverted .. expo          else            lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          if ( m_live.nonLinCurveUsed ) {            lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3          }          else {            lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The following statement contains a magic number: if ( !lval.used ) {          // leave alone.. for next time enabling it          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = "---"; lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          lvi.SubItems[4].Text = "--- / ---"; lvi.SubItems[5].Text = "--- / ---"; lvi.SubItems[6].Text = "--- / ---"; // pt1..3        }        else {          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = m_live.invertS;          if ( m_live.exponentUsed )            lvi.SubItems[LV_Expo].Text = m_live.exponentS; // inverted .. expo          else            lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          if ( m_live.nonLinCurveUsed ) {            lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3          }          else {            lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The following statement contains a magic number: if ( !lval.used ) {          // leave alone.. for next time enabling it          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = "---"; lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          lvi.SubItems[4].Text = "--- / ---"; lvi.SubItems[5].Text = "--- / ---"; lvi.SubItems[6].Text = "--- / ---"; // pt1..3        }        else {          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = m_live.invertS;          if ( m_live.exponentUsed )            lvi.SubItems[LV_Expo].Text = m_live.exponentS; // inverted .. expo          else            lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          if ( m_live.nonLinCurveUsed ) {            lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3          }          else {            lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The following statement contains a magic number: if ( !lval.used ) {          // leave alone.. for next time enabling it          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = "---"; lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          lvi.SubItems[4].Text = "--- / ---"; lvi.SubItems[5].Text = "--- / ---"; lvi.SubItems[6].Text = "--- / ---"; // pt1..3        }        else {          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = m_live.invertS;          if ( m_live.exponentUsed )            lvi.SubItems[LV_Expo].Text = m_live.exponentS; // inverted .. expo          else            lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          if ( m_live.nonLinCurveUsed ) {            lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3          }          else {            lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateLvOptionFromLiveValues,The following statement contains a magic number: if ( !lval.used ) {          // leave alone.. for next time enabling it          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = "---"; lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          lvi.SubItems[4].Text = "--- / ---"; lvi.SubItems[5].Text = "--- / ---"; lvi.SubItems[6].Text = "--- / ---"; // pt1..3        }        else {          lvi.SubItems[LV_DevCtrl].Text = m_live.control; // js4_x          lvi.SubItems[LV_Invert].Text = m_live.invertS;          if ( m_live.exponentUsed )            lvi.SubItems[LV_Expo].Text = m_live.exponentS; // inverted .. expo          else            lvi.SubItems[LV_Expo].Text = "---"; // inverted .. expo          if ( m_live.nonLinCurveUsed ) {            lvi.SubItems[LV_Pt1].Text = m_live.PtS( 1 ); lvi.SubItems[LV_Pt2].Text = m_live.PtS( 2 ); lvi.SubItems[LV_Pt3].Text = m_live.PtS( 3 ); // pt1..3          }          else {            lvi.SubItems[LV_Pt1].Text = "--- / ---"; lvi.SubItems[LV_Pt2].Text = "--- / ---"; lvi.SubItems[LV_Pt3].Text = "--- / ---"; // pt1..3          }        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,EvalChartInput,The following statement contains a magic number: if ( rbUsePts.Checked && rbLivePt2.Enabled && rbLivePt2.Checked ) m_hitPt = 2;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,EvalChartInput,The following statement contains a magic number: if ( rbUsePts.Checked && rbLivePt3.Enabled && rbLivePt3.Checked ) m_hitPt = 3;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,EvalChartInput,The following statement contains a magic number: if ( rbUseExpo.Checked && rbLivePtExponent.Enabled && rbLivePtExponent.Checked ) m_hitPt = 4;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: if ( expUsed ) {          // Exp mode          double expo = double.Parse( lblOut[4].Text );          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' expo ) );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' expo ) );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' expo ) );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else if ( ptsUsed ) {          // Pts mode          // dont touch zero Point          for ( int i = 1; i <= 3; i++ ) {            m_bSeries.BezierPoints[i].SetValueXY( float.Parse( lblIn[i].Text )' float.Parse( lblOut[i].Text ) );          }          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );          }        else {          // linear          // dont touch zero Point          m_bSeries.BezierPoints[1].SetValueXY( 0.25' 0.25 );          m_bSeries.BezierPoints[2].SetValueXY( 0.5' 0.5 );          m_bSeries.BezierPoints[3].SetValueXY( 0.75' 0.75 );          m_bSeries.BezierPoints[4].SetValueXY( 1.0' 1.0 );        }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,chartPoint_MouseMove,The following statement contains a magic number: if ( m_hitActive ) {          if ( m_hitPt < 1 ) {            // nothing selected ...          }          else if ( m_hitPt <= 3 ) {            // Pt1..3            double newX = double.Parse( lblIn[m_hitPt].Text ) + ( e.X - mX ) * 0.001f; mX = e.X;            newX = ( newX > 1.0f ) ? 1.0f : newX;            newX = ( newX < 0.0f ) ? 0.0f : newX;            lblIn[m_hitPt].Text = newX.ToString( "0.000" );              double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * -0.001f; mY = e.Y;            newY = ( newY > 1.0f ) ? 1.0f : newY;            newY = ( newY < 0.0f ) ? 0.0f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[m_hitPt].SetValueXY( newX' newY );            // update markers from curve points            chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];            }          else if ( m_hitPt == 4 ) {            // Exponent            double newY = double.Parse( lblOut[m_hitPt].Text ) + ( e.Y - mY ) * 0.01f; mY = e.Y;            newY = ( newY > 3.0f ) ? 3.0f : newY;            newY = ( newY < 0.5f ) ? 0.5f : newY;            lblOut[m_hitPt].Text = newY.ToString( "0.000" );              // update chart (Points[0] is zero)            m_bSeries.BezierPoints[1].SetValueXY( 0.25' Math.Pow( 0.25' newY ) );            m_bSeries.BezierPoints[2].SetValueXY( 0.5' Math.Pow( 0.5' newY ) );            m_bSeries.BezierPoints[3].SetValueXY( 0.75' Math.Pow( 0.75' newY ) );          }            // update markers from curve points          chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];          chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];          chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];          chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];            m_bSeries.Invalidate( chart1 );          }
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.pnlDevOptionInput' 1' 2);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.pnlPreview' 0' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.panel4' 1' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(9' 9);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(9' 9);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 4;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(1008' 719);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(1008' 719);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabC.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabC.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.SetRowSpan(this.tabC' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabC.Size = new System.Drawing.Size(664' 661);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabC.Size = new System.Drawing.Size(664' 661);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabC.TabIndex = 3;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabOptions.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabOptions.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabOptions.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabOptions.Size = new System.Drawing.Size(656' 635);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabOptions.Size = new System.Drawing.Size(656' 635);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lvOptionTree.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lvOptionTree.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lvOptionTree.Size = new System.Drawing.Size(650' 629);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lvOptionTree.Size = new System.Drawing.Size(650' 629);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabDevOption.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabDevOption.Location = new System.Drawing.Point(4' 22);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabDevOption.Padding = new System.Windows.Forms.Padding(3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabDevOption.Size = new System.Drawing.Size(656' 635);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tabDevOption.Size = new System.Drawing.Size(656' 635);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlOptionInput.Location = new System.Drawing.Point(673' 28);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlOptionInput.Location = new System.Drawing.Point(673' 28);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlOptionInput.Size = new System.Drawing.Size(332' 510);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlOptionInput.Size = new System.Drawing.Size(332' 510);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlOptionInput.TabIndex = 6;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUsePts.Location = new System.Drawing.Point(13' 396);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUsePts.Location = new System.Drawing.Point(13' 396);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUsePts.Size = new System.Drawing.Size(58' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUsePts.Size = new System.Drawing.Size(58' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUsePts.TabIndex = 57;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseExpo.Location = new System.Drawing.Point(13' 354);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseExpo.Location = new System.Drawing.Point(13' 354);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseExpo.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseExpo.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseExpo.TabIndex = 57;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseNone.Location = new System.Drawing.Point(13' 482);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseNone.Location = new System.Drawing.Point(13' 482);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseNone.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseNone.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbUseNone.TabIndex = 56;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(103' 345);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(103' 345);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(220' 144);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(220' 144);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel2.TabIndex = 55;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePtExponent.Location = new System.Drawing.Point(9' 9);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePtExponent.Location = new System.Drawing.Point(9' 9);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePtExponent.Size = new System.Drawing.Size(85' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePtExponent.Size = new System.Drawing.Size(85' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePtExponent.TabIndex = 33;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutExponent.Location = new System.Drawing.Point(107' 11);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutExponent.Location = new System.Drawing.Point(107' 11);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutExponent.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutExponent.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutExponent.TabIndex = 9;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn1.Location = new System.Drawing.Point(84' 51);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn1.Location = new System.Drawing.Point(84' 51);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn1.TabIndex = 18;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut1.Location = new System.Drawing.Point(137' 51);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut1.Location = new System.Drawing.Point(137' 51);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut1.TabIndex = 19;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxLiveInvert.Location = new System.Drawing.Point(9' 120);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxLiveInvert.Location = new System.Drawing.Point(9' 120);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxLiveInvert.Size = new System.Drawing.Size(59' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxLiveInvert.Size = new System.Drawing.Size(59' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxLiveInvert.TabIndex = 54;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn2.Location = new System.Drawing.Point(84' 74);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn2.Location = new System.Drawing.Point(84' 74);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn2.TabIndex = 20;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut2.Location = new System.Drawing.Point(137' 74);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut2.Location = new System.Drawing.Point(137' 74);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut2.TabIndex = 21;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn3.Location = new System.Drawing.Point(84' 97);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn3.Location = new System.Drawing.Point(84' 97);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveIn3.TabIndex = 22;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt3.Location = new System.Drawing.Point(9' 95);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt3.Location = new System.Drawing.Point(9' 95);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt3.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt3.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt3.TabIndex = 31;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut3.Location = new System.Drawing.Point(137' 97);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut3.Location = new System.Drawing.Point(137' 97);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOut3.TabIndex = 23;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt2.Location = new System.Drawing.Point(9' 72);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt2.Location = new System.Drawing.Point(9' 72);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt2.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt2.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt2.TabIndex = 30;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label32.Location = new System.Drawing.Point(84' 31);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label32.Location = new System.Drawing.Point(84' 31);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label32.Size = new System.Drawing.Size(35' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label32.Size = new System.Drawing.Size(35' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label32.TabIndex = 27;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt1.Location = new System.Drawing.Point(9' 49);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt1.Location = new System.Drawing.Point(9' 49);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt1.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt1.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.rbLivePt1.TabIndex = 29;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label33.Location = new System.Drawing.Point(130' 31);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label33.Location = new System.Drawing.Point(130' 31);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label33.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label33.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label33.TabIndex = 28;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Location = new System.Drawing.Point(289' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Location = new System.Drawing.Point(289' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.TabIndex = 53;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Location = new System.Drawing.Point(10' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Location = new System.Drawing.Point(10' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.TabIndex = 52;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveNodetext.Location = new System.Drawing.Point(13' 321);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveNodetext.Location = new System.Drawing.Point(13' 321);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveNodetext.Size = new System.Drawing.Size(16' 13);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveNodetext.Size = new System.Drawing.Size(16' 13);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveNodetext.TabIndex = 51;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(84' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(84' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(178' 13);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(178' 13);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 36;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Location = new System.Drawing.Point(16' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Location = new System.Drawing.Point(16' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Size = new System.Drawing.Size(301' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Size = new System.Drawing.Size(301' 295);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.chart1.TabIndex = 16;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlDevOptionInput.Location = new System.Drawing.Point(673' 544);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlDevOptionInput.Location = new System.Drawing.Point(673' 544);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlDevOptionInput.Size = new System.Drawing.Size(332' 120);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlDevOptionInput.Size = new System.Drawing.Size(332' 120);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlDevOptionInput.TabIndex = 7;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseSaturation.Location = new System.Drawing.Point(13' 76);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseSaturation.Location = new System.Drawing.Point(13' 76);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseSaturation.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseSaturation.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseSaturation.TabIndex = 57;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseDeadzone.Location = new System.Drawing.Point(13' 25);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseDeadzone.Location = new System.Drawing.Point(13' 25);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseDeadzone.Size = new System.Drawing.Size(83' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseDeadzone.Size = new System.Drawing.Size(83' 17);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.cbxUseDeadzone.TabIndex = 56;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Location = new System.Drawing.Point(103' 5);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Location = new System.Drawing.Point(103' 5);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Size = new System.Drawing.Size(220' 109);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel3.Size = new System.Drawing.Size(220' 109);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel3.TabIndex = 55;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutSaturation.Location = new System.Drawing.Point(180' 71);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutSaturation.Location = new System.Drawing.Point(180' 71);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutSaturation.TabIndex = 15;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.Location = new System.Drawing.Point(9' 58);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.Location = new System.Drawing.Point(9' 58);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.Maximum = 40;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.TabIndex = 14;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbSaturation.TickFrequency = 5;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.Location = new System.Drawing.Point(9' 7);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.Location = new System.Drawing.Point(9' 7);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.Maximum = 40;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.tbDeadzone.TickFrequency = 5;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutDeadzone.Location = new System.Drawing.Point(180' 20);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutDeadzone.Location = new System.Drawing.Point(180' 20);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveOutDeadzone.TabIndex = 13;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlPreview.Location = new System.Drawing.Point(3' 670);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlPreview.Location = new System.Drawing.Point(3' 670);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlPreview.Size = new System.Drawing.Size(664' 46);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlPreview.Size = new System.Drawing.Size(664' 46);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.pnlPreview.TabIndex = 8;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btDebugStop.Location = new System.Drawing.Point(233' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btDebugStop.Location = new System.Drawing.Point(233' 3);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btDebugStop.Size = new System.Drawing.Size(134' 27);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btDebugStop.Size = new System.Drawing.Size(134' 27);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btDebugStop.TabIndex = 2;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel4.Location = new System.Drawing.Point(673' 670);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel4.Location = new System.Drawing.Point(673' 670);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel4.Size = new System.Drawing.Size(332' 46);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel4.Size = new System.Drawing.Size(332' 46);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.panel4.TabIndex = 9;
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btExit.Location = new System.Drawing.Point(193' 8);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btExit.Location = new System.Drawing.Point(193' 8);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btExit.Size = new System.Drawing.Size(136' 32);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.btExit.Size = new System.Drawing.Size(136' 32);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1027' 737);
Magic Number,SCJMapper_V2.Options,FormOptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1027' 737);
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Load,The following statement contains a magic number: if ( dp != null ) {            optionName = dp.OptionName;            used = true; // always              isTuningItem = true;            isDevOptionItem = false;              gameDeviceRef = dp.GameDevice;            nodetext = dp.NodeText;            if ( !string.IsNullOrEmpty( dp.NodeText ) ) {              string[] e = nodetext.Split( new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries );              if ( e.Length > 0 )                control = e[1].TrimEnd( );              else                control = dp.NodeText;            }            else if ( gameDeviceRef != null ) {              //control = gameDeviceRef.DevName;            }            else {              control = "n.a.";            }            command = dp.CommandCtrl;              // the device option data if available            if ( dp.DeviceoptionRef != null ) {              isDevOptionItem = true;                deadzoneUsed = dp.DeviceoptionRef.DeadzoneUsed;              deadzoneS = dp.DeviceoptionRef.Deadzone;                saturationSupported = dp.DeviceoptionRef.SaturationSupported;              saturationUsed = dp.DeviceoptionRef.SaturationUsed;              saturationS = dp.DeviceoptionRef.Saturation;            }            else {              deadzoneUsed = false;              saturationSupported = false;              saturationUsed = false;            }              // the tuning data            invertUsed = dp.InvertUsed;            exponentUsed = dp.ExponentUsed;            exponentS = dp.Exponent;            nonLinCurveUsed = dp.NonLinCurveUsed;            if ( dp.NonLinCurveUsed ) {              nonLinCurve.Curve( float.Parse( dp.NonLinCurvePtsIn[0] )' float.Parse( dp.NonLinCurvePtsOut[0] )'                                     float.Parse( dp.NonLinCurvePtsIn[1] )' float.Parse( dp.NonLinCurvePtsOut[1] )'                                     float.Parse( dp.NonLinCurvePtsIn[2] )' float.Parse( dp.NonLinCurvePtsOut[2] ) );            }            else {              // dummy curve              nonLinCurve.Curve( 0.25f' 0.25f' 0.5f' 0.5f' 0.75f' 0.75f );            }          }
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Load,The following statement contains a magic number: if ( dp != null ) {            optionName = dp.OptionName;            used = true; // always              isTuningItem = true;            isDevOptionItem = false;              gameDeviceRef = dp.GameDevice;            nodetext = dp.NodeText;            if ( !string.IsNullOrEmpty( dp.NodeText ) ) {              string[] e = nodetext.Split( new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries );              if ( e.Length > 0 )                control = e[1].TrimEnd( );              else                control = dp.NodeText;            }            else if ( gameDeviceRef != null ) {              //control = gameDeviceRef.DevName;            }            else {              control = "n.a.";            }            command = dp.CommandCtrl;              // the device option data if available            if ( dp.DeviceoptionRef != null ) {              isDevOptionItem = true;                deadzoneUsed = dp.DeviceoptionRef.DeadzoneUsed;              deadzoneS = dp.DeviceoptionRef.Deadzone;                saturationSupported = dp.DeviceoptionRef.SaturationSupported;              saturationUsed = dp.DeviceoptionRef.SaturationUsed;              saturationS = dp.DeviceoptionRef.Saturation;            }            else {              deadzoneUsed = false;              saturationSupported = false;              saturationUsed = false;            }              // the tuning data            invertUsed = dp.InvertUsed;            exponentUsed = dp.ExponentUsed;            exponentS = dp.Exponent;            nonLinCurveUsed = dp.NonLinCurveUsed;            if ( dp.NonLinCurveUsed ) {              nonLinCurve.Curve( float.Parse( dp.NonLinCurvePtsIn[0] )' float.Parse( dp.NonLinCurvePtsOut[0] )'                                     float.Parse( dp.NonLinCurvePtsIn[1] )' float.Parse( dp.NonLinCurvePtsOut[1] )'                                     float.Parse( dp.NonLinCurvePtsIn[2] )' float.Parse( dp.NonLinCurvePtsOut[2] ) );            }            else {              // dummy curve              nonLinCurve.Curve( 0.25f' 0.25f' 0.5f' 0.5f' 0.75f' 0.75f );            }          }
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Update,The following statement contains a magic number: pts.Add( nonLinCurve.Pt( 2 ).X.ToString( "0.000" ) );
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Update,The following statement contains a magic number: pts.Add( nonLinCurve.Pt( 2 ).Y.ToString( "0.000" ) );
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Reset,The following statement contains a magic number: m_range = 1000.0;
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,Reset,The following statement contains a magic number: saturation = 1000.0;
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,PtInS,The following statement contains a magic number: if ( !nonLinCurveUsed )            return ( 0.25 * ptIndex ).ToString( "0.000" );          else            return nonLinCurve.Pt( ptIndex - 1 ).X.ToString( "0.000" );
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,PtOutS,The following statement contains a magic number: if ( !nonLinCurveUsed )            return ( 0.25 * ptIndex ).ToString( "0.000" );          else            return nonLinCurve.Pt( ptIndex - 1 ).Y.ToString( "0.000" );
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,PtS,The following statement contains a magic number: if ( !nonLinCurveUsed )            return ( 0.25 * ptIndex ).ToString( "0.000" ) + " / " + ( 0.25 * ptIndex ).ToString( "0.000" );          else            return nonLinCurve.Pt( ptIndex - 1 ).X.ToString( "0.000" ) + " / " + nonLinCurve.Pt( ptIndex - 1 ).Y.ToString( "0.000" );
Magic Number,SCJMapper_V2.Options,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\Options\FormOptions.cs,PtS,The following statement contains a magic number: if ( !nonLinCurveUsed )            return ( 0.25 * ptIndex ).ToString( "0.000" ) + " / " + ( 0.25 * ptIndex ).ToString( "0.000" );          else            return nonLinCurve.Pt( ptIndex - 1 ).X.ToString( "0.000" ) + " / " + nonLinCurve.Pt( ptIndex - 1 ).Y.ToString( "0.000" );
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,Tuningoptions,C:\repos\SCToolsfactory_SCJMapper-V2\Options\Tuningoptions.cs,Tuningoptions,The following statement contains a magic number: m_jsMap = new int[] { 1' 2' 3' 4' 5' 6' 7' 8' 9' 10' 11' 12 };
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_toXML,The following statement contains a magic number: if ( NonLinCurveUsed ) {          // add exp to avoid merge of things...          tmp += string.Format( "exponent=\"1.00\" > \n" ); // CIG get to default expo 2.something if not set to 1 here          tmp += string.Format( "\t\t\t<nonlinearity_curve>\n" );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[0]' m_PtsOut[0] );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[1]' m_PtsOut[1] );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[2]' m_PtsOut[2] );          tmp += string.Format( "\t\t\t</nonlinearity_curve>\n" );          tmp += string.Format( "\t\t</{0}> \n"' m_option );        } else if ( ExponentUsed ) {          // only exp used          tmp += string.Format( "exponent=\"{0}\" /> \n"' Exponent );        } else {          // neither exp or curve          tmp += string.Format( " /> \n" );// nothing...        }
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_toXML,The following statement contains a magic number: if ( NonLinCurveUsed ) {          // add exp to avoid merge of things...          tmp += string.Format( "exponent=\"1.00\" > \n" ); // CIG get to default expo 2.something if not set to 1 here          tmp += string.Format( "\t\t\t<nonlinearity_curve>\n" );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[0]' m_PtsOut[0] );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[1]' m_PtsOut[1] );          tmp += string.Format( "\t\t\t\t<point in=\"{0}\"  out=\"{1}\"/>\n"' m_PtsIn[2]' m_PtsOut[2] );          tmp += string.Format( "\t\t\t</nonlinearity_curve>\n" );          tmp += string.Format( "\t\t</{0}> \n"' m_option );        } else if ( ExponentUsed ) {          // only exp used          tmp += string.Format( "exponent=\"{0}\" /> \n"' Exponent );        } else {          // neither exp or curve          tmp += string.Format( " /> \n" );// nothing...        }
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_fromXML,The following statement contains a magic number: if ( e.Length > 2 ) m_cmdCtrl = e[2];
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_fromXML,The following statement contains a magic number: if ( e.Length > 2 ) m_cmdCtrl = e[2];
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_fromXML,The following statement contains a magic number: if ( !reader.IsEmptyElement ) {          reader.Read( );          if ( !reader.EOF ) {            if ( reader.Name.ToLowerInvariant( ) == "nonlinearity_curve" ) {              m_PtsIn.Clear( ); m_PtsOut.Clear( ); // reset pts              ExponentUsed = false; // NonLin Curve takes prio                reader.Read( );              while ( !reader.EOF ) {                string ptIn = "";                string ptOut = "";                if ( reader.Name.ToLowerInvariant( ) == "point" ) {                  if ( reader.HasAttributes ) {                    ptIn = RoundString( reader["in"] );                    ptOut = RoundString( reader["out"] );                    m_PtsIn.Add( ptIn ); m_PtsOut.Add( ptOut ); m_ptsEnabled = true;                  }                }                reader.Read( );              }//while               // sanity check - we've have to have 3 pts  here - else we subst               // add 2nd              if ( m_PtsIn.Count < 2 ) {                m_PtsIn.Add( "0.500" ); m_PtsOut.Add( "0.500" );                log.Info( "Options_fromXML: got only one nonlin point' added (0.5|0.5)" );              }              // add 3rd              if ( m_PtsIn.Count < 3 ) {                m_PtsIn.Add( "0.750" ); m_PtsOut.Add( "0.750" );                log.Info( "Options_fromXML: got only two nonlin points' added (0.75|0.75)" );              }            }          }        }
Magic Number,SCJMapper_V2.Options,DeviceTuningParameter,C:\repos\SCToolsfactory_SCJMapper-V2\Options\DeviceTuningParameter.cs,Options_fromXML,The following statement contains a magic number: if ( !reader.IsEmptyElement ) {          reader.Read( );          if ( !reader.EOF ) {            if ( reader.Name.ToLowerInvariant( ) == "nonlinearity_curve" ) {              m_PtsIn.Clear( ); m_PtsOut.Clear( ); // reset pts              ExponentUsed = false; // NonLin Curve takes prio                reader.Read( );              while ( !reader.EOF ) {                string ptIn = "";                string ptOut = "";                if ( reader.Name.ToLowerInvariant( ) == "point" ) {                  if ( reader.HasAttributes ) {                    ptIn = RoundString( reader["in"] );                    ptOut = RoundString( reader["out"] );                    m_PtsIn.Add( ptIn ); m_PtsOut.Add( ptOut ); m_ptsEnabled = true;                  }                }                reader.Read( );              }//while               // sanity check - we've have to have 3 pts  here - else we subst               // add 2nd              if ( m_PtsIn.Count < 2 ) {                m_PtsIn.Add( "0.500" ); m_PtsOut.Add( "0.500" );                log.Info( "Options_fromXML: got only one nonlin point' added (0.5|0.5)" );              }              // add 3rd              if ( m_PtsIn.Count < 3 ) {                m_PtsIn.Add( "0.750" ); m_PtsOut.Add( "0.750" );                log.Info( "Options_fromXML: got only two nonlin points' added (0.75|0.75)" );              }            }          }        }
Magic Number,SCJMapper_V2.RTF,RTFformatter,C:\repos\SCToolsfactory_SCJMapper-V2\RTF\RTFformatter.cs,FontSize_low,The following statement contains a magic number: return @"\fs" + ( ps * 2 ).ToString( ).Trim( );
Magic Number,SCJMapper_V2.Table,DS_ActionMap,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMap.cs,ActionMapFromAMShown,The following statement contains a magic number: string ret = actionMapShown.Substring(3);
Magic Number,SCJMapper_V2.Table,DS_ActionMap,C:\repos\SCToolsfactory_SCJMapper-V2\Table\DS_ActionMap.cs,ActionCommandIndex,The following statement contains a magic number: int actionCommandIndex = int.Parse( e[2] );
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: dataGridViewCellStyle1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: dataGridViewCellStyle1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: dataGridViewCellStyle1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(224))))' ((int)(((byte)(224))))' ((int)(((byte)(224)))));
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.DGV.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.DGV.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.DGV.Size = new System.Drawing.Size(438' 230);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.DGV.Size = new System.Drawing.Size(438' 230);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterAction.Location = new System.Drawing.Point(93' 6);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterAction.Location = new System.Drawing.Point(93' 6);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterAction.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterAction.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(744' 286);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(744' 286);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.TabIndex = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(447' 239);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(447' 239);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(294' 44);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(294' 44);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel2.TabIndex = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point(447' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point(447' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.RowCount = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size(294' 230);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size(294' 230);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.TabIndex = 3;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(288' 202);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(288' 202);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btBlendAll.Location = new System.Drawing.Point(183' 122);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btBlendAll.Location = new System.Drawing.Point(183' 122);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btBlendAll.Size = new System.Drawing.Size(97' 42);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btBlendAll.Size = new System.Drawing.Size(97' 42);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btBlendAll.TabIndex = 14;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btCancelEdit.Location = new System.Drawing.Point(183' 170);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btCancelEdit.Location = new System.Drawing.Point(183' 170);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btCancelEdit.Size = new System.Drawing.Size(97' 28);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btCancelEdit.Size = new System.Drawing.Size(97' 28);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btCancelEdit.TabIndex = 13;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkEditBlend.Location = new System.Drawing.Point(76' 135);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkEditBlend.Location = new System.Drawing.Point(76' 135);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkEditBlend.Size = new System.Drawing.Size(87' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkEditBlend.Size = new System.Drawing.Size(87' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkEditBlend.TabIndex = 12;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btUpdateFromEdit.Location = new System.Drawing.Point(10' 169);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btUpdateFromEdit.Location = new System.Drawing.Point(10' 169);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btUpdateFromEdit.Size = new System.Drawing.Size(97' 30);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btUpdateFromEdit.Size = new System.Drawing.Size(97' 30);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btUpdateFromEdit.TabIndex = 12;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterUsrBinding.Location = new System.Drawing.Point(222' 60);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterUsrBinding.Location = new System.Drawing.Point(222' 60);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterUsrBinding.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterUsrBinding.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterUsrBinding.TabIndex = 11;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(7' 65);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(7' 65);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(80' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(80' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 10;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterUsrBinding.Location = new System.Drawing.Point(93' 62);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterUsrBinding.Location = new System.Drawing.Point(93' 62);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterUsrBinding.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterUsrBinding.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterUsrBinding.TabIndex = 9;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterDefBinding.Location = new System.Drawing.Point(222' 32);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterDefBinding.Location = new System.Drawing.Point(222' 32);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterDefBinding.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterDefBinding.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterDefBinding.TabIndex = 8;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(7' 37);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(7' 37);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(81' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(81' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 7;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterDefBinding.Location = new System.Drawing.Point(93' 34);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterDefBinding.Location = new System.Drawing.Point(93' 34);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterDefBinding.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterDefBinding.Size = new System.Drawing.Size(109' 22);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.txFilterDefBinding.TabIndex = 6;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterAction.Location = new System.Drawing.Point(222' 4);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterAction.Location = new System.Drawing.Point(222' 4);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterAction.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterAction.Size = new System.Drawing.Size(58' 23);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.btClrFilterAction.TabIndex = 5;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkKbd.Location = new System.Drawing.Point(222' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkKbd.Location = new System.Drawing.Point(222' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkKbd.Size = new System.Drawing.Size(46' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkKbd.Size = new System.Drawing.Size(46' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkKbd.TabIndex = 4;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkMouse.Location = new System.Drawing.Point(158' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkMouse.Location = new System.Drawing.Point(158' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkMouse.Size = new System.Drawing.Size(61' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkMouse.Size = new System.Drawing.Size(61' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkMouse.TabIndex = 4;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkGamepad.Location = new System.Drawing.Point(80' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkGamepad.Location = new System.Drawing.Point(80' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkGamepad.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkGamepad.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkGamepad.TabIndex = 4;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkJoystick.Location = new System.Drawing.Point(10' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkJoystick.Location = new System.Drawing.Point(10' 93);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkJoystick.Size = new System.Drawing.Size(65' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkJoystick.Size = new System.Drawing.Size(65' 17);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.chkJoystick.TabIndex = 3;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(7' 9);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(7' 9);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(744' 286);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(744' 286);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(760' 320);
Magic Number,SCJMapper_V2.Table,FormTable,C:\repos\SCToolsfactory_SCJMapper-V2\Table\FormTable.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(760' 320);
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,FromAC1,The following statement contains a magic number: if ( retVal.StartsWith( "xi_" ) )          retVal = retVal.Insert( 2' "1" );        else          retVal = "xi1_" + retVal;
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.LeftThumbX = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.LeftThumbX = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.LeftThumbY = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.LeftThumbY = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.RightThumbX = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.RightThumbX = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.RightThumbY = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,ApplyCalibration,The following statement contains a magic number: state.Gamepad.RightThumbY = (short)( val > 32767 ? 32767 * sign : val * sign );
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,DidAxisChange2,The following statement contains a magic number: int change = ( Math.Abs( current ) - Math.Abs( prev ) ) / 32;
Magic Number,SCJMapper_V2.Gamepad,GamepadCls,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\GamepadCls.cs,DidAxisChange,The following statement contains a magic number: return changepct > 70 ? true : false;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,Chk,The following statement contains a magic number: if ( s.Length > 12 ) return d; else return s;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Size = new System.Drawing.Size(232' 60);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Size = new System.Drawing.Size(232' 60);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.TabIndex = 5;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.TabIndex = 14;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTSticks.Location = new System.Drawing.Point(188' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTSticks.Location = new System.Drawing.Point(188' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTSticks.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTSticks.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTSticks.TabIndex = 14;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnDPad.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnDPad.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnDPad.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnDPad.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnDPad.TabIndex = 14;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 13;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 13;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(47' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(47' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 13;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Location = new System.Drawing.Point(3' 67);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Location = new System.Drawing.Point(3' 67);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Size = new System.Drawing.Size(232' 161);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Size = new System.Drawing.Size(232' 161);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.TabIndex = 6;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Location = new System.Drawing.Point(65' 141);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Location = new System.Drawing.Point(65' 141);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Size = new System.Drawing.Size(154' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Size = new System.Drawing.Size(154' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.TabIndex = 25;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Location = new System.Drawing.Point(9' 141);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Location = new System.Drawing.Point(9' 141);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Size = new System.Drawing.Size(46' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Size = new System.Drawing.Size(46' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.TabIndex = 24;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtBack.Location = new System.Drawing.Point(185' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtBack.Location = new System.Drawing.Point(185' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtBack.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtBack.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtBack.TabIndex = 23;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigR.Location = new System.Drawing.Point(81' 88);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigR.Location = new System.Drawing.Point(81' 88);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigR.TabIndex = 22;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigL.Location = new System.Drawing.Point(81' 72);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigL.Location = new System.Drawing.Point(81' 72);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTrigL.TabIndex = 21;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtStart.Location = new System.Drawing.Point(185' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtStart.Location = new System.Drawing.Point(185' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtStart.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtStart.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iBtStart.TabIndex = 20;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShR.Location = new System.Drawing.Point(81' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShR.Location = new System.Drawing.Point(81' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShR.TabIndex = 19;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShL.Location = new System.Drawing.Point(81' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShL.Location = new System.Drawing.Point(81' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iShL.TabIndex = 18;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXR.Location = new System.Drawing.Point(81' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXR.Location = new System.Drawing.Point(81' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXR.TabIndex = 14;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXL.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXL.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickXL.TabIndex = 13;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iDPad.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iDPad.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iDPad.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iDPad.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iDPad.TabIndex = 12;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Location = new System.Drawing.Point(124' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Location = new System.Drawing.Point(124' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Size = new System.Drawing.Size(35' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Size = new System.Drawing.Size(35' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.TabIndex = 11;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Location = new System.Drawing.Point(124' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Location = new System.Drawing.Point(124' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Size = new System.Drawing.Size(32' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Size = new System.Drawing.Size(32' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.TabIndex = 10;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Location = new System.Drawing.Point(9' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Location = new System.Drawing.Point(9' 122);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Size = new System.Drawing.Size(51' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Size = new System.Drawing.Size(51' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.TabIndex = 9;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Location = new System.Drawing.Point(9' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Location = new System.Drawing.Point(9' 106);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Size = new System.Drawing.Size(44' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Size = new System.Drawing.Size(44' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.TabIndex = 8;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigR.Location = new System.Drawing.Point(9' 88);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigR.Location = new System.Drawing.Point(9' 88);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigR.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigR.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigR.TabIndex = 7;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigL.Location = new System.Drawing.Point(9' 72);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigL.Location = new System.Drawing.Point(9' 72);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigL.Size = new System.Drawing.Size(52' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigL.Size = new System.Drawing.Size(52' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTrigL.TabIndex = 6;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickR.Location = new System.Drawing.Point(9' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickR.Location = new System.Drawing.Point(9' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickR.Size = new System.Drawing.Size(69' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickR.Size = new System.Drawing.Size(69' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickR.TabIndex = 2;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickL.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickL.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickL.Size = new System.Drawing.Size(62' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lTStickL.Size = new System.Drawing.Size(62' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lDPad.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lDPad.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lDPad.Size = new System.Drawing.Size(37' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lDPad.Size = new System.Drawing.Size(37' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTriggers.Location = new System.Drawing.Point(188' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTriggers.Location = new System.Drawing.Point(188' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTriggers.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTriggers.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnTriggers.TabIndex = 16;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(58' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(58' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 15;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYL.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYL.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYL.TabIndex = 26;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYR.Location = new System.Drawing.Point(124' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYR.Location = new System.Drawing.Point(124' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickYR.TabIndex = 14;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtL.Location = new System.Drawing.Point(185' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtL.Location = new System.Drawing.Point(185' 40);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtL.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtL.TabIndex = 27;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtR.Location = new System.Drawing.Point(185' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtR.Location = new System.Drawing.Point(185' 56);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtR.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.iTStickBtR.TabIndex = 27;
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(239' 295);
Magic Number,SCJMapper_V2.Gamepad,UC_GpadPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Gamepad\UC_GpadPanel.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(239' 295);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[2] = txJS3;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[3] = txJS4;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[4] = txJS5;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[5] = txJS6;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[6] = txJS7;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[7] = txJS8;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[8] = txJS9;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[9] = txJS10;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[10] = txJS11;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_tb[11] = txJS12;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[2] = cbxStick3;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[3] = cbxStick4;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[4] = cbxStick5;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[5] = cbxStick6;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[6] = cbxStick7;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[7] = cbxStick8;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[8] = cbxStick9;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[9] = cbxStick10;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[10] = cbxStick11;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,FormReassign,The following statement contains a magic number: m_cb[11] = cbxStick12;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,IsOK,The following statement contains a magic number: return ( ( jsx[1] < 2 ) && ( jsx[2] < 2 ) && ( jsx[3] < 2 ) && ( jsx[4] < 2 )               && ( jsx[5] < 2 ) && ( jsx[6] < 2 ) && ( jsx[7] < 2 ) && ( jsx[8] < 2 )              && ( jsx[9] < 2 ) && ( jsx[10] < 2 ) && ( jsx[11] < 2 ) && ( jsx[12] < 2 ) );
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Location = new System.Drawing.Point(562' 379);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Location = new System.Drawing.Point(562' 379);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Size = new System.Drawing.Size(108' 31);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.Size = new System.Drawing.Size(108' 31);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btCancel.TabIndex = 27;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(446' 379);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(446' 379);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(108' 31);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(108' 31);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.btDone.TabIndex = 26;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(14' 12);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(14' 12);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(654' 361);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(654' 361);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 28;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick12.Location = new System.Drawing.Point(562' 329);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick12.Location = new System.Drawing.Point(562' 329);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick12.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick12.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick12.TabIndex = 41;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick11.Location = new System.Drawing.Point(562' 301);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick11.Location = new System.Drawing.Point(562' 301);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick11.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick11.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick11.TabIndex = 40;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick10.Location = new System.Drawing.Point(562' 273);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick10.Location = new System.Drawing.Point(562' 273);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick10.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick10.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick10.TabIndex = 39;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick9.Location = new System.Drawing.Point(562' 245);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick9.Location = new System.Drawing.Point(562' 245);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick9.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick9.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick9.TabIndex = 38;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Location = new System.Drawing.Point(77' 301);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Location = new System.Drawing.Point(77' 301);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS11.TabIndex = 34;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(7' 332);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(7' 332);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 37;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Location = new System.Drawing.Point(77' 329);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Location = new System.Drawing.Point(77' 329);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS12.TabIndex = 36;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(7' 304);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(7' 304);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 35;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(7' 276);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(7' 276);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(63' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 33;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Location = new System.Drawing.Point(77' 273);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Location = new System.Drawing.Point(77' 273);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS10.TabIndex = 32;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(7' 248);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(7' 248);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 31;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Location = new System.Drawing.Point(77' 245);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Location = new System.Drawing.Point(77' 245);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS9.TabIndex = 30;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick8.Location = new System.Drawing.Point(562' 217);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick8.Location = new System.Drawing.Point(562' 217);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick8.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick8.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick8.TabIndex = 29;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick7.Location = new System.Drawing.Point(562' 189);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick7.Location = new System.Drawing.Point(562' 189);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick7.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick7.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick7.TabIndex = 28;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick6.Location = new System.Drawing.Point(562' 161);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick6.Location = new System.Drawing.Point(562' 161);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick6.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick6.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick6.TabIndex = 27;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick5.Location = new System.Drawing.Point(562' 133);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick5.Location = new System.Drawing.Point(562' 133);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick5.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick5.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick5.TabIndex = 26;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick4.Location = new System.Drawing.Point(562' 105);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick4.Location = new System.Drawing.Point(562' 105);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick4.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick4.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick4.TabIndex = 25;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick3.Location = new System.Drawing.Point(562' 77);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick3.Location = new System.Drawing.Point(562' 77);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick3.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick3.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick3.TabIndex = 24;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick2.Location = new System.Drawing.Point(562' 49);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick2.Location = new System.Drawing.Point(562' 49);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick2.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick2.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick2.TabIndex = 23;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick1.Location = new System.Drawing.Point(562' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick1.Location = new System.Drawing.Point(562' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick1.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick1.Size = new System.Drawing.Size(84' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.cbxStick1.TabIndex = 22;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Location = new System.Drawing.Point(77' 189);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Location = new System.Drawing.Point(77' 189);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS7.TabIndex = 18;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(7' 220);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(7' 220);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 21;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Location = new System.Drawing.Point(77' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Location = new System.Drawing.Point(77' 21);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS1.TabIndex = 6;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Location = new System.Drawing.Point(77' 217);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Location = new System.Drawing.Point(77' 217);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS8.TabIndex = 20;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(7' 24);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(7' 24);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 7;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(7' 192);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(7' 192);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 19;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Location = new System.Drawing.Point(77' 49);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Location = new System.Drawing.Point(77' 49);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS2.TabIndex = 8;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 52);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 52);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 9;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(7' 164);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(7' 164);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 17;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Location = new System.Drawing.Point(77' 77);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Location = new System.Drawing.Point(77' 77);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS3.TabIndex = 10;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Location = new System.Drawing.Point(77' 161);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Location = new System.Drawing.Point(77' 161);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS6.TabIndex = 16;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 80);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 80);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 11;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(7' 136);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(7' 136);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 15;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Location = new System.Drawing.Point(77' 105);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Location = new System.Drawing.Point(77' 105);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS4.TabIndex = 12;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Location = new System.Drawing.Point(77' 133);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Location = new System.Drawing.Point(77' 133);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.Size = new System.Drawing.Size(466' 22);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.txJS5.TabIndex = 14;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(7' 108);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(7' 108);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(57' 13);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 13;
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(682' 419);
Magic Number,SCJMapper_V2.Joystick,FormReassign,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\FormReassign.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(682' 419);
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JSNum,The following statement contains a magic number: if ( !string.IsNullOrWhiteSpace( jsTag ) ) {          // find jsN start           int jsPos = jsTag.IndexOf( "+js" );          if ( jsPos > 0 ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( jsPos + 3' 2 )' out retNum ) ) { // cheap .. test for double digits              if ( !int.TryParse( jsTag.Substring( jsPos + 3' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN; // neither double nor single digit found              }            }          } else if ( jsTag.StartsWith( "js" ) ) {            if ( !int.TryParse( ( jsTag + "XX" ).Substring( 2' 2 )' out retNum ) ) {  // cheap .. test for double digits ( have to extend the string to parse)              if ( !int.TryParse( jsTag.Substring( 2' 1 )' out retNum ) ) { // now for only single ones                retNum = JSnum_UNKNOWN;  // neither double nor single digit found              }            }          } else {            retNum = JSnum_UNKNOWN;  // neither double nor single digit found          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ReassignJSTag,The following statement contains a magic number: if ( IsJsN( input ) ) {          int inJsN = JSNum( input );          if ( inJsN < 10 ) {            return input.Replace( input.Substring( 0' 3 )' JSTag( newJsN ) );          } else {            // 2 digit input JsN            return input.Replace( input.Substring( 0' 4 )' JSTag( newJsN ) );          }        } else {          return input;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ReassignJSTag,The following statement contains a magic number: if ( IsJsN( input ) ) {          int inJsN = JSNum( input );          if ( inJsN < 10 ) {            return input.Replace( input.Substring( 0' 3 )' JSTag( newJsN ) );          } else {            // 2 digit input JsN            return input.Replace( input.Substring( 0' 4 )' JSTag( newJsN ) );          }        } else {          return input;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ReassignJSTag,The following statement contains a magic number: if ( IsJsN( input ) ) {          int inJsN = JSNum( input );          if ( inJsN < 10 ) {            return input.Replace( input.Substring( 0' 3 )' JSTag( newJsN ) );          } else {            // 2 digit input JsN            return input.Replace( input.Substring( 0' 4 )' JSTag( newJsN ) );          }        } else {          return input;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,MakeThrottle,The following statement contains a magic number: if ( control.Length < 5 ) return control;
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,MakeThrottle,The following statement contains a magic number: if ( rgx_jsl.IsMatch( control ) ) {          int inJsN = JSNum( control );          if ( inJsN < 10 ) {            retVal = retVal.Insert( 4' "throttle" );          } else {            // 2 digit input JsN            retVal = retVal.Insert( 5' "throttle" );          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,MakeThrottle,The following statement contains a magic number: if ( rgx_jsl.IsMatch( control ) ) {          int inJsN = JSNum( control );          if ( inJsN < 10 ) {            retVal = retVal.Insert( 4' "throttle" );          } else {            // 2 digit input JsN            retVal = retVal.Insert( 5' "throttle" );          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,MakeThrottle,The following statement contains a magic number: if ( rgx_jsl.IsMatch( control ) ) {          int inJsN = JSNum( control );          if ( inJsN < 10 ) {            retVal = retVal.Insert( 4' "throttle" );          } else {            // 2 digit input JsN            retVal = retVal.Insert( 5' "throttle" );          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,HatDir,The following statement contains a magic number: if ( value == 9000 ) return "right";
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,HatDir,The following statement contains a magic number: if ( value == 18000 ) return "down";
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,HatDir,The following statement contains a magic number: if ( value == 27000 ) return "left";
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JoystickCls,The following statement contains a magic number: m_device.Properties.BufferSize = 128;
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JoystickCls,The following statement contains a magic number: try {          // Set the data format to the c_dfDIJoystick pre-defined format.          //m_device.SetDataFormat( DeviceDataFormat.Joystick );          // Set the cooperative level for the device.          m_device.SetCooperativeLevel( m_hwnd' CooperativeLevel.NonExclusive | CooperativeLevel.Background );          // Enumerate all the objects on the device.          foreach ( DeviceObjectInstance d in m_device.GetObjects( ) ) {            // For axes that are returned' set the DIPROP_RANGE property for the            // enumerated axis in order to scale min/max values.            if ( ( 0 != ( d.ObjectId.Flags & DeviceObjectTypeFlags.Axis ) ) ) {              // Set the range for the axis.              m_device.Properties.Range = new InputRange( -1000' +1000 );            }            // Update the controls to reflect what objects the device supports.            UpdateControls( d );          }        } catch ( Exception ex ) {          log.Error( "Get JS Objects failed"' ex );        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,JoystickCls,The following statement contains a magic number: try {          // Set the data format to the c_dfDIJoystick pre-defined format.          //m_device.SetDataFormat( DeviceDataFormat.Joystick );          // Set the cooperative level for the device.          m_device.SetCooperativeLevel( m_hwnd' CooperativeLevel.NonExclusive | CooperativeLevel.Background );          // Enumerate all the objects on the device.          foreach ( DeviceObjectInstance d in m_device.GetObjects( ) ) {            // For axes that are returned' set the DIPROP_RANGE property for the            // enumerated axis in order to scale min/max values.            if ( ( 0 != ( d.ObjectId.Flags & DeviceObjectTypeFlags.Axis ) ) ) {              // Set the range for the axis.              m_device.Properties.Range = new InputRange( -1000' +1000 );            }            // Update the controls to reflect what objects the device supports.            UpdateControls( d );          }        } catch ( Exception ex ) {          log.Error( "Get JS Objects failed"' ex );        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,ApplySettings_low,The following statement contains a magic number: switch ( m_joystickNumber ) {          case 1: igs = appSettings.IgnoreJS1; break;          case 2: igs = appSettings.IgnoreJS2; break;          case 3: igs = appSettings.IgnoreJS3; break;          case 4: igs = appSettings.IgnoreJS4; break;          case 5: igs = appSettings.IgnoreJS5; break;          case 6: igs = appSettings.IgnoreJS6; break;          case 7: igs = appSettings.IgnoreJS7; break;          case 8: igs = appSettings.IgnoreJS8; break;          case 9: igs = appSettings.IgnoreJS9; break;          case 10: igs = appSettings.IgnoreJS10; break;          case 11: igs = appSettings.IgnoreJS11; break;          case 12: igs = appSettings.IgnoreJS12; break;          default: break;        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateModifier,The following statement contains a magic number: if ( jsn == m_joystickNumber ) {          // format is jsN_buttonM i.e. get button number at the end          int bNr = 0;          if ( int.TryParse( modS.Substring( 10 )' out bNr ) ) {            // valid bNr            m_modifierButtons[bNr - 1] = add; // update          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateControls,The following statement contains a magic number: if ( ObjectGuid.PovController == d.ObjectType ) {          switch ( m_numPOVs++ ) {            case 0:              m_jPanel.H1e = true;              m_jPanel.H1name = d.Name + ":";              break;              case 1:              m_jPanel.H2e = true;              m_jPanel.H2name = d.Name + ":";              break;              case 2:              m_jPanel.H3e = true;              m_jPanel.H3name = d.Name + ":";              break;              case 3:              m_jPanel.H4e = true;              m_jPanel.H4name = d.Name + ":";              break;          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateControls,The following statement contains a magic number: if ( ObjectGuid.PovController == d.ObjectType ) {          switch ( m_numPOVs++ ) {            case 0:              m_jPanel.H1e = true;              m_jPanel.H1name = d.Name + ":";              break;              case 1:              m_jPanel.H2e = true;              m_jPanel.H2name = d.Name + ":";              break;              case 2:              m_jPanel.H3e = true;              m_jPanel.H3name = d.Name + ":";              break;              case 3:              m_jPanel.H4e = true;              m_jPanel.H4name = d.Name + ":";              break;          }        }
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[2] >= 0 ) if ( pov[2] != ppov[2] ) m_lastItem = "hat3_" + HatDir( pov[2] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[2] >= 0 ) if ( pov[2] != ppov[2] ) m_lastItem = "hat3_" + HatDir( pov[2] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[2] >= 0 ) if ( pov[2] != ppov[2] ) m_lastItem = "hat3_" + HatDir( pov[2] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[2] >= 0 ) if ( pov[2] != ppov[2] ) m_lastItem = "hat3_" + HatDir( pov[2] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[3] >= 0 ) if ( pov[3] != ppov[3] ) m_lastItem = "hat4_" + HatDir( pov[3] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[3] >= 0 ) if ( pov[3] != ppov[3] ) m_lastItem = "hat4_" + HatDir( pov[3] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[3] >= 0 ) if ( pov[3] != ppov[3] ) m_lastItem = "hat4_" + HatDir( pov[3] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,GetLastChange,The following statement contains a magic number: if ( pov[3] >= 0 ) if ( pov[3] != ppov[3] ) m_lastItem = "hat4_" + HatDir( pov[3] );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,DidAxisChange,The following statement contains a magic number: return changepct > 70 ? true : false;
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateUI,The following statement contains a magic number: m_jPanel.H3 = pov[2].ToString( );
Magic Number,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateUI,The following statement contains a magic number: m_jPanel.H4 = pov[3].ToString( );
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,Chk,The following statement contains a magic number: if ( s.Length > 12 ) return s.Substring(0'12) ; else return s;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,Chk,The following statement contains a magic number: if ( s.Length > 12 ) return s.Substring(0'12) ; else return s;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Location = new System.Drawing.Point(3' 69);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Location = new System.Drawing.Point(3' 69);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Size = new System.Drawing.Size(261' 151);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.Size = new System.Drawing.Size(261' 151);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBox.TabIndex = 3;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Location = new System.Drawing.Point(65' 132);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Location = new System.Drawing.Point(65' 132);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Size = new System.Drawing.Size(154' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.Size = new System.Drawing.Size(154' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Buttons.TabIndex = 25;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Location = new System.Drawing.Point(9' 132);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Location = new System.Drawing.Point(9' 132);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Size = new System.Drawing.Size(46' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.Size = new System.Drawing.Size(46' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lB.TabIndex = 24;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat3.Location = new System.Drawing.Point(219' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat3.Location = new System.Drawing.Point(219' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat3.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat3.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat3.TabIndex = 23;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S1.Location = new System.Drawing.Point(219' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S1.Location = new System.Drawing.Point(219' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S1.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S1.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S1.TabIndex = 22;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S0.Location = new System.Drawing.Point(219' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S0.Location = new System.Drawing.Point(219' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S0.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S0.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1S0.TabIndex = 21;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat2.Location = new System.Drawing.Point(219' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat2.Location = new System.Drawing.Point(219' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat2.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat2.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat2.TabIndex = 20;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat1.Location = new System.Drawing.Point(219' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat1.Location = new System.Drawing.Point(219' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat1.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat1.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat1.TabIndex = 19;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat0.Location = new System.Drawing.Point(219' 64);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat0.Location = new System.Drawing.Point(219' 64);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat0.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat0.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Hat0.TabIndex = 18;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Zr.Location = new System.Drawing.Point(81' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Zr.Location = new System.Drawing.Point(81' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Zr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Zr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Zr.TabIndex = 17;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Yr.Location = new System.Drawing.Point(81' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Yr.Location = new System.Drawing.Point(81' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Yr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Yr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Yr.TabIndex = 16;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Xr.Location = new System.Drawing.Point(81' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Xr.Location = new System.Drawing.Point(81' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Xr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Xr.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Xr.TabIndex = 15;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Z.Location = new System.Drawing.Point(81' 56);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Z.Location = new System.Drawing.Point(81' 56);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Z.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Z.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Z.TabIndex = 14;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Y.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Y.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Y.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Y.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1Y.TabIndex = 13;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1X.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1X.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1X.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1X.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lbl1X.TabIndex = 12;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Location = new System.Drawing.Point(124' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Location = new System.Drawing.Point(124' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH3.TabIndex = 11;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Location = new System.Drawing.Point(124' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Location = new System.Drawing.Point(124' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH2.TabIndex = 10;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Location = new System.Drawing.Point(124' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Location = new System.Drawing.Point(124' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH1.TabIndex = 9;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Location = new System.Drawing.Point(124' 64);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Location = new System.Drawing.Point(124' 64);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.Size = new System.Drawing.Size(41' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lH0.TabIndex = 8;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS1.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS1.Location = new System.Drawing.Point(124' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS1.Size = new System.Drawing.Size(45' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS1.Size = new System.Drawing.Size(45' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS1.TabIndex = 7;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS0.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS0.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS0.Size = new System.Drawing.Size(45' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS0.Size = new System.Drawing.Size(45' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lS0.TabIndex = 6;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZr.Location = new System.Drawing.Point(9' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZr.Location = new System.Drawing.Point(9' 112);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZr.TabIndex = 5;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lYr.Location = new System.Drawing.Point(9' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lYr.Location = new System.Drawing.Point(9' 96);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lYr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lYr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lYr.TabIndex = 4;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lXr.Location = new System.Drawing.Point(9' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lXr.Location = new System.Drawing.Point(9' 80);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lXr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lXr.Size = new System.Drawing.Size(60' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lXr.TabIndex = 3;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZ.Location = new System.Drawing.Point(9' 56);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZ.Location = new System.Drawing.Point(9' 56);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZ.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZ.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lZ.TabIndex = 2;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lY.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lY.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lY.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lY.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lX.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lX.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lX.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lX.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Size = new System.Drawing.Size(261' 60);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.Size = new System.Drawing.Size(261' 60);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.gBoxCap.TabIndex = 4;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Location = new System.Drawing.Point(81' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnButtons.TabIndex = 14;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnPOVs.Location = new System.Drawing.Point(219' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnPOVs.Location = new System.Drawing.Point(219' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnPOVs.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnPOVs.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnPOVs.TabIndex = 14;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnAxis.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnAxis.Location = new System.Drawing.Point(81' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnAxis.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnAxis.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblnAxis.TabIndex = 14;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(9' 40);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(56' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 13;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(124' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(42' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(42' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 13;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(9' 24);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(39' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 13;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 226);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(3' 226);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(261' 46);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(261' 46);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 5;
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblJsAssignment.Location = new System.Drawing.Point(169' 21);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblJsAssignment.Location = new System.Drawing.Point(169' 21);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblJsAssignment.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.lblJsAssignment.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(9' 21);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(9' 21);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(119' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(119' 13);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(271' 278);
Magic Number,SCJMapper_V2.Joystick,UC_JoyPanel,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\UC_JoyPanel.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(271' 278);
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Setup,The following statement contains a magic number: if ( ( dimension < 1 ) || ( dimension > 3 ) ) return;
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Setup,The following statement contains a magic number: m_Npoints = dimension + 2;
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Setup,The following statement contains a magic number: switch ( dimension ) {          case 1: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.5f' 0.5f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            case 2: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.333333f' 0.333333f );              m_points[i++] = new Vector2( 0.666667f' 0.666667f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            case 3: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.25f' 0.25f );              m_points[i++] = new Vector2( 0.5f' 0.5f );              m_points[i++] = new Vector2( 0.75f' 0.75f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            default: {              // does not get here              break;            }        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Setup,The following statement contains a magic number: switch ( dimension ) {          case 1: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.5f' 0.5f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            case 2: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.333333f' 0.333333f );              m_points[i++] = new Vector2( 0.666667f' 0.666667f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            case 3: {              m_points[i++] = new Vector2( 0f' 0f );              m_points[i++] = new Vector2( 0.25f' 0.25f );              m_points[i++] = new Vector2( 0.5f' 0.5f );              m_points[i++] = new Vector2( 0.75f' 0.75f );              m_points[i++] = new Vector2( 1.0f' 1.0f );              break;            }            default: {              // does not get here              break;            }        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,GetOutput,The following statement contains a magic number: for ( int i = 1; i < m_maxpts; i++ ) {          double sense = i / ( double )m_maxpts;          while ( ( input[idx] < sense ) && ( idx < ( ( m_maxpts - 1 ) * 2 ) ) ) idx += 2;          m_outCurve[i] = input[idx + 1];          idx = ( idx < ( m_maxpts * 2 ) ) ? idx : ( m_maxpts - 1 ) * 2; // we shall not overrun...        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,GetOutput,The following statement contains a magic number: for ( int i = 1; i < m_maxpts; i++ ) {          double sense = i / ( double )m_maxpts;          while ( ( input[idx] < sense ) && ( idx < ( ( m_maxpts - 1 ) * 2 ) ) ) idx += 2;          m_outCurve[i] = input[idx + 1];          idx = ( idx < ( m_maxpts * 2 ) ) ? idx : ( m_maxpts - 1 ) * 2; // we shall not overrun...        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,GetOutput,The following statement contains a magic number: for ( int i = 1; i < m_maxpts; i++ ) {          double sense = i / ( double )m_maxpts;          while ( ( input[idx] < sense ) && ( idx < ( ( m_maxpts - 1 ) * 2 ) ) ) idx += 2;          m_outCurve[i] = input[idx + 1];          idx = ( idx < ( m_maxpts * 2 ) ) ? idx : ( m_maxpts - 1 ) * 2; // we shall not overrun...        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,GetOutput,The following statement contains a magic number: for ( int i = 1; i < m_maxpts; i++ ) {          double sense = i / ( double )m_maxpts;          while ( ( input[idx] < sense ) && ( idx < ( ( m_maxpts - 1 ) * 2 ) ) ) idx += 2;          m_outCurve[i] = input[idx + 1];          idx = ( idx < ( m_maxpts * 2 ) ) ? idx : ( m_maxpts - 1 ) * 2; // we shall not overrun...        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Pt,The following statement contains a magic number: if ( index >= (m_points.Length-2) ) return new Vector2( 0' 0 );
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: float[] cout = new float[m_maxpts * 2];
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;         }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;         }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: float[] cout = new float[m_maxpts * 2];
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: Setup( 2 );
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: float[] cout = new float[m_maxpts * 2];
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: Setup( 3 );
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: float[] cout = new float[m_maxpts * 2];
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Joystick,xyPoints,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\xyPoints.cs,Curve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = m_curve.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.Keyboard,KeyboardCls,C:\repos\SCToolsfactory_SCJMapper-V2\Keyboard\KeyboardCls.cs,KeyboardCls,The following statement contains a magic number: m_device.Properties.BufferSize = 128;
Magic Number,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,MouseCls,The following statement contains a magic number: m_device.Properties.BufferSize = 128;
Magic Number,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,DidAxisChange2,The following statement contains a magic number: if ( posAxis && ( current - prev ) > 0 )          return change > 2 ? true : false;        else if ( ( !posAxis ) && ( current - prev ) < 0 )          return change > 2 ? true : false;        else          return false;
Magic Number,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,DidAxisChange2,The following statement contains a magic number: if ( posAxis && ( current - prev ) > 0 )          return change > 2 ? true : false;        else if ( ( !posAxis ) && ( current - prev ) < 0 )          return change > 2 ? true : false;        else          return false;
Magic Number,SCJMapper_V2.OGL,BezierSeries,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\BezierSeries.cs,Invalidate,The following statement contains a magic number: float[] cout = new float[PointsOnCurve*2];
Magic Number,SCJMapper_V2.OGL,BezierSeries,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\BezierSeries.cs,Invalidate,The following statement contains a magic number: for ( int i = 0; i < cout.Length; i = i + 2 ) {          this.Points.AddXY( cout[i]' cout[i + 1] );        }
Magic Number,SCJMapper_V2.OGL,BezierSeries,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\BezierSeries.cs,CalcCurve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = bc.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.OGL,BezierSeries,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\BezierSeries.cs,CalcCurve,The following statement contains a magic number: for ( int p = 0; p <= resolution; p++ ) {          pos = bc.CalculatePoint( ( float )p / ( float )resolution );          cout[p * 2] = pos.X; cout[p * 2 + 1] = pos.Y;        }
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,BezierInterpolation,The following statement contains a magic number: nPts = m_points.Count - 2;
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,BezierInterpolation,The following statement contains a magic number: for ( int i= 0; i < segPts; i++ ) {          double t1 = 1.0 - t;          double t12 = t1 * t1;          double t2 = t * t;            B0[i] = t1 * t12; B1[i] = 3.0 * t * t12; B2[i] = 3.0 * t2 * t1; B3[i] = t * t2;            t += increment;        }
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,BezierInterpolation,The following statement contains a magic number: for ( int i= 0; i < segPts; i++ ) {          double t1 = 1.0 - t;          double t12 = t1 * t1;          double t2 = t * t;            B0[i] = t1 * t12; B1[i] = 3.0 * t * t12; B2[i] = 3.0 * t2 * t1; B3[i] = t * t2;            t += increment;        }
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: d[nPts - 1].X = ( m_points[nPts - 1].X - m_points[nPts - 2].X ) / 3f;
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: d[nPts - 1].Y = ( m_points[nPts - 1].Y - m_points[nPts - 2].Y ) / 3f;
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: A[1].X = ( m_points[2].X - m_points[0].X - d[0].X ) / 4f;
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: A[1].Y = ( m_points[2].Y - m_points[0].Y - d[0].Y ) / 4f;
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: for ( int i = 2; i < nPts - 1; i++ ) {          Bi[i] = -1.0f / ( 4.0f + Bi[i - 1] );          A[i].X = -( m_points[i + 1].X - m_points[i - 1].X - A[i - 1].X ) * Bi[i];          A[i].Y = -( m_points[i + 1].Y - m_points[i - 1].Y - A[i - 1].Y ) * Bi[i];        }
Magic Number,SCJMapper_V2.OGL,BezierInterpolation,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CalcBezierCurve.cs,findCPoints,The following statement contains a magic number: for ( var i = nPts - 2; i > 0; i-- ) {          d[i].X = A[i].X + d[i + 1].X * Bi[i];          d[i].Y = A[i].Y + d[i + 1].Y * Bi[i];        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,GetNextXIndex,The following statement contains a magic number: while ((_lastIndex < xOrig.Length - 2) && (x > xOrig[_lastIndex + 1]))        {          _lastIndex++;        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Fit,The following statement contains a magic number: if (float.IsNaN(startSlope))        {          dx1 = x[1] - x[0];          m.C[0] = 1.0f / dx1;          m.B[0] = 2.0f * m.C[0];          r[0] = 3 * (y[1] - y[0]) / (dx1 * dx1);        }        else        {          m.B[0] = 1;          r[0] = startSlope;        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Fit,The following statement contains a magic number: for (int i = 1; i < n - 1; i++)        {          dx1 = x[i] - x[i - 1];          dx2 = x[i + 1] - x[i];            m.A[i] = 1.0f / dx1;          m.C[i] = 1.0f / dx2;          m.B[i] = 2.0f * (m.A[i] + m.C[i]);            dy1 = y[i] - y[i - 1];          dy2 = y[i + 1] - y[i];          r[i] = 3 * (dy1 / (dx1 * dx1) + dy2 / (dx2 * dx2));        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Fit,The following statement contains a magic number: if (float.IsNaN(endSlope))        {          dx1 = x[n - 1] - x[n - 2];          dy1 = y[n - 1] - y[n - 2];          m.A[n - 1] = 1.0f / dx1;          m.B[n - 1] = 2.0f * m.A[n - 1];          r[n - 1] = 3 * (dy1 / (dx1 * dx1));        }        else        {          m.B[n - 1] = 1;          r[n - 1] = endSlope;        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Fit,The following statement contains a magic number: if (float.IsNaN(endSlope))        {          dx1 = x[n - 1] - x[n - 2];          dy1 = y[n - 1] - y[n - 2];          m.A[n - 1] = 1.0f / dx1;          m.B[n - 1] = 2.0f * m.A[n - 1];          r[n - 1] = 3 * (dy1 / (dx1 * dx1));        }        else        {          m.B[n - 1] = 1;          r[n - 1] = endSlope;        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,Fit,The following statement contains a magic number: if (float.IsNaN(endSlope))        {          dx1 = x[n - 1] - x[n - 2];          dy1 = y[n - 1] - y[n - 2];          m.A[n - 1] = 1.0f / dx1;          m.B[n - 1] = 2.0f * m.A[n - 1];          r[n - 1] = 3 * (dy1 / (dx1 * dx1));        }        else        {          m.B[n - 1] = 1;          r[n - 1] = endSlope;        }
Magic Number,SCJMapper_V2.OGL,CubicSpline,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\CubicSpline.cs,EvalSlope,The following statement contains a magic number: for (int i = 0; i < n; i++)        {          // Find which spline can be used to compute this x (by simultaneous traverse)          int j = GetNextXIndex(x[i]);            // Evaluate using j'th spline          float dx = xOrig[j + 1] - xOrig[j];          float dy = yOrig[j + 1] - yOrig[j];          float t = (x[i] - xOrig[j]) / dx;            // From equation 5 we could also compute q' (qp) which is the slope at this x          qPrime[i] = dy / dx            + (1 - 2 * t) * (a[j] * (1 - t) + b[j] * t) / dx            + t * (1 - t) * (b[j] - a[j]) / dx;          }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  m_bSeries.BezierPoints.Add(new DataPoint(0' 0));              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.25' 0.25);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.25' 0.25);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.5' 0.5);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.5' 0.5);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.75' 0.75);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,FormJSCalCurve,The following statement contains a magic number: chart1.Series[1].Points.AddXY(0.75' 0.75);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,YawUpdateGUIFromLiveValues,The following statement contains a magic number: lblYin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,YawUpdateGUIFromLiveValues,The following statement contains a magic number: lblYout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,PitchUpdateGUIFromLiveValues,The following statement contains a magic number: lblPin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,PitchUpdateGUIFromLiveValues,The following statement contains a magic number: lblPout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,RollUpdateGUIFromLiveValues,The following statement contains a magic number: lblRin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,RollUpdateGUIFromLiveValues,The following statement contains a magic number: lblRout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeLatUpdateGUIFromLiveValues,The following statement contains a magic number: lblYin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeLatUpdateGUIFromLiveValues,The following statement contains a magic number: lblYout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeVertUpdateGUIFromLiveValues,The following statement contains a magic number: lblPin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeVertUpdateGUIFromLiveValues,The following statement contains a magic number: lblPout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeLonUpdateGUIFromLiveValues,The following statement contains a magic number: lblRin3.Text = lv.nonLinCurve.Pt(2).X.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,StrafeLonUpdateGUIFromLiveValues,The following statement contains a magic number: lblRout3.Text = lv.nonLinCurve.Pt(2).Y.ToString("0.000");
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,glControl1_Load,The following statement contains a magic number: if (!GL.GetString(StringName.Extensions).Contains("GL_ARB_shading_language"))              {                  log.ErrorFormat("glControl1_Load - This program requires OpenGL 2.0. Found {0}. Aborting."' GL.GetString(StringName.Version).Substring(0' 3));                    throw new NotSupportedException(string.Format("This program requires OpenGL 2.0. Found {0}. Aborting."'                      GL.GetString(StringName.Version).Substring(0' 3)));              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,glControl1_Load,The following statement contains a magic number: if (!GL.GetString(StringName.Extensions).Contains("GL_ARB_shading_language"))              {                  log.ErrorFormat("glControl1_Load - This program requires OpenGL 2.0. Found {0}. Aborting."' GL.GetString(StringName.Version).Substring(0' 3));                    throw new NotSupportedException(string.Format("This program requires OpenGL 2.0. Found {0}. Aborting."'                      GL.GetString(StringName.Version).Substring(0' 3)));              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_Strafe,The following statement contains a magic number: if (lat)              {                  double fout = m_liveStrafeLat.ScaledOut(x); // 0 .. 1000.0                  lblYInput.Text = (i_x / 1000.0).ToString("0.00"); lblYOutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.X = m_liveStrafeLat.InvertedSign * ((!cbYuse.Checked) ? fout : 0) * m_msElapsed * DegPerMS;              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_Strafe,The following statement contains a magic number: if (vert)              {                  double fout = m_liveStrafeVert.ScaledOut(y); // 0 .. 1000.0                  lblPInput.Text = (i_y / 1000.0).ToString("0.00"); lblPOutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.Y = m_liveStrafeVert.InvertedSign * ((!cbPuse.Checked) ? fout : 0) * m_msElapsed * DegPerMS;              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_Strafe,The following statement contains a magic number: if (lon)              {                  double fout = m_liveStrafeLon.ScaledOut(z); // 0 .. 1000.0                  lblRInput.Text = (i_z / 1000.0).ToString("0.00"); lblROutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.Z = m_liveStrafeLon.InvertedSign * ((!cbRuse.Checked) ? fout : 0) * m_msElapsed * DegPerMS;              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_YPR,The following statement contains a magic number: if (yaw)              {                  double fout = m_liveYaw.ScaledOut(x); // 0 .. 1000.0                  lblYInput.Text = (i_x / 1000.0).ToString("0.00"); lblYOutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.X = m_liveYaw.InvertedSign * ((!cbYuse.Checked) ? fout : 0) * m_msElapsed * DegPerMS;              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_YPR,The following statement contains a magic number: if (pitch)              {                  double fout = m_livePitch.ScaledOut(y); // 0 .. 1000.0                  lblPInput.Text = (i_y / 1000.0).ToString("0.00"); lblPOutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.Y = m_livePitch.InvertedSign * ((!cbPuse.Checked) ? -fout : 0) * m_msElapsed * DegPerMS; // 20170801: fix - Must use inverted out value              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Idle_YPR,The following statement contains a magic number: if (roll)              {                  double fout = m_liveRoll.ScaledOut(z); // 0 .. 1000.0                  lblRInput.Text = (i_z / 1000.0).ToString("0.00"); lblROutput.Text = (fout).ToString("0.00");                  // calculate new direction vector                  m.Z = m_liveRoll.InvertedSign * ((!cbRuse.Checked) ? fout : 0) * m_msElapsed * DegPerMS;              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Application_Idle,The following statement contains a magic number: while (glControl1.IsIdle)              {                  Vector3d m = Vector3d.Zero; ;                  // calculate the aim change while the user is handling the control (integrating the amount of control)                  Int64 newTick = DateTime.Now.Ticks;                  m_msElapsed = (newTick - m_ticks) / TimeSpan.TicksPerMillisecond;                  if (m_msElapsed < m_frameTime)                  {                      // lblDebug.Text = "F";                      continue; //pace updates the max frametime allowed                  }                  //lblDebug.Text = "R";                    // safeguard against locking (moving the window) so the integrator does not get crazy..                  // if deltatime gets too big we fake a regular cycle for this round                  if (m_msElapsed > 200) m_msElapsed = m_frameTime;                    m_ticks = newTick; // prep next run                    // query the Joysticks for the 3 controls and fill the flight model vector                  if (m_isStrafe)                  {                      m = Idle_Strafe();                  }                  else                  {                      m = Idle_YPR();                  }                    // finalize                  m_flightModel.Velocity -= m; // new direction change vector                  Vector3d deltaAngleV = m_flightModel.Integrate((double)m_msElapsed / 1000.0' m_damping' 85.0); // heuristic K and B ..                    // rotate the view along the input                   // rotDeg( m );                  rotDeg(deltaAngleV);                    // render once more                  Render();                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Application_Idle,The following statement contains a magic number: while (glControl1.IsIdle)              {                  Vector3d m = Vector3d.Zero; ;                  // calculate the aim change while the user is handling the control (integrating the amount of control)                  Int64 newTick = DateTime.Now.Ticks;                  m_msElapsed = (newTick - m_ticks) / TimeSpan.TicksPerMillisecond;                  if (m_msElapsed < m_frameTime)                  {                      // lblDebug.Text = "F";                      continue; //pace updates the max frametime allowed                  }                  //lblDebug.Text = "R";                    // safeguard against locking (moving the window) so the integrator does not get crazy..                  // if deltatime gets too big we fake a regular cycle for this round                  if (m_msElapsed > 200) m_msElapsed = m_frameTime;                    m_ticks = newTick; // prep next run                    // query the Joysticks for the 3 controls and fill the flight model vector                  if (m_isStrafe)                  {                      m = Idle_Strafe();                  }                  else                  {                      m = Idle_YPR();                  }                    // finalize                  m_flightModel.Velocity -= m; // new direction change vector                  Vector3d deltaAngleV = m_flightModel.Integrate((double)m_msElapsed / 1000.0' m_damping' 85.0); // heuristic K and B ..                    // rotate the view along the input                   // rotDeg( m );                  rotDeg(deltaAngleV);                    // render once more                  Render();                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Application_Idle,The following statement contains a magic number: while (glControl1.IsIdle)              {                  Vector3d m = Vector3d.Zero; ;                  // calculate the aim change while the user is handling the control (integrating the amount of control)                  Int64 newTick = DateTime.Now.Ticks;                  m_msElapsed = (newTick - m_ticks) / TimeSpan.TicksPerMillisecond;                  if (m_msElapsed < m_frameTime)                  {                      // lblDebug.Text = "F";                      continue; //pace updates the max frametime allowed                  }                  //lblDebug.Text = "R";                    // safeguard against locking (moving the window) so the integrator does not get crazy..                  // if deltatime gets too big we fake a regular cycle for this round                  if (m_msElapsed > 200) m_msElapsed = m_frameTime;                    m_ticks = newTick; // prep next run                    // query the Joysticks for the 3 controls and fill the flight model vector                  if (m_isStrafe)                  {                      m = Idle_Strafe();                  }                  else                  {                      m = Idle_YPR();                  }                    // finalize                  m_flightModel.Velocity -= m; // new direction change vector                  Vector3d deltaAngleV = m_flightModel.Integrate((double)m_msElapsed / 1000.0' m_damping' 85.0); // heuristic K and B ..                    // rotate the view along the input                   // rotDeg( m );                  rotDeg(deltaAngleV);                    // render once more                  Render();                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbAurora_CheckedChanged,The following statement contains a magic number: slDamping.Value = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbAurora_CheckedChanged,The following statement contains a magic number: slTurnSpeed.Value = 10;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rb300i_CheckedChanged,The following statement contains a magic number: slDamping.Value = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rb300i_CheckedChanged,The following statement contains a magic number: slTurnSpeed.Value = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbHornet_CheckedChanged,The following statement contains a magic number: slDamping.Value = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbHornet_CheckedChanged,The following statement contains a magic number: slTurnSpeed.Value = 12;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,slTurnSpeed_ValueChanged,The following statement contains a magic number: DegPerMS = 360.0 / (slTurnSpeed.Value * 500.0);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,slTurnSpeed_ValueChanged,The following statement contains a magic number: DegPerMS = 360.0 / (slTurnSpeed.Value * 500.0);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,slTurnSpeed_ValueChanged,The following statement contains a magic number: lblTurnspeed.Text = (slTurnSpeed.Value / 2.0).ToString();
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,slDamping_ValueChanged,The following statement contains a magic number: m_damping = (slDamping.Maximum - slDamping.Value + 1) * 100.0;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbY_CheckedChanged,The following statement contains a magic number: if (rbY.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblYin1.Text; lblIn[2].Text = lblYin2.Text; lblIn[3].Text = lblYin3.Text;                  lblOut[1].Text = lblYout1.Text; lblOut[2].Text = lblYout2.Text; lblOut[3].Text = lblYout3.Text;                  lblOut[4].Text = lblYexponent.Text;                  lblNodetext.Text = lblYnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxYdeadzone.Checked;                  rbPtSaturation.Enabled = cbxYsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblYdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true;                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblYsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbY_CheckedChanged,The following statement contains a magic number: if (rbY.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblYin1.Text; lblIn[2].Text = lblYin2.Text; lblIn[3].Text = lblYin3.Text;                  lblOut[1].Text = lblYout1.Text; lblOut[2].Text = lblYout2.Text; lblOut[3].Text = lblYout3.Text;                  lblOut[4].Text = lblYexponent.Text;                  lblNodetext.Text = lblYnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxYdeadzone.Checked;                  rbPtSaturation.Enabled = cbxYsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblYdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true;                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblYsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbY_CheckedChanged,The following statement contains a magic number: if (rbY.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblYin1.Text; lblIn[2].Text = lblYin2.Text; lblIn[3].Text = lblYin3.Text;                  lblOut[1].Text = lblYout1.Text; lblOut[2].Text = lblYout2.Text; lblOut[3].Text = lblYout3.Text;                  lblOut[4].Text = lblYexponent.Text;                  lblNodetext.Text = lblYnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxYdeadzone.Checked;                  rbPtSaturation.Enabled = cbxYsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblYdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true;                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblYsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbY_CheckedChanged,The following statement contains a magic number: if (rbY.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblYin1.Text; lblIn[2].Text = lblYin2.Text; lblIn[3].Text = lblYin3.Text;                  lblOut[1].Text = lblYout1.Text; lblOut[2].Text = lblYout2.Text; lblOut[3].Text = lblYout3.Text;                  lblOut[4].Text = lblYexponent.Text;                  lblNodetext.Text = lblYnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxYdeadzone.Checked;                  rbPtSaturation.Enabled = cbxYsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblYdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true;                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblYsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbY_CheckedChanged,The following statement contains a magic number: if (rbY.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblYin1.Text; lblIn[2].Text = lblYin2.Text; lblIn[3].Text = lblYin3.Text;                  lblOut[1].Text = lblYout1.Text; lblOut[2].Text = lblYout2.Text; lblOut[3].Text = lblYout3.Text;                  lblOut[4].Text = lblYexponent.Text;                  lblNodetext.Text = lblYnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxYdeadzone.Checked;                  rbPtSaturation.Enabled = cbxYsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblYdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true;                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblYsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbP_CheckedChanged,The following statement contains a magic number: if (rbP.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblPin1.Text; lblIn[2].Text = lblPin2.Text; lblIn[3].Text = lblPin3.Text;                  lblOut[1].Text = lblPout1.Text; lblOut[2].Text = lblPout2.Text; lblOut[3].Text = lblPout3.Text;                  lblOut[4].Text = lblPexponent.Text;                  lblNodetext.Text = lblPnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxPdeadzone.Checked;                  rbPtSaturation.Enabled = cbxPsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblPdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblPsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbP_CheckedChanged,The following statement contains a magic number: if (rbP.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblPin1.Text; lblIn[2].Text = lblPin2.Text; lblIn[3].Text = lblPin3.Text;                  lblOut[1].Text = lblPout1.Text; lblOut[2].Text = lblPout2.Text; lblOut[3].Text = lblPout3.Text;                  lblOut[4].Text = lblPexponent.Text;                  lblNodetext.Text = lblPnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxPdeadzone.Checked;                  rbPtSaturation.Enabled = cbxPsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblPdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblPsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbP_CheckedChanged,The following statement contains a magic number: if (rbP.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblPin1.Text; lblIn[2].Text = lblPin2.Text; lblIn[3].Text = lblPin3.Text;                  lblOut[1].Text = lblPout1.Text; lblOut[2].Text = lblPout2.Text; lblOut[3].Text = lblPout3.Text;                  lblOut[4].Text = lblPexponent.Text;                  lblNodetext.Text = lblPnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxPdeadzone.Checked;                  rbPtSaturation.Enabled = cbxPsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblPdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblPsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbP_CheckedChanged,The following statement contains a magic number: if (rbP.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblPin1.Text; lblIn[2].Text = lblPin2.Text; lblIn[3].Text = lblPin3.Text;                  lblOut[1].Text = lblPout1.Text; lblOut[2].Text = lblPout2.Text; lblOut[3].Text = lblPout3.Text;                  lblOut[4].Text = lblPexponent.Text;                  lblNodetext.Text = lblPnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxPdeadzone.Checked;                  rbPtSaturation.Enabled = cbxPsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblPdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblPsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbP_CheckedChanged,The following statement contains a magic number: if (rbP.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblPin1.Text; lblIn[2].Text = lblPin2.Text; lblIn[3].Text = lblPin3.Text;                  lblOut[1].Text = lblPout1.Text; lblOut[2].Text = lblPout2.Text; lblOut[3].Text = lblPout3.Text;                  lblOut[4].Text = lblPexponent.Text;                  lblNodetext.Text = lblPnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxPdeadzone.Checked;                  rbPtSaturation.Enabled = cbxPsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblPdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblPsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbR_CheckedChanged,The following statement contains a magic number: if (rbR.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblRin1.Text; lblIn[2].Text = lblRin2.Text; lblIn[3].Text = lblRin3.Text;                  lblOut[1].Text = lblRout1.Text; lblOut[2].Text = lblRout2.Text; lblOut[3].Text = lblRout3.Text;                  lblOut[4].Text = lblRexponent.Text;                  lblNodetext.Text = lblRnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxRdeadzone.Checked;                  rbPtSaturation.Enabled = cbxRsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblRdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblRsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbR_CheckedChanged,The following statement contains a magic number: if (rbR.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblRin1.Text; lblIn[2].Text = lblRin2.Text; lblIn[3].Text = lblRin3.Text;                  lblOut[1].Text = lblRout1.Text; lblOut[2].Text = lblRout2.Text; lblOut[3].Text = lblRout3.Text;                  lblOut[4].Text = lblRexponent.Text;                  lblNodetext.Text = lblRnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxRdeadzone.Checked;                  rbPtSaturation.Enabled = cbxRsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblRdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblRsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbR_CheckedChanged,The following statement contains a magic number: if (rbR.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblRin1.Text; lblIn[2].Text = lblRin2.Text; lblIn[3].Text = lblRin3.Text;                  lblOut[1].Text = lblRout1.Text; lblOut[2].Text = lblRout2.Text; lblOut[3].Text = lblRout3.Text;                  lblOut[4].Text = lblRexponent.Text;                  lblNodetext.Text = lblRnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxRdeadzone.Checked;                  rbPtSaturation.Enabled = cbxRsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblRdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblRsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbR_CheckedChanged,The following statement contains a magic number: if (rbR.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblRin1.Text; lblIn[2].Text = lblRin2.Text; lblIn[3].Text = lblRin3.Text;                  lblOut[1].Text = lblRout1.Text; lblOut[2].Text = lblRout2.Text; lblOut[3].Text = lblRout3.Text;                  lblOut[4].Text = lblRexponent.Text;                  lblNodetext.Text = lblRnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxRdeadzone.Checked;                  rbPtSaturation.Enabled = cbxRsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblRdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblRsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,rbR_CheckedChanged,The following statement contains a magic number: if (rbR.Checked == true)              {                  // get Labels from left area (current)                  lblIn[1].Text = lblRin1.Text; lblIn[2].Text = lblRin2.Text; lblIn[3].Text = lblRin3.Text;                  lblOut[1].Text = lblRout1.Text; lblOut[2].Text = lblRout2.Text; lblOut[3].Text = lblRout3.Text;                  lblOut[4].Text = lblRexponent.Text;                  lblNodetext.Text = lblRnt.Text;                  // setup chart along the choosen parameter                  rbPtDeadzone.Enabled = cbxRdeadzone.Checked;                  rbPtSaturation.Enabled = cbxRsat.Checked;                    rbPtDeadzone.Checked = true;                  if (rbPtDeadzone.Enabled)                  {                      tbSlider.Value = Deviceoptions.DeadzoneToSlider(lblRdeadzone.Text);                  }                  else                  {                      rbPtSaturation.Checked = true; // force back to sense (available for both..)                      if (rbPtSaturation.Enabled)                      {                          tbSlider.Value = Deviceoptions.SaturationToSlider(lblRsat.Text);                      }                  }                  UpdateChartItems();              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,EvalChartInput,The following statement contains a magic number: if (rbPt2.Enabled && rbPt2.Checked) m_hitPt = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,EvalChartInput,The following statement contains a magic number: if (rbPt3.Enabled && rbPt3.Checked) m_hitPt = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,EvalChartInput,The following statement contains a magic number: if (rbPtExponent.Enabled && rbPtExponent.Checked) m_hitPt = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: if (expUsed)              {                  // Exp mode                  double expo = double.Parse(lblOut[4].Text);                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' expo));                  m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' expo));                  m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' expo));                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else if (ptsUsed)              {                  // Pts mode                  // dont touch zero Point                  for (int i = 1; i <= 3; i++)                  {                      m_bSeries.BezierPoints[i].SetValueXY(float.Parse(lblIn[i].Text)' float.Parse(lblOut[i].Text));                  }                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);                }              else              {                  // linear                  // dont touch zero Point                  m_bSeries.BezierPoints[1].SetValueXY(0.25' 0.25);                  m_bSeries.BezierPoints[2].SetValueXY(0.5' 0.5);                  m_bSeries.BezierPoints[3].SetValueXY(0.75' 0.75);                  m_bSeries.BezierPoints[4].SetValueXY(1.0' 1.0);              }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,UpdateChartItems,The following statement contains a magic number: chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseMove,The following statement contains a magic number: if (m_hitActive)              {                  if (m_hitPt < 1)                  {                      // nothing selected ...                  }                  else if (m_hitPt <= 3)                  {                      // Pt1..3                      double newX = double.Parse(lblIn[m_hitPt].Text) + (e.X - mX) * 0.001f; mX = e.X;                      newX = (newX > 1.0f) ? 1.0f : newX;                      newX = (newX < 0.0f) ? 0.0f : newX;                      lblIn[m_hitPt].Text = newX.ToString("0.000");                        double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * -0.001f; mY = e.Y;                      newY = (newY > 1.0f) ? 1.0f : newY;                      newY = (newY < 0.0f) ? 0.0f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.000");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[m_hitPt].SetValueXY(newX' newY);                      // update markers from curve points                      chart1.Series[1].Points[m_hitPt] = m_bSeries.BezierPoints[m_hitPt];                    }                  else if (m_hitPt == 4)                  {                      // Exponent                      double newY = double.Parse(lblOut[m_hitPt].Text) + (e.Y - mY) * 0.01f; mY = e.Y;                      newY = (newY > 3.0f) ? 3.0f : newY;                      newY = (newY < 0.5f) ? 0.5f : newY;                      lblOut[m_hitPt].Text = newY.ToString("0.00");                        // update chart (Points[0] is zero)                      m_bSeries.BezierPoints[1].SetValueXY(0.25' Math.Pow(0.25' newY));                      m_bSeries.BezierPoints[2].SetValueXY(0.5' Math.Pow(0.5' newY));                      m_bSeries.BezierPoints[3].SetValueXY(0.75' Math.Pow(0.75' newY));                  }                    // update markers from curve points                  chart1.Series[1].Points[1] = m_bSeries.BezierPoints[1];                  chart1.Series[1].Points[2] = m_bSeries.BezierPoints[2];                  chart1.Series[1].Points[3] = m_bSeries.BezierPoints[3];                  chart1.Series[1].Points[4] = m_bSeries.BezierPoints[4];                    m_bSeries.Invalidate(chart1);                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,chartPoint_MouseUp,The following statement contains a magic number: if (rbY.Checked == true)              {                  // left area labels                  lblYin1.Text = lblIn[1].Text; lblYin2.Text = lblIn[2].Text; lblYin3.Text = lblIn[3].Text;                  lblYout1.Text = lblOut[1].Text; lblYout2.Text = lblOut[2].Text; lblYout3.Text = lblOut[3].Text;                  lblYexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLat.exponentS = lblYexponent.Text;                      if (m_liveStrafeLat.nonLinCurve != null)                      {                          m_liveStrafeLat.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                  else                  {                      m_liveYaw.exponentS = lblYexponent.Text;                      if (m_liveYaw.nonLinCurve != null)                      {                          m_liveYaw.nonLinCurve.Curve(float.Parse(lblYin1.Text)' float.Parse(lblYout1.Text)'                                                float.Parse(lblYin2.Text)' float.Parse(lblYout2.Text)'                                                float.Parse(lblYin3.Text)' float.Parse(lblYout3.Text));                      }                  }                }              else if (rbP.Checked == true)              {                  // left area labels                  lblPin1.Text = lblIn[1].Text; lblPin2.Text = lblIn[2].Text; lblPin3.Text = lblIn[3].Text;                  lblPout1.Text = lblOut[1].Text; lblPout2.Text = lblOut[2].Text; lblPout3.Text = lblOut[3].Text;                  lblPexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeVert.exponentS = lblPexponent.Text;                      if (m_liveStrafeVert.nonLinCurve != null)                      {                          m_liveStrafeVert.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                  else                  {                      m_livePitch.exponentS = lblPexponent.Text;                      if (m_livePitch.nonLinCurve != null)                      {                          m_livePitch.nonLinCurve.Curve(float.Parse(lblPin1.Text)' float.Parse(lblPout1.Text)'                                                float.Parse(lblPin2.Text)' float.Parse(lblPout2.Text)'                                                float.Parse(lblPin3.Text)' float.Parse(lblPout3.Text));                      }                  }                }              else if (rbR.Checked == true)              {                  // left area labels                  lblRin1.Text = lblIn[1].Text; lblRin2.Text = lblIn[2].Text; lblRin3.Text = lblIn[3].Text;                  lblRout1.Text = lblOut[1].Text; lblRout2.Text = lblOut[2].Text; lblRout3.Text = lblOut[3].Text;                  lblRexponent.Text = lblOut[4].Text;                  // update live values                  if (m_isStrafe)                  {                      m_liveStrafeLon.exponentS = lblRexponent.Text;                      if (m_liveStrafeLon.nonLinCurve != null)                      {                          m_liveStrafeLon.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                  else                  {                      m_liveRoll.exponentS = lblRexponent.Text;                      if (m_liveRoll.nonLinCurve != null)                      {                          m_liveRoll.nonLinCurve.Curve(float.Parse(lblRin1.Text)' float.Parse(lblRout1.Text)'                                                float.Parse(lblRin2.Text)' float.Parse(lblRout2.Text)'                                                float.Parse(lblRin3.Text)' float.Parse(lblRout3.Text));                      }                  }                }
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Location = new System.Drawing.Point(153' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Location = new System.Drawing.Point(153' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(1028' 610);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(1028' 610);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlp.ColumnCount = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlp.RowCount = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlp.Size = new System.Drawing.Size(1184' 916);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlp.Size = new System.Drawing.Size(1184' 916);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Controls.Add(this.pnlPitch' 0' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Controls.Add(this.pnlRoll' 0' 5);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.RowCount = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Size = new System.Drawing.Size(144' 610);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.Size = new System.Drawing.Size(144' 610);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tlpData.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(138' 114);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel2.Size = new System.Drawing.Size(138' 114);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlYaw.Location = new System.Drawing.Point(3' 123);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlYaw.Location = new System.Drawing.Point(3' 123);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlYaw.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlYaw.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlYaw.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYnt.TabIndex = 23;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYinvert.TabIndex = 22;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYpts.TabIndex = 21;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYexpo.TabIndex = 20;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYsat.TabIndex = 19;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxYdeadzone.TabIndex = 18;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label25.Location = new System.Drawing.Point(37' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label25.Location = new System.Drawing.Point(37' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label25.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label25.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label25.TabIndex = 17;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label24.Location = new System.Drawing.Point(37' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label24.Location = new System.Drawing.Point(37' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label24.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label24.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label24.TabIndex = 16;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label23.Location = new System.Drawing.Point(37' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label23.Location = new System.Drawing.Point(37' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label23.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label23.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label23.TabIndex = 15;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout3.Location = new System.Drawing.Point(99' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout3.Location = new System.Drawing.Point(99' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout3.TabIndex = 14;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin3.Location = new System.Drawing.Point(59' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin3.Location = new System.Drawing.Point(59' 127);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin3.TabIndex = 13;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout2.Location = new System.Drawing.Point(99' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout2.Location = new System.Drawing.Point(99' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout2.TabIndex = 12;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin2.Location = new System.Drawing.Point(59' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin2.Location = new System.Drawing.Point(59' 109);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin2.TabIndex = 11;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout1.Location = new System.Drawing.Point(99' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout1.Location = new System.Drawing.Point(99' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYout1.TabIndex = 10;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin1.Location = new System.Drawing.Point(59' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin1.Location = new System.Drawing.Point(59' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYin1.TabIndex = 9;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYsat.TabIndex = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYexponent.TabIndex = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYdeadzone.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYCmd.Location = new System.Drawing.Point(37' 1);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYCmd.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYaw.Location = new System.Drawing.Point(2' 0);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYaw.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYaw.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlPitch.Location = new System.Drawing.Point(3' 284);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlPitch.Location = new System.Drawing.Point(3' 284);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlPitch.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlPitch.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlPitch.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPnt.TabIndex = 34;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPinvert.TabIndex = 33;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPpts.TabIndex = 32;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPexpo.TabIndex = 31;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPsat.TabIndex = 30;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxPdeadzone.TabIndex = 29;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label26.Location = new System.Drawing.Point(37' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label26.Location = new System.Drawing.Point(37' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label26.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label26.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label26.TabIndex = 28;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label27.Location = new System.Drawing.Point(37' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label27.Location = new System.Drawing.Point(37' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label27.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label27.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label27.TabIndex = 27;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label28.Location = new System.Drawing.Point(37' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label28.Location = new System.Drawing.Point(37' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label28.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label28.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label28.TabIndex = 26;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout3.Location = new System.Drawing.Point(99' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout3.Location = new System.Drawing.Point(99' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout3.TabIndex = 25;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin3.Location = new System.Drawing.Point(59' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin3.Location = new System.Drawing.Point(59' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin3.TabIndex = 24;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout2.Location = new System.Drawing.Point(99' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout2.Location = new System.Drawing.Point(99' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout2.TabIndex = 23;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin2.Location = new System.Drawing.Point(59' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin2.Location = new System.Drawing.Point(59' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin2.TabIndex = 22;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout1.Location = new System.Drawing.Point(99' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout1.Location = new System.Drawing.Point(99' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPout1.TabIndex = 21;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin1.Location = new System.Drawing.Point(59' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin1.Location = new System.Drawing.Point(59' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPin1.TabIndex = 20;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPsat.TabIndex = 10;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPexponent.TabIndex = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPdeadzone.TabIndex = 5;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPCmd.Location = new System.Drawing.Point(37' 1);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPCmd.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPitch.Location = new System.Drawing.Point(2' 0);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPitch.Size = new System.Drawing.Size(33' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPitch.Size = new System.Drawing.Size(33' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPitch.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlRoll.Location = new System.Drawing.Point(3' 445);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlRoll.Location = new System.Drawing.Point(3' 445);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlRoll.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlRoll.Size = new System.Drawing.Size(138' 149);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlRoll.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRnt.Location = new System.Drawing.Point(107' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRnt.Size = new System.Drawing.Size(20' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRnt.TabIndex = 38;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRinvert.Location = new System.Drawing.Point(6' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRinvert.Size = new System.Drawing.Size(55' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRinvert.TabIndex = 37;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRpts.Location = new System.Drawing.Point(6' 91);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRpts.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRpts.TabIndex = 36;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRexpo.Location = new System.Drawing.Point(6' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRexpo.Size = new System.Drawing.Size(75' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRexpo.TabIndex = 35;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRsat.Location = new System.Drawing.Point(6' 53);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRsat.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRsat.TabIndex = 34;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRdeadzone.Location = new System.Drawing.Point(6' 35);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRdeadzone.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbxRdeadzone.TabIndex = 33;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label35.Location = new System.Drawing.Point(37' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label35.Location = new System.Drawing.Point(37' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label35.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label35.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label35.TabIndex = 28;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label36.Location = new System.Drawing.Point(37' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label36.Location = new System.Drawing.Point(37' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label36.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label36.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label36.TabIndex = 27;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label37.Location = new System.Drawing.Point(37' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label37.Location = new System.Drawing.Point(37' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label37.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label37.Size = new System.Drawing.Size(23' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label37.TabIndex = 26;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout3.Location = new System.Drawing.Point(99' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout3.Location = new System.Drawing.Point(99' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout3.TabIndex = 25;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin3.Location = new System.Drawing.Point(59' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin3.Location = new System.Drawing.Point(59' 126);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin3.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin3.TabIndex = 24;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout2.Location = new System.Drawing.Point(99' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout2.Location = new System.Drawing.Point(99' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout2.TabIndex = 23;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin2.Location = new System.Drawing.Point(59' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin2.Location = new System.Drawing.Point(59' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin2.Size = new System.Drawing.Size(22' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin2.TabIndex = 22;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout1.Location = new System.Drawing.Point(99' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout1.Location = new System.Drawing.Point(99' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRout1.TabIndex = 21;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin1.Location = new System.Drawing.Point(59' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin1.Location = new System.Drawing.Point(59' 90);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin1.Size = new System.Drawing.Size(28' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRin1.TabIndex = 20;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRsat.Location = new System.Drawing.Point(99' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRsat.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRsat.TabIndex = 10;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRexponent.Location = new System.Drawing.Point(99' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRexponent.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRexponent.TabIndex = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRdeadzone.Location = new System.Drawing.Point(99' 36);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRdeadzone.Size = new System.Drawing.Size(34' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRdeadzone.TabIndex = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRCmd.Location = new System.Drawing.Point(37' 1);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRCmd.Size = new System.Drawing.Size(47' 12);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRCmd.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRoll.Location = new System.Drawing.Point(2' 0);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRoll.Size = new System.Drawing.Size(27' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRoll.Size = new System.Drawing.Size(27' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRoll.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.flowLayoutPanel1' 1' 2);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3' 1' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(153' 619);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point(153' 619);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(1028' 294);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size(1028' 294);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel9.Location = new System.Drawing.Point(624' 63);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel9.Location = new System.Drawing.Point(624' 63);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel9.Size = new System.Drawing.Size(401' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel9.Size = new System.Drawing.Size(401' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel9.TabIndex = 7;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(273' 8);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(273' 8);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(54' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 12;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblDamping.Location = new System.Drawing.Point(273' 29);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblDamping.Location = new System.Drawing.Point(273' 29);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblDamping.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblDamping.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblDamping.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.Size = new System.Drawing.Size(264' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.Size = new System.Drawing.Size(264' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slDamping.Value = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(624' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(624' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(401' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(401' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel1.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label16.Location = new System.Drawing.Point(273' 8);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label16.Location = new System.Drawing.Point(273' 8);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label16.Size = new System.Drawing.Size(93' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label16.Size = new System.Drawing.Size(93' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label16.TabIndex = 12;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblTurnspeed.Location = new System.Drawing.Point(273' 29);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblTurnspeed.Location = new System.Drawing.Point(273' 29);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblTurnspeed.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblTurnspeed.Size = new System.Drawing.Size(13' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblTurnspeed.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Maximum = 30;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Size = new System.Drawing.Size(264' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Size = new System.Drawing.Size(264' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.slTurnSpeed.Value = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel6.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel6.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.SetRowSpan(this.panel6' 4);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel6.Size = new System.Drawing.Size(579' 288);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel6.Size = new System.Drawing.Size(579' 288);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel6.TabIndex = 5;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtDeadzone.Location = new System.Drawing.Point(14' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtDeadzone.Location = new System.Drawing.Point(14' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtDeadzone.Size = new System.Drawing.Size(81' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtDeadzone.Size = new System.Drawing.Size(81' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtDeadzone.TabIndex = 54;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Location = new System.Drawing.Point(531' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Location = new System.Drawing.Point(531' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphSaturation.TabIndex = 53;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Location = new System.Drawing.Point(252' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Location = new System.Drawing.Point(252' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblGraphDeadzone.TabIndex = 52;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblNodetext.Location = new System.Drawing.Point(11' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblNodetext.Location = new System.Drawing.Point(11' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblNodetext.Size = new System.Drawing.Size(16' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblNodetext.Size = new System.Drawing.Size(16' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblNodetext.TabIndex = 51;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(213' 233);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(213' 233);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(16' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(16' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 50;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbRuse.Location = new System.Drawing.Point(192' 267);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbRuse.Location = new System.Drawing.Point(192' 267);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbRuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbRuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbRuse.TabIndex = 49;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbPuse.Location = new System.Drawing.Point(192' 248);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbPuse.Location = new System.Drawing.Point(192' 248);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbPuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbPuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbPuse.TabIndex = 48;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbYuse.Location = new System.Drawing.Point(192' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbYuse.Location = new System.Drawing.Point(192' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbYuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbYuse.Size = new System.Drawing.Size(15' 14);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.cbYuse.TabIndex = 47;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(5' 216);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(5' 216);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(246' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(246' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 46;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(15' 225);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(15' 225);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(13' 60);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(13' 60);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 45;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblROutput.Location = new System.Drawing.Point(142' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblROutput.Location = new System.Drawing.Point(142' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblROutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblROutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblROutput.TabIndex = 44;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRInput.Location = new System.Drawing.Point(89' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRInput.Location = new System.Drawing.Point(89' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblRInput.TabIndex = 43;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPOutput.Location = new System.Drawing.Point(142' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPOutput.Location = new System.Drawing.Point(142' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPOutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPOutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPOutput.TabIndex = 42;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPInput.Location = new System.Drawing.Point(89' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPInput.Location = new System.Drawing.Point(89' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblPInput.TabIndex = 41;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveRoll.Location = new System.Drawing.Point(32' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveRoll.Location = new System.Drawing.Point(32' 266);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveRoll.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveRoll.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveRoll.TabIndex = 40;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLivePitch.Location = new System.Drawing.Point(32' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLivePitch.Location = new System.Drawing.Point(32' 247);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLivePitch.Size = new System.Drawing.Size(45' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLivePitch.Size = new System.Drawing.Size(45' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLivePitch.TabIndex = 39;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btCopyToAllAxis.Location = new System.Drawing.Point(192' 159);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btCopyToAllAxis.Location = new System.Drawing.Point(192' 159);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btCopyToAllAxis.Size = new System.Drawing.Size(57' 44);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btCopyToAllAxis.Size = new System.Drawing.Size(57' 44);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btCopyToAllAxis.TabIndex = 38;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveYaw.Location = new System.Drawing.Point(32' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveYaw.Location = new System.Drawing.Point(32' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveYaw.Size = new System.Drawing.Size(45' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveYaw.Size = new System.Drawing.Size(45' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblLiveYaw.TabIndex = 37;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(310' 272);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(310' 272);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(193' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(193' 13);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 36;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYOutput.Location = new System.Drawing.Point(142' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYOutput.Location = new System.Drawing.Point(142' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYOutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYOutput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYOutput.TabIndex = 35;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYInput.Location = new System.Drawing.Point(89' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYInput.Location = new System.Drawing.Point(89' 228);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYInput.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblYInput.TabIndex = 34;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtExponent.Location = new System.Drawing.Point(14' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtExponent.Location = new System.Drawing.Point(14' 108);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtExponent.Size = new System.Drawing.Size(81' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtExponent.Size = new System.Drawing.Size(81' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtExponent.TabIndex = 33;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtSaturation.Location = new System.Drawing.Point(101' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtSaturation.Location = new System.Drawing.Point(101' 72);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtSaturation.Size = new System.Drawing.Size(83' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtSaturation.Size = new System.Drawing.Size(83' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPtSaturation.TabIndex = 32;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt3.Location = new System.Drawing.Point(14' 194);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt3.Location = new System.Drawing.Point(14' 194);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt3.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt3.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt3.TabIndex = 31;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt2.Location = new System.Drawing.Point(14' 171);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt2.Location = new System.Drawing.Point(14' 171);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt2.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt2.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt2.TabIndex = 30;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt1.Location = new System.Drawing.Point(14' 148);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt1.Location = new System.Drawing.Point(14' 148);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt1.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt1.Size = new System.Drawing.Size(67' 19);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbPt1.TabIndex = 29;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label33.Location = new System.Drawing.Point(135' 130);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label33.Location = new System.Drawing.Point(135' 130);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label33.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label33.Size = new System.Drawing.Size(46' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label33.TabIndex = 28;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label32.Location = new System.Drawing.Point(89' 130);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label32.Location = new System.Drawing.Point(89' 130);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label32.Size = new System.Drawing.Size(35' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label32.Size = new System.Drawing.Size(35' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.label32.TabIndex = 27;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut3.Location = new System.Drawing.Point(142' 196);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut3.Location = new System.Drawing.Point(142' 196);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut3.TabIndex = 23;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn3.Location = new System.Drawing.Point(89' 196);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn3.Location = new System.Drawing.Point(89' 196);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn3.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn3.TabIndex = 22;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut2.Location = new System.Drawing.Point(142' 173);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut2.Location = new System.Drawing.Point(142' 173);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut2.TabIndex = 21;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn2.Location = new System.Drawing.Point(89' 173);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn2.Location = new System.Drawing.Point(89' 173);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn2.Size = new System.Drawing.Size(22' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn2.TabIndex = 20;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut1.Location = new System.Drawing.Point(142' 150);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut1.Location = new System.Drawing.Point(142' 150);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOut1.TabIndex = 19;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn1.Location = new System.Drawing.Point(89' 150);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn1.Location = new System.Drawing.Point(89' 150);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn1.Size = new System.Drawing.Size(28' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblIn1.TabIndex = 18;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Location = new System.Drawing.Point(258' 7);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Location = new System.Drawing.Point(258' 7);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: series1.MarkerColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(128))))' ((int)(((byte)(0)))));
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Size = new System.Drawing.Size(301' 262);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.chart1.Size = new System.Drawing.Size(301' 262);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.chart1.TabIndex = 16;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutSlider.Location = new System.Drawing.Point(174' 34);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutSlider.Location = new System.Drawing.Point(174' 34);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutSlider.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutSlider.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutSlider.TabIndex = 13;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutExponent.Location = new System.Drawing.Point(112' 110);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutExponent.Location = new System.Drawing.Point(112' 110);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutExponent.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutExponent.Size = new System.Drawing.Size(34' 15);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.lblOutExponent.TabIndex = 9;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.Location = new System.Drawing.Point(3' 21);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.Location = new System.Drawing.Point(3' 21);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.Maximum = 40;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.Size = new System.Drawing.Size(165' 45);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tbSlider.TickFrequency = 5;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel1.Location = new System.Drawing.Point(624' 123);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel1.Location = new System.Drawing.Point(624' 123);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel1.Size = new System.Drawing.Size(401' 55);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel1.Size = new System.Drawing.Size(401' 55);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel1.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rb300.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rb300.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rb300.Size = new System.Drawing.Size(114' 48);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rb300.Size = new System.Drawing.Size(114' 48);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rb300.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHornet.Location = new System.Drawing.Point(123' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHornet.Location = new System.Drawing.Point(123' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHornet.Size = new System.Drawing.Size(114' 50);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHornet.Size = new System.Drawing.Size(114' 50);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbAurora.Location = new System.Drawing.Point(243' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbAurora.Location = new System.Drawing.Point(243' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbAurora.Size = new System.Drawing.Size(114' 50);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbAurora.Size = new System.Drawing.Size(114' 50);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.ColumnCount = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Location = new System.Drawing.Point(607' 184);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Location = new System.Drawing.Point(607' 184);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Size = new System.Drawing.Size(418' 107);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.Size = new System.Drawing.Size(418' 107);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel3.TabIndex = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(290' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Location = new System.Drawing.Point(290' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(125' 101);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btDone.Size = new System.Drawing.Size(125' 101);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.btDone.TabIndex = 28;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel8.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel8.Location = new System.Drawing.Point(3' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel8.Size = new System.Drawing.Size(281' 101);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel8.Size = new System.Drawing.Size(281' 101);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel8.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbArea18.Location = new System.Drawing.Point(27' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbArea18.Location = new System.Drawing.Point(27' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbArea18.Size = new System.Drawing.Size(63' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbArea18.Size = new System.Drawing.Size(63' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbArea18.TabIndex = 12;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDemien.Location = new System.Drawing.Point(200' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDemien.Location = new System.Drawing.Point(200' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDemien.Size = new System.Drawing.Size(64' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDemien.Size = new System.Drawing.Size(64' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDemien.TabIndex = 11;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBrokenMoon.Location = new System.Drawing.Point(27' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBrokenMoon.Location = new System.Drawing.Point(27' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBrokenMoon.Size = new System.Drawing.Size(96' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBrokenMoon.Size = new System.Drawing.Size(96' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBrokenMoon.TabIndex = 9;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDyingStar.Location = new System.Drawing.Point(200' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDyingStar.Location = new System.Drawing.Point(200' 3);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDyingStar.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDyingStar.Size = new System.Drawing.Size(78' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbDyingStar.TabIndex = 8;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSunset.Location = new System.Drawing.Point(27' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSunset.Location = new System.Drawing.Point(27' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSunset.Size = new System.Drawing.Size(60' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSunset.Size = new System.Drawing.Size(60' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSunset.TabIndex = 7;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere3.Location = new System.Drawing.Point(27' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere3.Location = new System.Drawing.Point(27' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere3.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere3.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere3.TabIndex = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSkybox.Location = new System.Drawing.Point(200' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSkybox.Location = new System.Drawing.Point(200' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSkybox.Size = new System.Drawing.Size(83' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSkybox.Size = new System.Drawing.Size(83' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbSkybox.TabIndex = 5;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere1.Location = new System.Drawing.Point(27' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere1.Location = new System.Drawing.Point(27' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere1.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere1.Size = new System.Drawing.Size(84' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbOutThere1.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBigSight.Location = new System.Drawing.Point(200' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBigSight.Location = new System.Drawing.Point(200' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBigSight.Size = new System.Drawing.Size(72' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBigSight.Size = new System.Drawing.Size(72' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbBigSight.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHighway.Location = new System.Drawing.Point(200' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHighway.Location = new System.Drawing.Point(200' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHighway.Size = new System.Drawing.Size(70' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHighway.Size = new System.Drawing.Size(70' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHighway.TabIndex = 2;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHelipad.Location = new System.Drawing.Point(117' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHelipad.Location = new System.Drawing.Point(117' 71);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHelipad.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbHelipad.Size = new System.Drawing.Size(80' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbShiodome.Location = new System.Drawing.Point(117' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbShiodome.Location = new System.Drawing.Point(117' 54);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbShiodome.Size = new System.Drawing.Size(77' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbShiodome.Size = new System.Drawing.Size(77' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbCanyon.Location = new System.Drawing.Point(117' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbCanyon.Location = new System.Drawing.Point(117' 37);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbCanyon.Size = new System.Drawing.Size(64' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbCanyon.Size = new System.Drawing.Size(64' 17);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel2.Location = new System.Drawing.Point(3' 619);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel2.Location = new System.Drawing.Point(3' 619);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel2.Size = new System.Drawing.Size(144' 294);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel2.Size = new System.Drawing.Size(144' 294);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.flowLayoutPanel2.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlAxisSelector.Size = new System.Drawing.Size(144' 157);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlAxisSelector.Size = new System.Drawing.Size(144' 157);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.pnlAxisSelector.TabIndex = 3;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbP.Location = new System.Drawing.Point(14' 58);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbP.Location = new System.Drawing.Point(14' 58);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbP.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbP.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbP.TabIndex = 6;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbY.Location = new System.Drawing.Point(15' 10);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbY.Location = new System.Drawing.Point(15' 10);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbY.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbY.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbY.TabIndex = 5;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbR.Location = new System.Drawing.Point(15' 106);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbR.Location = new System.Drawing.Point(15' 106);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbR.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbR.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbR.TabIndex = 7;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel10.Location = new System.Drawing.Point(3' 160);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel10.Location = new System.Drawing.Point(3' 160);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel10.Size = new System.Drawing.Size(138' 128);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel10.Size = new System.Drawing.Size(138' 128);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.panel10.TabIndex = 4;
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneStrafe.Location = new System.Drawing.Point(12' 68);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneStrafe.Location = new System.Drawing.Point(12' 68);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneStrafe.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneStrafe.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneYPR.Location = new System.Drawing.Point(12' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneYPR.Location = new System.Drawing.Point(12' 20);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneYPR.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.rbTuneYPR.Size = new System.Drawing.Size(111' 42);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1184' 916);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1184' 916);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(1200' 950);
Magic Number,SCJMapper_V2.OGL,FormJSCalCurve,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(1200' 950);
Magic Number,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Load,The following statement contains a magic number: if (dp != null)                  {                      used = (!string.IsNullOrEmpty(dp.NodeText));                      if (!used) return;                        nodetext = dp.NodeText;                      string[] e = nodetext.Split(new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries);                      if (e.Length > 0)                          control = e[1].TrimEnd();                      else                          control = dp.NodeText;                      command = dp.CommandCtrl;                      // the option data                      if (dp.DeviceoptionRef == null)                      {                          deadzoneUsed = false;                          saturationUsed = false;                      }                      else                      {                          deadzoneUsed = dp.DeviceoptionRef.DeadzoneUsed;                          deadzoneS = dp.DeviceoptionRef.Deadzone;                          saturationUsed = dp.DeviceoptionRef.SaturationUsed;                          saturationS = dp.DeviceoptionRef.Saturation;                      }                      invertUsed = dp.InvertUsed;                      exponentUsed = dp.ExponentUsed;                      exponentS = dp.Exponent;                      nonLinCurveUsed = dp.NonLinCurveUsed;                      if (dp.NonLinCurveUsed)                      {                          nonLinCurve.Curve(float.Parse(dp.NonLinCurvePtsIn[0])' float.Parse(dp.NonLinCurvePtsOut[0])'                                                 float.Parse(dp.NonLinCurvePtsIn[1])' float.Parse(dp.NonLinCurvePtsOut[1])'                                                 float.Parse(dp.NonLinCurvePtsIn[2])' float.Parse(dp.NonLinCurvePtsOut[2]));                      }                      else                      {                          // dummy curve                          nonLinCurve.Curve(0.25f' 0.25f' 0.5f' 0.5f' 0.75f' 0.75f);                      }                  }
Magic Number,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Load,The following statement contains a magic number: if (dp != null)                  {                      used = (!string.IsNullOrEmpty(dp.NodeText));                      if (!used) return;                        nodetext = dp.NodeText;                      string[] e = nodetext.Split(new char[] { ActionTreeInputNode.RegDiv' ActionTreeInputNode.ModDiv }' StringSplitOptions.RemoveEmptyEntries);                      if (e.Length > 0)                          control = e[1].TrimEnd();                      else                          control = dp.NodeText;                      command = dp.CommandCtrl;                      // the option data                      if (dp.DeviceoptionRef == null)                      {                          deadzoneUsed = false;                          saturationUsed = false;                      }                      else                      {                          deadzoneUsed = dp.DeviceoptionRef.DeadzoneUsed;                          deadzoneS = dp.DeviceoptionRef.Deadzone;                          saturationUsed = dp.DeviceoptionRef.SaturationUsed;                          saturationS = dp.DeviceoptionRef.Saturation;                      }                      invertUsed = dp.InvertUsed;                      exponentUsed = dp.ExponentUsed;                      exponentS = dp.Exponent;                      nonLinCurveUsed = dp.NonLinCurveUsed;                      if (dp.NonLinCurveUsed)                      {                          nonLinCurve.Curve(float.Parse(dp.NonLinCurvePtsIn[0])' float.Parse(dp.NonLinCurvePtsOut[0])'                                                 float.Parse(dp.NonLinCurvePtsIn[1])' float.Parse(dp.NonLinCurvePtsOut[1])'                                                 float.Parse(dp.NonLinCurvePtsIn[2])' float.Parse(dp.NonLinCurvePtsOut[2]));                      }                      else                      {                          // dummy curve                          nonLinCurve.Curve(0.25f' 0.25f' 0.5f' 0.5f' 0.75f' 0.75f);                      }                  }
Magic Number,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Update,The following statement contains a magic number: pts.Add(nonLinCurve.Pt(2).X.ToString("0.000"));
Magic Number,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,Update,The following statement contains a magic number: pts.Add(nonLinCurve.Pt(2).Y.ToString("0.000"));
Magic Number,SCJMapper_V2.OGL,LiveValues,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\FormJSCalCurve.cs,ScaledOut,The following statement contains a magic number: if (exponentUsed)                  {                      fout = Math.Pow(fout' exponent) * Math.Sign(devIn);                  }                  else if (nonLinCurveUsed)                  {                      fout = nonLinCurve.EvalX((int)(fout * 1000.0 * Math.Sign(devIn))); // gets a scaled signed value (-1 .. +1)                  }                  else                  {                      fout = fout * Math.Sign(devIn);                  }
Magic Number,SCJMapper_V2.OGL,RK4Integrator,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\RK4Integrator.cs,Integrate,The following statement contains a magic number: Derivative b = Evaluate( m_currState' dt * 0.5' a' dampK' dampB );
Magic Number,SCJMapper_V2.OGL,RK4Integrator,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\RK4Integrator.cs,Integrate,The following statement contains a magic number: Derivative c = Evaluate( m_currState' dt * 0.5' b' dampK' dampB );
Magic Number,SCJMapper_V2.OGL,RK4Integrator,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\RK4Integrator.cs,Integrate,The following statement contains a magic number: Vector3d dadt = _6th * ( a.da + (2.0 * ( b.da + c.da )) + d.da );
Magic Number,SCJMapper_V2.OGL,RK4Integrator,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\RK4Integrator.cs,Integrate,The following statement contains a magic number: Vector3d dvdt = _6th * ( a.dv + (2.0 * ( b.dv + c.dv )) + d.dv );
Magic Number,SCJMapper_V2.OGL,TriDiagonalMatrixF,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\TriDiagonalMatrix.cs,Solve,The following statement contains a magic number: for (int i = n-2; i >= 0; i--)  			{  				x[i] = dPrime[i] - cPrime[i] * x[i + 1];  			}
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 20;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 1] = (byte) ( ( splitme & 0x0000ff00 ) >> 8 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: byte[][] ThreeBits = new byte[2][];
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][1] << 3 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][0] << 12 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][1] << 15 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Magic Number,SCJMapper_V2.OGL.TextureLoaders,ImageDDS,C:\repos\SCToolsfactory_SCJMapper-V2\OGL\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Missing Default,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,ReadEmptyElement,The following switch statement is missing a default case: switch ( xr.NodeType ) {          case XmlNodeType.Element:            //Console.Write( "<{0}"' xr.Name );            while ( xr.MoveToNextAttribute( ) ) {              attr.Add( xr.Name' xr.Value );  // save the attributes              //Console.Write( " {0}='{1}'"' xr.Name' xr.Value );            }            if ( m_state == EState.inActionMap ) {              // processing a valid action map - collect actions              if ( eName.ToLower( ) == "action" ) {                // this is an action.. - collect it                CollectActions( attr );              }            }// if inmap            //Console.Write( ">\n" );              break;          case XmlNodeType.Text:            //Console.Write( xr.Value );            break;          case XmlNodeType.EndElement:            //Console.Write( "</{0}>\n"' xr.Name );            break;        }
Missing Default,SCJMapper_V2.SC,DProfileReader,C:\repos\SCToolsfactory_SCJMapper-V2\SC\DProfileReader.cs,ReadElement,The following switch statement is missing a default case: switch ( xr.NodeType ) {          case XmlNodeType.Element:            //Console.Write( "<{0}"' xr.Name );            while ( xr.MoveToNextAttribute( ) ) {              attr.Add( xr.Name' xr.Value );  // save the attributes              //Console.Write( " {0}='{1}'"' xr.Name' xr.Value );            }            // now here we could have an actionmap start            if ( m_state == EState.idle ) {              if ( m_nodeNameStack.Peek( ).ToLower( ) == "actionmap" ) {                // check for a valid one                string mapName = attr["name"];                string item = Array.Find( ActionMapsCls.ActionMaps' delegate ( string sstr ) { return sstr == mapName; } );                if ( !string.IsNullOrEmpty( item ) ) {                  // finally.... it is a valid actionmap                  m_currentMap = new ActionMap( );                  m_currentMap.name = mapName;                  if ( !m_aMap.ContainsKey( mapName ) ) { //20170325 - fix multiple map names - don't add the second' third etc. (CIG bug..)                    m_aMap.Add( mapName' m_currentMap ); // add to our inventory                  }else {                    log.DebugFormat( "ReadElement: IGNORED duplicate map with name: {0}"' mapName );                  }                  m_state = EState.inActionMap; // now we are in and processing the map                }              }            } else if ( m_state == EState.inActionMap ) {              // processing a valid action map - collect actions              if ( eName.ToLower( ) == "action" ) {                // this is an action.. - collect it                CollectActions( attr );                ReadActionSub( xr' attr["name"]' "" ); // a non empty action element may have a sub element (but no device yet)              }            }            //Console.Write( ">\n" );            break;          case XmlNodeType.Text:            //Console.Write( xr.Value );            break;          case XmlNodeType.EndElement:            //Console.Write( "</{0}>\n"' xr.Name );            break;        }
Missing Default,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateControls,The following switch statement is missing a default case: switch ( m_sliderCount++ ) {            case 0:              m_jPanel.S1e = true;              m_jPanel.S1name = d.Name + ":";              break;              case 1:              m_jPanel.S2e = true;              m_jPanel.S2name = d.Name + ":";              break;          }
Missing Default,SCJMapper_V2.Joystick,JoystickCls,C:\repos\SCToolsfactory_SCJMapper-V2\Joystick\JoystickCls.cs,UpdateControls,The following switch statement is missing a default case: switch ( m_numPOVs++ ) {            case 0:              m_jPanel.H1e = true;              m_jPanel.H1name = d.Name + ":";              break;              case 1:              m_jPanel.H2e = true;              m_jPanel.H2name = d.Name + ":";              break;              case 2:              m_jPanel.H3e = true;              m_jPanel.H3name = d.Name + ":";              break;              case 3:              m_jPanel.H4e = true;              m_jPanel.H4name = d.Name + ":";              break;          }
Missing Default,SCJMapper_V2.Mouse,MouseCls,C:\repos\SCToolsfactory_SCJMapper-V2\Mouse\MouseCls.cs,MouseCmd,The following switch statement is missing a default case: switch ( e.Button ) {          case MouseButtons.Left: {              mbs = "mouse1";              break;            }          case MouseButtons.Middle: {              mbs = "mouse3";              break;            }          case MouseButtons.Right: {              mbs = "mouse2";              break;            }          case MouseButtons.XButton1: {              mbs = "mouse4";              break;            }          case MouseButtons.XButton2: {              mbs = "mouse5";              break;            }        }
