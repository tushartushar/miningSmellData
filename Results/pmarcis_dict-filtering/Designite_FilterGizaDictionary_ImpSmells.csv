Implementation smell,Namespace,Class,File,Method,Description
Long Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The method has 389 lines of code.
Long Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The method has 136 lines of code.
Long Method,FilterGizaDictionary,SimpleCharacterTransliteration,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\SimpleCharacterTransliteration.cs,Transliterate,The method has 145 lines of code.
Long Method,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,GetAlphabet,The method has 105 lines of code.
Long Method,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,IsValidPhrase,The method has 128 lines of code.
Long Method,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The method has 125 lines of code.
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,Cyclomatic complexity of the method is 63
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidCase,Cyclomatic complexity of the method is 13
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,GetShape,Cyclomatic complexity of the method is 8
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,Cyclomatic complexity of the method is 107
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,GetStemmer,Cyclomatic complexity of the method is 26
Complex Method,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,Cyclomatic complexity of the method is 8
Complex Method,FilterGizaDictionary,SimpleCharacterTransliteration,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\SimpleCharacterTransliteration.cs,Transliterate,Cyclomatic complexity of the method is 45
Complex Method,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,GetAlphabet,Cyclomatic complexity of the method is 99
Complex Method,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,IsValidPhrase,Cyclomatic complexity of the method is 105
Complex Method,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,Cyclomatic complexity of the method is 8
Complex Method,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,Cyclomatic complexity of the method is 13
Complex Method,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,Cyclomatic complexity of the method is 11
Complex Method,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,Cyclomatic complexity of the method is 9
Complex Method,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,Cyclomatic complexity of the method is 22
Long Parameter List,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,AppendToErr,The method has 5 parameters.
Long Parameter List,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The method has 6 parameters.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "	if (string.IsNullOrWhiteSpace (filteredDictionaryFile) || string.IsNullOrWhiteSpace (gizaDictionaryFile) || string.IsNullOrWhiteSpace (sourceLang) || string.IsNullOrWhiteSpace (targetLang) || string.IsNullOrWhiteSpace (srcIdfFile) || string.IsNullOrWhiteSpace (trgIdfFile)) { " is 275.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "		Console.WriteLine ("Usage: ./FilterGizaDictionary.exe -i ./gizadict-in/lex.e2f -sl bg -tl en -o ./bg-en-filtered-dict.txt -s_idf ./bg_idf.txt -t_idf ./en_idf.txt -t 0.1 [-kc]"); " is 177.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "		Console.WriteLine ("Note that Giza++ gives probabilities in a reverse order - for each target (source <tab> target <tab> probability) word the probabilities sum to one. Therefore' to get a source-to-target filtered dictionary' you have to pass the target-to-source dictionary to the input data."); " is 297.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "	//At first' we read the dictionary into memory and calculate the first scores. Note that this requires enormous memory (more than 1GB). " is 135.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "	//Therefore' dictionaries should not be extremely large. This has been done just for convenience and could potentially be also changed. " is 135.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "				string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText); " is 139.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "				string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText); " is 139.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "				if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0) " is 131.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "				if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0) " is 131.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "		//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4). " is 141.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "						srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str); " is 185.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "						trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str); " is 185.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "					// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) { " is 147.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "					if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) { " is 143.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "			//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords). " is 124.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The length of the statement  "					if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) { " is 312.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The length of the statement  "		if (IsValidPhrase (srcLower' srcLang' true) && IsValidPhrase (trgLower' trgLang' true) && IsSameShape (srcLower' trgLower) && IsRightNumericCount (srcLower' trgLower) && IsRightPunctuationCount (srcLower' trgLower) && IsRightSymbolCount (srcLower' trgLower)) { " is 260.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The length of the statement  "		if (!acceptSymbolsAndOtherGarbage && baseAlphabet.IndexOf (c) < 0 && ValidAlphabets.punctuationsForTermsPhraseTableFiltering.IndexOf (c) < 0) { " is 143.
Long Statement,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The length of the statement  "		else if (acceptSymbolsAndOtherGarbage && !Char.IsDigit (c) && !Char.IsNumber (c) && !Char.IsPunctuation (c) && !Char.IsSymbol (c)) { " is 132.
Long Statement,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,IsValidPhrase,The length of the statement  "		if (baseAlphabet.IndexOf (c) < 0 && ValidAlphabets.punctuationsForTermsPhraseTableFiltering.IndexOf (c) < 0)//&& ValidAlphabets.EN.IndexOf(c) < 0) " is 146.
Long Statement,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep6,The length of the statement  "	if (word.Length >= MinStemLength && word.EndsWith ("e") && cvc (word [word.Length - 3]' word [word.Length - 2]' word [word.Length - 1])) { " is 138.
Long Statement,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The length of the statement  "	if (lowerCasedTerms == null || lowerCasedTerms.Count < 1 || string.IsNullOrWhiteSpace (srcLang) || string.IsNullOrWhiteSpace (trgLang) || string.IsNullOrWhiteSpace (mosesPath) || string.IsNullOrWhiteSpace (tempFilePath)) { " is 222.
Long Statement,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The length of the statement  "	Log.Write ("Starting transliteration of " + lowerCasedTerms.Count.ToString () + " tokens."' LogLevelType.LIMITED_OUTPUT); " is 121.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The conditional expression  "string.IsNullOrWhiteSpace (filteredDictionaryFile) || string.IsNullOrWhiteSpace (gizaDictionaryFile) || string.IsNullOrWhiteSpace (sourceLang) || string.IsNullOrWhiteSpace (targetLang) || string.IsNullOrWhiteSpace (srcIdfFile) || string.IsNullOrWhiteSpace (trgIdfFile)"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The conditional expression  "srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The conditional expression  "IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The conditional expression  "valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The conditional expression  "IsValidPhrase (srcLower' srcLang' true) && IsValidPhrase (trgLower' trgLang' true) && IsSameShape (srcLower' trgLower) && IsRightNumericCount (srcLower' trgLower) && IsRightPunctuationCount (srcLower' trgLower) && IsRightSymbolCount (srcLower' trgLower)"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidCase,The conditional expression  "srcAllLower && trgAllLower || srcAllUpper && trgAllUpper || srcFirstUpper && trgFirstUpper || srcMixed && trgMixed"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidCase,The conditional expression  "srcFirstUpper && trgAllLower || trgFirstUpper && srcAllLower"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The conditional expression  "acceptSymbolsAndOtherGarbage && !Char.IsDigit (c) && !Char.IsNumber (c) && !Char.IsPunctuation (c) && !Char.IsSymbol (c)"  is complex.
Complex Conditional,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The conditional expression  "spaceCount > 0 || punctCount > 1 || (!acceptSymbolsAndOtherGarbage && onlyPunct)"  is complex.
Complex Conditional,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The conditional expression  "lowerCasedTerms == null || lowerCasedTerms.Count < 1 || string.IsNullOrWhiteSpace (srcLang) || string.IsNullOrWhiteSpace (trgLang) || string.IsNullOrWhiteSpace (mosesPath) || string.IsNullOrWhiteSpace (tempFilePath)"  is complex.
Empty Catch Block,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,The method has an empty catch block.
Empty Catch Block,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The method has an empty catch block.
Empty Catch Block,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The method has an empty catch block.
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: while (!sr.EndOfStream) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string line = sr.ReadLine ().Trim ();  	if (!string.IsNullOrWhiteSpace (line)) {  		string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (arr != null && arr.Length == 3) {  			totalCounter++;  			string srcText = "";  			string trgText = "";  			string srcTextWCap = arr [1].Trim ();  			//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  			string trgTextWCap = arr [0].Trim ();  			srcText = arr [1].ToLower ().Trim ();  			trgText = arr [0].ToLower ().Trim ();  			if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  				invalidStringCounter++;  				continue;  			}  			double prob = 0;  			try {  				prob = Convert.ToDouble (arr [2]' nfi);  			}  			catch {  				invalidStringCounter++;  				continue;  			}  			if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  				AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  				invalidStringCounter++;  				continue;  			}  			if (!dict.ContainsKey (srcTextWCap))  				dict.Add (srcTextWCap' new Dictionary<string' double> ());  			if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  				dict [srcTextWCap].Add (trgTextWCap' prob);  			string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  			if (!stemDictionary [sourceLang].ContainsKey (srcText))  				stemDictionary [sourceLang].Add (srcText' srcStem);  			string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  			if (!stemDictionary [targetLang].ContainsKey (trgText))  				stemDictionary [targetLang].Add (trgText' trgStem);  			string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  			string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  			if (!srcToTrgStems.ContainsKey (srcStem))  				srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  			if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  				double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  				double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  				double similarity = (maxLen - levenshtainDistance) / maxLen;  				srcToTrgStems [srcStem].Add (trgStem' similarity);  			}  			//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  			if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  				srcWordsForTranslit.Add (srcText' true);  			if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  				trgWordsForTranslit.Add (trgText' true);  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: while (!sr.EndOfStream) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string line = sr.ReadLine ().Trim ();  	if (!string.IsNullOrWhiteSpace (line)) {  		string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (arr != null && arr.Length == 3) {  			totalCounter++;  			string srcText = "";  			string trgText = "";  			string srcTextWCap = arr [1].Trim ();  			//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  			string trgTextWCap = arr [0].Trim ();  			srcText = arr [1].ToLower ().Trim ();  			trgText = arr [0].ToLower ().Trim ();  			if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  				invalidStringCounter++;  				continue;  			}  			double prob = 0;  			try {  				prob = Convert.ToDouble (arr [2]' nfi);  			}  			catch {  				invalidStringCounter++;  				continue;  			}  			if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  				AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  				invalidStringCounter++;  				continue;  			}  			if (!dict.ContainsKey (srcTextWCap))  				dict.Add (srcTextWCap' new Dictionary<string' double> ());  			if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  				dict [srcTextWCap].Add (trgTextWCap' prob);  			string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  			if (!stemDictionary [sourceLang].ContainsKey (srcText))  				stemDictionary [sourceLang].Add (srcText' srcStem);  			string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  			if (!stemDictionary [targetLang].ContainsKey (trgText))  				stemDictionary [targetLang].Add (trgText' trgStem);  			string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  			string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  			if (!srcToTrgStems.ContainsKey (srcStem))  				srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  			if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  				double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  				double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  				double similarity = (maxLen - levenshtainDistance) / maxLen;  				srcToTrgStems [srcStem].Add (trgStem' similarity);  			}  			//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  			if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  				srcWordsForTranslit.Add (srcText' true);  			if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  				trgWordsForTranslit.Add (trgText' true);  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: while (!sr.EndOfStream) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string line = sr.ReadLine ().Trim ();  	if (!string.IsNullOrWhiteSpace (line)) {  		string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (arr != null && arr.Length == 3) {  			totalCounter++;  			string srcText = "";  			string trgText = "";  			string srcTextWCap = arr [1].Trim ();  			//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  			string trgTextWCap = arr [0].Trim ();  			srcText = arr [1].ToLower ().Trim ();  			trgText = arr [0].ToLower ().Trim ();  			if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  				invalidStringCounter++;  				continue;  			}  			double prob = 0;  			try {  				prob = Convert.ToDouble (arr [2]' nfi);  			}  			catch {  				invalidStringCounter++;  				continue;  			}  			if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  				AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  				invalidStringCounter++;  				continue;  			}  			if (!dict.ContainsKey (srcTextWCap))  				dict.Add (srcTextWCap' new Dictionary<string' double> ());  			if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  				dict [srcTextWCap].Add (trgTextWCap' prob);  			string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  			if (!stemDictionary [sourceLang].ContainsKey (srcText))  				stemDictionary [sourceLang].Add (srcText' srcStem);  			string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  			if (!stemDictionary [targetLang].ContainsKey (trgText))  				stemDictionary [targetLang].Add (trgText' trgStem);  			string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  			string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  			if (!srcToTrgStems.ContainsKey (srcStem))  				srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  			if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  				double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  				double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  				double similarity = (maxLen - levenshtainDistance) / maxLen;  				srcToTrgStems [srcStem].Add (trgStem' similarity);  			}  			//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  			if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  				srcWordsForTranslit.Add (srcText' true);  			if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  				trgWordsForTranslit.Add (trgText' true);  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: while (!sr.EndOfStream) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string line = sr.ReadLine ().Trim ();  	if (!string.IsNullOrWhiteSpace (line)) {  		string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (arr != null && arr.Length == 3) {  			totalCounter++;  			string srcText = "";  			string trgText = "";  			string srcTextWCap = arr [1].Trim ();  			//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  			string trgTextWCap = arr [0].Trim ();  			srcText = arr [1].ToLower ().Trim ();  			trgText = arr [0].ToLower ().Trim ();  			if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  				invalidStringCounter++;  				continue;  			}  			double prob = 0;  			try {  				prob = Convert.ToDouble (arr [2]' nfi);  			}  			catch {  				invalidStringCounter++;  				continue;  			}  			if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  				AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  				invalidStringCounter++;  				continue;  			}  			if (!dict.ContainsKey (srcTextWCap))  				dict.Add (srcTextWCap' new Dictionary<string' double> ());  			if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  				dict [srcTextWCap].Add (trgTextWCap' prob);  			string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  			if (!stemDictionary [sourceLang].ContainsKey (srcText))  				stemDictionary [sourceLang].Add (srcText' srcStem);  			string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  			if (!stemDictionary [targetLang].ContainsKey (trgText))  				stemDictionary [targetLang].Add (trgText' trgStem);  			string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  			string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  			if (!srcToTrgStems.ContainsKey (srcStem))  				srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  			if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  				double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  				double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  				double similarity = (maxLen - levenshtainDistance) / maxLen;  				srcToTrgStems [srcStem].Add (trgStem' similarity);  			}  			//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  			if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  				srcWordsForTranslit.Add (srcText' true);  			if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  				trgWordsForTranslit.Add (trgText' true);  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 10000 == 0) {  	Console.Error.Write (".");  	if (counter % 500000 == 0) {  		Console.Error.WriteLine (" - " + counter.ToString ());  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 10000 == 0) {  	Console.Error.Write (".");  	if (counter % 500000 == 0) {  		Console.Error.WriteLine (" - " + counter.ToString ());  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 500000 == 0) {  	Console.Error.WriteLine (" - " + counter.ToString ());  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace (line)) {  	string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  	if (arr != null && arr.Length == 3) {  		totalCounter++;  		string srcText = "";  		string trgText = "";  		string srcTextWCap = arr [1].Trim ();  		//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  		string trgTextWCap = arr [0].Trim ();  		srcText = arr [1].ToLower ().Trim ();  		trgText = arr [0].ToLower ().Trim ();  		if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  			invalidStringCounter++;  			continue;  		}  		double prob = 0;  		try {  			prob = Convert.ToDouble (arr [2]' nfi);  		}  		catch {  			invalidStringCounter++;  			continue;  		}  		if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  			AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  			invalidStringCounter++;  			continue;  		}  		if (!dict.ContainsKey (srcTextWCap))  			dict.Add (srcTextWCap' new Dictionary<string' double> ());  		if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  			dict [srcTextWCap].Add (trgTextWCap' prob);  		string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  		if (!stemDictionary [sourceLang].ContainsKey (srcText))  			stemDictionary [sourceLang].Add (srcText' srcStem);  		string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  		if (!stemDictionary [targetLang].ContainsKey (trgText))  			stemDictionary [targetLang].Add (trgText' trgStem);  		string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  		string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  		if (!srcToTrgStems.ContainsKey (srcStem))  			srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  		if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  			double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  			double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  			double similarity = (maxLen - levenshtainDistance) / maxLen;  			srcToTrgStems [srcStem].Add (trgStem' similarity);  		}  		//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  		if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  			srcWordsForTranslit.Add (srcText' true);  		if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  			trgWordsForTranslit.Add (trgText' true);  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace (line)) {  	string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  	if (arr != null && arr.Length == 3) {  		totalCounter++;  		string srcText = "";  		string trgText = "";  		string srcTextWCap = arr [1].Trim ();  		//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  		string trgTextWCap = arr [0].Trim ();  		srcText = arr [1].ToLower ().Trim ();  		trgText = arr [0].ToLower ().Trim ();  		if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  			invalidStringCounter++;  			continue;  		}  		double prob = 0;  		try {  			prob = Convert.ToDouble (arr [2]' nfi);  		}  		catch {  			invalidStringCounter++;  			continue;  		}  		if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  			AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  			invalidStringCounter++;  			continue;  		}  		if (!dict.ContainsKey (srcTextWCap))  			dict.Add (srcTextWCap' new Dictionary<string' double> ());  		if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  			dict [srcTextWCap].Add (trgTextWCap' prob);  		string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  		if (!stemDictionary [sourceLang].ContainsKey (srcText))  			stemDictionary [sourceLang].Add (srcText' srcStem);  		string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  		if (!stemDictionary [targetLang].ContainsKey (trgText))  			stemDictionary [targetLang].Add (trgText' trgStem);  		string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  		string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  		if (!srcToTrgStems.ContainsKey (srcStem))  			srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  		if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  			double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  			double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  			double similarity = (maxLen - levenshtainDistance) / maxLen;  			srcToTrgStems [srcStem].Add (trgStem' similarity);  		}  		//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  		if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  			srcWordsForTranslit.Add (srcText' true);  		if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  			trgWordsForTranslit.Add (trgText' true);  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (arr != null && arr.Length == 3) {  	totalCounter++;  	string srcText = "";  	string trgText = "";  	string srcTextWCap = arr [1].Trim ();  	//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  	string trgTextWCap = arr [0].Trim ();  	srcText = arr [1].ToLower ().Trim ();  	trgText = arr [0].ToLower ().Trim ();  	if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  		invalidStringCounter++;  		continue;  	}  	double prob = 0;  	try {  		prob = Convert.ToDouble (arr [2]' nfi);  	}  	catch {  		invalidStringCounter++;  		continue;  	}  	if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  		AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  		invalidStringCounter++;  		continue;  	}  	if (!dict.ContainsKey (srcTextWCap))  		dict.Add (srcTextWCap' new Dictionary<string' double> ());  	if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  		dict [srcTextWCap].Add (trgTextWCap' prob);  	string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  	if (!stemDictionary [sourceLang].ContainsKey (srcText))  		stemDictionary [sourceLang].Add (srcText' srcStem);  	string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  	if (!stemDictionary [targetLang].ContainsKey (trgText))  		stemDictionary [targetLang].Add (trgText' trgStem);  	string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  	string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  	if (!srcToTrgStems.ContainsKey (srcStem))  		srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  	if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  		double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  		double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  		double similarity = (maxLen - levenshtainDistance) / maxLen;  		srcToTrgStems [srcStem].Add (trgStem' similarity);  	}  	//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  	if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  		srcWordsForTranslit.Add (srcText' true);  	if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  		trgWordsForTranslit.Add (trgText' true);  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (arr != null && arr.Length == 3) {  	totalCounter++;  	string srcText = "";  	string trgText = "";  	string srcTextWCap = arr [1].Trim ();  	//GIZA++ probabilities are in the reverse direction! For each target word the probabilities sum to 1!  	string trgTextWCap = arr [0].Trim ();  	srcText = arr [1].ToLower ().Trim ();  	trgText = arr [0].ToLower ().Trim ();  	if (string.IsNullOrWhiteSpace (srcText) || string.IsNullOrWhiteSpace (trgText)) {  		invalidStringCounter++;  		continue;  	}  	double prob = 0;  	try {  		prob = Convert.ToDouble (arr [2]' nfi);  	}  	catch {  		invalidStringCounter++;  		continue;  	}  	if (!IsValidPhrase (srcTextWCap' sourceLang' trgTextWCap' targetLang)) {  		AppendToErr (srcTextWCap' trgTextWCap' prob' swe' "INVALID_STRING_FILTER");  		invalidStringCounter++;  		continue;  	}  	if (!dict.ContainsKey (srcTextWCap))  		dict.Add (srcTextWCap' new Dictionary<string' double> ());  	if (!dict [srcTextWCap].ContainsKey (trgTextWCap))  		dict [srcTextWCap].Add (trgTextWCap' prob);  	string srcStem = stemDictionary [sourceLang].ContainsKey (srcText) ? stemDictionary [sourceLang] [srcText] : srcStemmer.StemWord (srcText);  	if (!stemDictionary [sourceLang].ContainsKey (srcText))  		stemDictionary [sourceLang].Add (srcText' srcStem);  	string trgStem = stemDictionary [targetLang].ContainsKey (trgText) ? stemDictionary [targetLang] [trgText] : trgStemmer.StemWord (trgText);  	if (!stemDictionary [targetLang].ContainsKey (trgText))  		stemDictionary [targetLang].Add (trgText' trgStem);  	string srcSimple = SimpleCharacterTransliteration.Transliterate (srcStem);  	string trgSimple = SimpleCharacterTransliteration.Transliterate (trgStem);  	if (!srcToTrgStems.ContainsKey (srcStem))  		srcToTrgStems.Add (srcStem' new Dictionary<string' double> ());  	if (!srcToTrgStems [srcStem].ContainsKey (trgStem)) {  		double levenshtainDistance = LevenshteinDistance.Compute (srcSimple' trgSimple);  		double maxLen = Math.Max (srcSimple.Length' trgSimple.Length);  		double similarity = (maxLen - levenshtainDistance) / maxLen;  		srcToTrgStems [srcStem].Add (trgStem' similarity);  	}  	//If word pairs are valid and the words contain at least one letter' we add them to the "to be transliterated" list.  	if (!srcWordsForTranslit.ContainsKey (srcText) && srcText.IndexOfAny (ValidAlphabets.GetAlphabet (sourceLang).ToCharArray ()) >= 0)  		srcWordsForTranslit.Add (srcText' true);  	if (!trgWordsForTranslit.ContainsKey (trgText) && trgText.IndexOfAny (ValidAlphabets.GetAlphabet (targetLang).ToCharArray ()) >= 0)  		trgWordsForTranslit.Add (trgText' true);  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: try {  	prob = Convert.ToDouble (arr [2]' nfi);  }  catch {  	invalidStringCounter++;  	continue;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: prob = Convert.ToDouble (arr [2]' nfi);  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (useHeavyTranslit) {  	if (!File.Exists (srcTranslitBackup)) {  		translitSrcDict = tm.GetTransliterations (srcWordsForTranslit' sourceLang' targetLang' mosesPath' tempFilePath' 6);  		SaveBackupTranslits (srcTranslitBackup' translitSrcDict);  	}  	else {  		translitSrcDict = LoadBackupTranslits (srcTranslitBackup);  	}  	if (!File.Exists (trgTranslitBackup)) {  		translitTrgDict = tm.GetTransliterations (trgWordsForTranslit' targetLang' sourceLang' mosesPath' tempFilePath' 6);  		SaveBackupTranslits (trgTranslitBackup' translitTrgDict);  	}  	else {  		translitTrgDict = LoadBackupTranslits (trgTranslitBackup);  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (useHeavyTranslit) {  	if (!File.Exists (srcTranslitBackup)) {  		translitSrcDict = tm.GetTransliterations (srcWordsForTranslit' sourceLang' targetLang' mosesPath' tempFilePath' 6);  		SaveBackupTranslits (srcTranslitBackup' translitSrcDict);  	}  	else {  		translitSrcDict = LoadBackupTranslits (srcTranslitBackup);  	}  	if (!File.Exists (trgTranslitBackup)) {  		translitTrgDict = tm.GetTransliterations (trgWordsForTranslit' targetLang' sourceLang' mosesPath' tempFilePath' 6);  		SaveBackupTranslits (trgTranslitBackup' translitTrgDict);  	}  	else {  		translitTrgDict = LoadBackupTranslits (trgTranslitBackup);  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (!File.Exists (srcTranslitBackup)) {  	translitSrcDict = tm.GetTransliterations (srcWordsForTranslit' sourceLang' targetLang' mosesPath' tempFilePath' 6);  	SaveBackupTranslits (srcTranslitBackup' translitSrcDict);  }  else {  	translitSrcDict = LoadBackupTranslits (srcTranslitBackup);  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: translitSrcDict = tm.GetTransliterations (srcWordsForTranslit' sourceLang' targetLang' mosesPath' tempFilePath' 6);  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (!File.Exists (trgTranslitBackup)) {  	translitTrgDict = tm.GetTransliterations (trgWordsForTranslit' targetLang' sourceLang' mosesPath' tempFilePath' 6);  	SaveBackupTranslits (trgTranslitBackup' translitTrgDict);  }  else {  	translitTrgDict = LoadBackupTranslits (trgTranslitBackup);  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: translitTrgDict = tm.GetTransliterations (trgWordsForTranslit' targetLang' sourceLang' mosesPath' tempFilePath' 6);  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string srcWord in dict.Keys) {  	counter++;  	if (counter % 10000 == 0) {  		Console.Error.Write (".");  		if (counter % 500000 == 0) {  			Console.Error.WriteLine (" - " + counter.ToString ());  		}  	}  	string srcLower = srcWord.ToLower ();  	string srcStem = stemDictionary [sourceLang] [srcLower];  	double srcIdf = srcIdfDict.ContainsKey (srcStem) ? srcIdfDict [srcStem] : maxSrcIdf;  	//At first' try to identify whether something can be paired using transliteration. If yes' apply to all other pairs a higher threshold (0.4).  	//If no transliteration can be found' apply the minimum IDF threshold.  	//Allow falling through pairs with only one translation candidate  	List<StringProbabEntry> foundTranslits = new List<StringProbabEntry> ();  	List<StringProbabEntry> validAfterMinimumIdf = new List<StringProbabEntry> ();  	Dictionary<string' double> maxStemDict = new Dictionary<string' double> ();  	Dictionary<string' int> maxStemCountDict = new Dictionary<string' int> ();  	double maxProb = 0;  	int maxStemCount = 0;  	foreach (string trgWord in dict [srcWord].Keys) {  		string trgLower = trgWord.ToLower ();  		string trgStem = stemDictionary [targetLang] [trgLower];  		double prob = dict [srcWord] [trgWord];  		double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  		List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  		if (srcTranslits != null) {  			for (int i = 0; i < srcTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  					srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  					if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  						stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  				}  			}  		}  		List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  		if (trgTranslits != null) {  			for (int i = 0; i < trgTranslits.Count; i++) {  				if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  					trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  					if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  						stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  				}  			}  		}  		double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  		double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  		double minLen = Math.Min (srcLower.Length' trgLower.Length);  		double maxLen = Math.Max (srcLower.Length' trgLower.Length);  		//Check whether the words may be transliterations (but only if they are not equal!  		if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  			double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  			if (maxTranslScore >= 0.7) {  				// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  				foundTranslits.Add (new StringProbabEntry (trgWord' prob));  				if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  					swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  				}  				continue;  			}  		}  		//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  		double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  		double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  		double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  		if (idfProp < idfPropThreshold) {  			idfFilterCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  			continue;  		}  		if (prob < absThreshold && dict [srcWord].Count > 1) {  			absThresholdCounter++;  			AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  			continue;  		}  		validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  		if (!maxStemDict.ContainsKey (trgStem))  			maxStemDict.Add (trgStem' prob);  		if (maxStemDict [trgStem] < prob)  			maxStemDict [trgStem] = prob;  		if (maxProb < prob)  			maxProb = prob;  		if (!maxStemCountDict.ContainsKey (trgStem))  			maxStemCountDict.Add (trgStem' 1);  		else  			maxStemCountDict [trgStem]++;  		if (maxStemCountDict [trgStem] > maxStemCount) {  			maxStemCount = maxStemCountDict [trgStem];  		}  	}  	double updatedThr = foundTranslits.Count > 0 ? afterTranslThreshold : initialThreshold;  	foreach (StringProbabEntry spe in foundTranslits) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" TRANSLIT");  		translCounter++;  		writtenCounter++;  	}  	foreach (StringProbabEntry spe in validAfterMinimumIdf) {  		if (validAfterMinimumIdf.Count > 1) {  			if (spe.probab >= updatedThr) {  				bool valid = true;  				foreach (StringProbabEntry tre in foundTranslits) {  					if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  						valid = false;  						translitFilterCounter++;  						AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  						swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  						break;  					}  				}  				if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  					heuristicFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  					valid = false;  				}  				if (valid) {  					sw.Write (srcWord);  					sw.Write (" ");  					sw.Write (spe.str);  					sw.Write (" ");  					sw.WriteLine (spe.probab.ToString (nfi));  					/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  				}  			}  			else {  				secondThresholdFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  			}  		}  		else if (foundTranslits.Count == 0) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			//sw.WriteLine (" UNIQUE");  			uniqueCounter++;  			writtenCounter++;  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 10000 == 0) {  	Console.Error.Write (".");  	if (counter % 500000 == 0) {  		Console.Error.WriteLine (" - " + counter.ToString ());  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 10000 == 0) {  	Console.Error.Write (".");  	if (counter % 500000 == 0) {  		Console.Error.WriteLine (" - " + counter.ToString ());  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (counter % 500000 == 0) {  	Console.Error.WriteLine (" - " + counter.ToString ());  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string trgWord in dict [srcWord].Keys) {  	string trgLower = trgWord.ToLower ();  	string trgStem = stemDictionary [targetLang] [trgLower];  	double prob = dict [srcWord] [trgWord];  	double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  	List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  	if (srcTranslits != null) {  		for (int i = 0; i < srcTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  				srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  				if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  					stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  			}  		}  	}  	List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  	if (trgTranslits != null) {  		for (int i = 0; i < trgTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  				trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  				if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  					stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  			}  		}  	}  	double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  	double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  	double minLen = Math.Min (srcLower.Length' trgLower.Length);  	double maxLen = Math.Max (srcLower.Length' trgLower.Length);  	//Check whether the words may be transliterations (but only if they are not equal!  	if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  		double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  		if (maxTranslScore >= 0.7) {  			// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  			foundTranslits.Add (new StringProbabEntry (trgWord' prob));  			if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  				swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  			}  			continue;  		}  	}  	//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  	double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  	double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  	double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  	if (idfProp < idfPropThreshold) {  		idfFilterCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  		continue;  	}  	if (prob < absThreshold && dict [srcWord].Count > 1) {  		absThresholdCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  		continue;  	}  	validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  	if (!maxStemDict.ContainsKey (trgStem))  		maxStemDict.Add (trgStem' prob);  	if (maxStemDict [trgStem] < prob)  		maxStemDict [trgStem] = prob;  	if (maxProb < prob)  		maxProb = prob;  	if (!maxStemCountDict.ContainsKey (trgStem))  		maxStemCountDict.Add (trgStem' 1);  	else  		maxStemCountDict [trgStem]++;  	if (maxStemCountDict [trgStem] > maxStemCount) {  		maxStemCount = maxStemCountDict [trgStem];  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string trgWord in dict [srcWord].Keys) {  	string trgLower = trgWord.ToLower ();  	string trgStem = stemDictionary [targetLang] [trgLower];  	double prob = dict [srcWord] [trgWord];  	double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  	List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  	if (srcTranslits != null) {  		for (int i = 0; i < srcTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  				srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  				if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  					stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  			}  		}  	}  	List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  	if (trgTranslits != null) {  		for (int i = 0; i < trgTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  				trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  				if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  					stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  			}  		}  	}  	double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  	double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  	double minLen = Math.Min (srcLower.Length' trgLower.Length);  	double maxLen = Math.Max (srcLower.Length' trgLower.Length);  	//Check whether the words may be transliterations (but only if they are not equal!  	if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  		double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  		if (maxTranslScore >= 0.7) {  			// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  			foundTranslits.Add (new StringProbabEntry (trgWord' prob));  			if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  				swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  			}  			continue;  		}  	}  	//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  	double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  	double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  	double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  	if (idfProp < idfPropThreshold) {  		idfFilterCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  		continue;  	}  	if (prob < absThreshold && dict [srcWord].Count > 1) {  		absThresholdCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  		continue;  	}  	validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  	if (!maxStemDict.ContainsKey (trgStem))  		maxStemDict.Add (trgStem' prob);  	if (maxStemDict [trgStem] < prob)  		maxStemDict [trgStem] = prob;  	if (maxProb < prob)  		maxProb = prob;  	if (!maxStemCountDict.ContainsKey (trgStem))  		maxStemCountDict.Add (trgStem' 1);  	else  		maxStemCountDict [trgStem]++;  	if (maxStemCountDict [trgStem] > maxStemCount) {  		maxStemCount = maxStemCountDict [trgStem];  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string trgWord in dict [srcWord].Keys) {  	string trgLower = trgWord.ToLower ();  	string trgStem = stemDictionary [targetLang] [trgLower];  	double prob = dict [srcWord] [trgWord];  	double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  	List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  	if (srcTranslits != null) {  		for (int i = 0; i < srcTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  				srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  				if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  					stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  			}  		}  	}  	List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  	if (trgTranslits != null) {  		for (int i = 0; i < trgTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  				trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  				if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  					stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  			}  		}  	}  	double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  	double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  	double minLen = Math.Min (srcLower.Length' trgLower.Length);  	double maxLen = Math.Max (srcLower.Length' trgLower.Length);  	//Check whether the words may be transliterations (but only if they are not equal!  	if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  		double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  		if (maxTranslScore >= 0.7) {  			// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  			foundTranslits.Add (new StringProbabEntry (trgWord' prob));  			if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  				swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  			}  			continue;  		}  	}  	//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  	double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  	double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  	double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  	if (idfProp < idfPropThreshold) {  		idfFilterCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  		continue;  	}  	if (prob < absThreshold && dict [srcWord].Count > 1) {  		absThresholdCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  		continue;  	}  	validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  	if (!maxStemDict.ContainsKey (trgStem))  		maxStemDict.Add (trgStem' prob);  	if (maxStemDict [trgStem] < prob)  		maxStemDict [trgStem] = prob;  	if (maxProb < prob)  		maxProb = prob;  	if (!maxStemCountDict.ContainsKey (trgStem))  		maxStemCountDict.Add (trgStem' 1);  	else  		maxStemCountDict [trgStem]++;  	if (maxStemCountDict [trgStem] > maxStemCount) {  		maxStemCount = maxStemCountDict [trgStem];  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (string trgWord in dict [srcWord].Keys) {  	string trgLower = trgWord.ToLower ();  	string trgStem = stemDictionary [targetLang] [trgLower];  	double prob = dict [srcWord] [trgWord];  	double simpleTranslitScore = srcToTrgStems [srcStem] [trgStem];  	List<StringProbabEntry> srcTranslits = translitSrcDict.ContainsKey (srcLower) ? translitSrcDict [srcLower] : null;  	if (srcTranslits != null) {  		for (int i = 0; i < srcTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (srcTranslits [i].stem)) {  				srcTranslits [i].stem = stemDictionary [targetLang].ContainsKey (srcTranslits [i].str) ? stemDictionary [targetLang] [srcTranslits [i].str] : trgStemmer.StemWord (srcTranslits [i].str);  				if (!stemDictionary [targetLang].ContainsKey (srcTranslits [i].str))  					stemDictionary [targetLang].Add (srcTranslits [i].str' srcTranslits [i].stem);  			}  		}  	}  	List<StringProbabEntry> trgTranslits = translitTrgDict.ContainsKey (trgLower) ? translitTrgDict [trgLower] : null;  	if (trgTranslits != null) {  		for (int i = 0; i < trgTranslits.Count; i++) {  			if (string.IsNullOrWhiteSpace (trgTranslits [i].stem)) {  				trgTranslits [i].stem = stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str) ? stemDictionary [sourceLang] [trgTranslits [i].str] : srcStemmer.StemWord (trgTranslits [i].str);  				if (!stemDictionary [sourceLang].ContainsKey (trgTranslits [i].str))  					stemDictionary [sourceLang].Add (trgTranslits [i].str' trgTranslits [i].stem);  			}  		}  	}  	double maxSrcTranslitScore = srcTranslits != null ? GetMaxTranslitScore (trgStem.ToLower ()' srcTranslits) : 0;  	double maxTrgTranslitScore = trgTranslits != null ? GetMaxTranslitScore (srcStem.ToLower ()' trgTranslits) : 0;  	double minLen = Math.Min (srcLower.Length' trgLower.Length);  	double maxLen = Math.Max (srcLower.Length' trgLower.Length);  	//Check whether the words may be transliterations (but only if they are not equal!  	if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  		double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  		if (maxTranslScore >= 0.7) {  			// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  			foundTranslits.Add (new StringProbabEntry (trgWord' prob));  			if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  				swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  			}  			continue;  		}  	}  	//Get the IDF score of the target and then check whether the IDF proportion is not too big (this deals only with stopwords).  	double trgIdf = trgIdfDict.ContainsKey (trgStem) ? trgIdfDict [trgStem] : maxTrgIdf;  	double trgAdjustedIdf = trgIdf * (maxSrcIdf / maxTrgIdf);  	double idfProp = Math.Min (srcIdf' trgAdjustedIdf) / Math.Max (srcIdf' trgAdjustedIdf);  	if (idfProp < idfPropThreshold) {  		idfFilterCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "IDF_FILTER");  		continue;  	}  	if (prob < absThreshold && dict [srcWord].Count > 1) {  		absThresholdCounter++;  		AppendToErr (srcWord' trgWord' prob' swe' "ABS_THRESHOLD_FILTER");  		continue;  	}  	validAfterMinimumIdf.Add (new StringProbabEntry (trgWord' prob' idfProp' trgStem));  	if (!maxStemDict.ContainsKey (trgStem))  		maxStemDict.Add (trgStem' prob);  	if (maxStemDict [trgStem] < prob)  		maxStemDict [trgStem] = prob;  	if (maxProb < prob)  		maxProb = prob;  	if (!maxStemCountDict.ContainsKey (trgStem))  		maxStemCountDict.Add (trgStem' 1);  	else  		maxStemCountDict [trgStem]++;  	if (maxStemCountDict [trgStem] > maxStemCount) {  		maxStemCount = maxStemCountDict [trgStem];  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  	double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  	if (maxTranslScore >= 0.7) {  		// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  		foundTranslits.Add (new StringProbabEntry (trgWord' prob));  		if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  			swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  		}  		continue;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  	double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  	if (maxTranslScore >= 0.7) {  		// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  		foundTranslits.Add (new StringProbabEntry (trgWord' prob));  		if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  			swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  		}  		continue;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  	double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  	if (maxTranslScore >= 0.7) {  		// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  		foundTranslits.Add (new StringProbabEntry (trgWord' prob));  		if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  			swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  		}  		continue;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (srcLower != trgLower && srcLower.Length >= 4 && trgLower.Length >= 4 && minLen / maxLen > 0.6) {  	double maxTranslScore = Math.Max (simpleTranslitScore' Math.Max (maxSrcTranslitScore' maxTrgTranslitScore));  	if (maxTranslScore >= 0.7) {  		// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  		foundTranslits.Add (new StringProbabEntry (trgWord' prob));  		if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  			swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  		}  		continue;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (maxTranslScore >= 0.7) {  	// || (maxTranslScore >= 0.6 && (sourceLang == "el"||targetLang == "el")) || (maxTranslScore >= 0.6 && (sourceLang == "ru"||targetLang == "ru"))) {  	foundTranslits.Add (new StringProbabEntry (trgWord' prob));  	if (IsValidPhrase (srcWord' sourceLang) && IsValidPhrase (trgWord' targetLang) && Char.IsLetter (srcWord [0]) && Char.IsLetter (trgWord [0])) {  		swt.WriteLine (srcWord + "\t" + trgWord + "\t" + maxTranslScore.ToString (nfi));  	}  	continue;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (StringProbabEntry spe in validAfterMinimumIdf) {  	if (validAfterMinimumIdf.Count > 1) {  		if (spe.probab >= updatedThr) {  			bool valid = true;  			foreach (StringProbabEntry tre in foundTranslits) {  				if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  					valid = false;  					translitFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  					swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  					break;  				}  			}  			if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  				heuristicFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  				valid = false;  			}  			if (valid) {  				sw.Write (srcWord);  				sw.Write (" ");  				sw.Write (spe.str);  				sw.Write (" ");  				sw.WriteLine (spe.probab.ToString (nfi));  				/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  			}  		}  		else {  			secondThresholdFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  		}  	}  	else if (foundTranslits.Count == 0) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" UNIQUE");  		uniqueCounter++;  		writtenCounter++;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (StringProbabEntry spe in validAfterMinimumIdf) {  	if (validAfterMinimumIdf.Count > 1) {  		if (spe.probab >= updatedThr) {  			bool valid = true;  			foreach (StringProbabEntry tre in foundTranslits) {  				if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  					valid = false;  					translitFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  					swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  					break;  				}  			}  			if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  				heuristicFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  				valid = false;  			}  			if (valid) {  				sw.Write (srcWord);  				sw.Write (" ");  				sw.Write (spe.str);  				sw.Write (" ");  				sw.WriteLine (spe.probab.ToString (nfi));  				/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  			}  		}  		else {  			secondThresholdFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  		}  	}  	else if (foundTranslits.Count == 0) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" UNIQUE");  		uniqueCounter++;  		writtenCounter++;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (StringProbabEntry spe in validAfterMinimumIdf) {  	if (validAfterMinimumIdf.Count > 1) {  		if (spe.probab >= updatedThr) {  			bool valid = true;  			foreach (StringProbabEntry tre in foundTranslits) {  				if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  					valid = false;  					translitFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  					swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  					break;  				}  			}  			if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  				heuristicFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  				valid = false;  			}  			if (valid) {  				sw.Write (srcWord);  				sw.Write (" ");  				sw.Write (spe.str);  				sw.Write (" ");  				sw.WriteLine (spe.probab.ToString (nfi));  				/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  			}  		}  		else {  			secondThresholdFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  		}  	}  	else if (foundTranslits.Count == 0) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" UNIQUE");  		uniqueCounter++;  		writtenCounter++;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (StringProbabEntry spe in validAfterMinimumIdf) {  	if (validAfterMinimumIdf.Count > 1) {  		if (spe.probab >= updatedThr) {  			bool valid = true;  			foreach (StringProbabEntry tre in foundTranslits) {  				if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  					valid = false;  					translitFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  					swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  					break;  				}  			}  			if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  				heuristicFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  				valid = false;  			}  			if (valid) {  				sw.Write (srcWord);  				sw.Write (" ");  				sw.Write (spe.str);  				sw.Write (" ");  				sw.WriteLine (spe.probab.ToString (nfi));  				/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  			}  		}  		else {  			secondThresholdFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  		}  	}  	else if (foundTranslits.Count == 0) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" UNIQUE");  		uniqueCounter++;  		writtenCounter++;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: foreach (StringProbabEntry spe in validAfterMinimumIdf) {  	if (validAfterMinimumIdf.Count > 1) {  		if (spe.probab >= updatedThr) {  			bool valid = true;  			foreach (StringProbabEntry tre in foundTranslits) {  				if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  					valid = false;  					translitFilterCounter++;  					AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  					swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  					break;  				}  			}  			if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  				heuristicFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  				valid = false;  			}  			if (valid) {  				sw.Write (srcWord);  				sw.Write (" ");  				sw.Write (spe.str);  				sw.Write (" ");  				sw.WriteLine (spe.probab.ToString (nfi));  				/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  			}  		}  		else {  			secondThresholdFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  		}  	}  	else if (foundTranslits.Count == 0) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		//sw.WriteLine (" UNIQUE");  		uniqueCounter++;  		writtenCounter++;  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (validAfterMinimumIdf.Count > 1) {  	if (spe.probab >= updatedThr) {  		bool valid = true;  		foreach (StringProbabEntry tre in foundTranslits) {  			if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  				valid = false;  				translitFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  				swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  				break;  			}  		}  		if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  			heuristicFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  			valid = false;  		}  		if (valid) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  		}  	}  	else {  		secondThresholdFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  	}  }  else if (foundTranslits.Count == 0) {  	sw.Write (srcWord);  	sw.Write (" ");  	sw.Write (spe.str);  	sw.Write (" ");  	sw.WriteLine (spe.probab.ToString (nfi));  	//sw.WriteLine (" UNIQUE");  	uniqueCounter++;  	writtenCounter++;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (validAfterMinimumIdf.Count > 1) {  	if (spe.probab >= updatedThr) {  		bool valid = true;  		foreach (StringProbabEntry tre in foundTranslits) {  			if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  				valid = false;  				translitFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  				swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  				break;  			}  		}  		if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  			heuristicFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  			valid = false;  		}  		if (valid) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  		}  	}  	else {  		secondThresholdFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  	}  }  else if (foundTranslits.Count == 0) {  	sw.Write (srcWord);  	sw.Write (" ");  	sw.Write (spe.str);  	sw.Write (" ");  	sw.WriteLine (spe.probab.ToString (nfi));  	//sw.WriteLine (" UNIQUE");  	uniqueCounter++;  	writtenCounter++;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (validAfterMinimumIdf.Count > 1) {  	if (spe.probab >= updatedThr) {  		bool valid = true;  		foreach (StringProbabEntry tre in foundTranslits) {  			if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  				valid = false;  				translitFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  				swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  				break;  			}  		}  		if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  			heuristicFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  			valid = false;  		}  		if (valid) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  		}  	}  	else {  		secondThresholdFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  	}  }  else if (foundTranslits.Count == 0) {  	sw.Write (srcWord);  	sw.Write (" ");  	sw.Write (spe.str);  	sw.Write (" ");  	sw.WriteLine (spe.probab.ToString (nfi));  	//sw.WriteLine (" UNIQUE");  	uniqueCounter++;  	writtenCounter++;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (validAfterMinimumIdf.Count > 1) {  	if (spe.probab >= updatedThr) {  		bool valid = true;  		foreach (StringProbabEntry tre in foundTranslits) {  			if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  				valid = false;  				translitFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  				swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  				break;  			}  		}  		if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  			heuristicFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  			valid = false;  		}  		if (valid) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  		}  	}  	else {  		secondThresholdFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  	}  }  else if (foundTranslits.Count == 0) {  	sw.Write (srcWord);  	sw.Write (" ");  	sw.Write (spe.str);  	sw.Write (" ");  	sw.WriteLine (spe.probab.ToString (nfi));  	//sw.WriteLine (" UNIQUE");  	uniqueCounter++;  	writtenCounter++;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (validAfterMinimumIdf.Count > 1) {  	if (spe.probab >= updatedThr) {  		bool valid = true;  		foreach (StringProbabEntry tre in foundTranslits) {  			if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  				valid = false;  				translitFilterCounter++;  				AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  				swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  				break;  			}  		}  		if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  			heuristicFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  			valid = false;  		}  		if (valid) {  			sw.Write (srcWord);  			sw.Write (" ");  			sw.Write (spe.str);  			sw.Write (" ");  			sw.WriteLine (spe.probab.ToString (nfi));  			/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  		}  	}  	else {  		secondThresholdFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  	}  }  else if (foundTranslits.Count == 0) {  	sw.Write (srcWord);  	sw.Write (" ");  	sw.Write (spe.str);  	sw.Write (" ");  	sw.WriteLine (spe.probab.ToString (nfi));  	//sw.WriteLine (" UNIQUE");  	uniqueCounter++;  	writtenCounter++;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (spe.probab >= updatedThr) {  	bool valid = true;  	foreach (StringProbabEntry tre in foundTranslits) {  		if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  			valid = false;  			translitFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  			swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  			break;  		}  	}  	if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  		heuristicFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  		valid = false;  	}  	if (valid) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  	}  }  else {  	secondThresholdFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (spe.probab >= updatedThr) {  	bool valid = true;  	foreach (StringProbabEntry tre in foundTranslits) {  		if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  			valid = false;  			translitFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  			swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  			break;  		}  	}  	if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  		heuristicFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  		valid = false;  	}  	if (valid) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  	}  }  else {  	secondThresholdFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (spe.probab >= updatedThr) {  	bool valid = true;  	foreach (StringProbabEntry tre in foundTranslits) {  		if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  			valid = false;  			translitFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  			swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  			break;  		}  	}  	if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  		heuristicFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  		valid = false;  	}  	if (valid) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  	}  }  else {  	secondThresholdFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (spe.probab >= updatedThr) {  	bool valid = true;  	foreach (StringProbabEntry tre in foundTranslits) {  		if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  			valid = false;  			translitFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  			swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  			break;  		}  	}  	if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  		heuristicFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  		valid = false;  	}  	if (valid) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  	}  }  else {  	secondThresholdFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (spe.probab >= updatedThr) {  	bool valid = true;  	foreach (StringProbabEntry tre in foundTranslits) {  		if (spe.str.ToLower ().Contains (tre.str.ToLower ())) {  			valid = false;  			translitFilterCounter++;  			AppendToErr (srcWord' spe.str' spe.probab' swe' "TRANSLITERATION_FILTER");  			swte.WriteLine (srcWord + "\t" + spe.str' spe.probab.ToString (nfi));  			break;  		}  	}  	if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  		heuristicFilterCounter++;  		AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  		valid = false;  	}  	if (valid) {  		sw.Write (srcWord);  		sw.Write (" ");  		sw.Write (spe.str);  		sw.Write (" ");  		sw.WriteLine (spe.probab.ToString (nfi));  		/*sw.Write (" OVER_THRESHOLD"); 								sw.Write (" "); 								sw.Write (spe.idf); 								sw.Write (" "); 								sw.Write (spe.stem); 								sw.Write (" "); 								sw.WriteLine (maxStemDict[spe.stem]);*/writtenCounter++;  	}  }  else {  	secondThresholdFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "SECOND_THRESHOLD_FILTER");  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  	heuristicFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  	valid = false;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  	heuristicFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  	valid = false;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  	heuristicFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  	valid = false;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  	heuristicFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  	valid = false;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: if (valid && ((spe.str == srcWord && foundTranslits.Count + validAfterMinimumIdf.Count > 3) || (maxStemDict [spe.stem] < (maxProb / 2)) || (maxStemCount >= 3 && maxStemCountDict [spe.stem] < 2) || (spe.probab == 1 && maxStemCountDict [spe.stem] == 1 && foundTranslits.Count + validAfterMinimumIdf.Count >= 5))) {  	heuristicFilterCounter++;  	AppendToErr (srcWord' spe.str' spe.probab' swe' "HEURISTIC_FILTER");  	valid = false;  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = idfFilterCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = absThresholdCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = secondThresholdFilterCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = translitFilterCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = heuristicFilterCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = translCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = uniqueCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,Main,The following statement contains a magic number: proc = writtenCounter / totalCounter * 100;  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,The following statement contains a magic number: while (!sr.EndOfStream) {  	string line = sr.ReadLine ().Trim ();  	try {  		if (!string.IsNullOrWhiteSpace (line)) {  			string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  			if (arr.Length >= 2) {  				string tok = arr [0].Trim ().ToLower ();  				double prob = Convert.ToDouble (arr [1]' nfi);  				string stem = "";  				if (stemDictionary [lang].ContainsKey (tok)) {  					stem = stemDictionary [lang] [tok];  				}  				else {  					stem = stemmer.StemWord (tok);  					stemDictionary [lang].Add (tok' stem);  				}  				if (!res.ContainsKey (stem)) {  					res.Add (stem' prob);  				}  				else {  					if (res [stem] > prob) {  						res [stem] = prob;  					}  				}  			}  		}  	}  	catch {  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,The following statement contains a magic number: try {  	if (!string.IsNullOrWhiteSpace (line)) {  		string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (arr.Length >= 2) {  			string tok = arr [0].Trim ().ToLower ();  			double prob = Convert.ToDouble (arr [1]' nfi);  			string stem = "";  			if (stemDictionary [lang].ContainsKey (tok)) {  				stem = stemDictionary [lang] [tok];  			}  			else {  				stem = stemmer.StemWord (tok);  				stemDictionary [lang].Add (tok' stem);  			}  			if (!res.ContainsKey (stem)) {  				res.Add (stem' prob);  			}  			else {  				if (res [stem] > prob) {  					res [stem] = prob;  				}  			}  		}  	}  }  catch {  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace (line)) {  	string[] arr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  	if (arr.Length >= 2) {  		string tok = arr [0].Trim ().ToLower ();  		double prob = Convert.ToDouble (arr [1]' nfi);  		string stem = "";  		if (stemDictionary [lang].ContainsKey (tok)) {  			stem = stemDictionary [lang] [tok];  		}  		else {  			stem = stemmer.StemWord (tok);  			stemDictionary [lang].Add (tok' stem);  		}  		if (!res.ContainsKey (stem)) {  			res.Add (stem' prob);  		}  		else {  			if (res [stem] > prob) {  				res [stem] = prob;  			}  		}  	}  }  
Magic Number,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,ParseIdfFile,The following statement contains a magic number: if (arr.Length >= 2) {  	string tok = arr [0].Trim ().ToLower ();  	double prob = Convert.ToDouble (arr [1]' nfi);  	string stem = "";  	if (stemDictionary [lang].ContainsKey (tok)) {  		stem = stemDictionary [lang] [tok];  	}  	else {  		stem = stemmer.StemWord (tok);  		stemDictionary [lang].Add (tok' stem);  	}  	if (!res.ContainsKey (stem)) {  		res.Add (stem' prob);  	}  	else {  		if (res [stem] > prob) {  			res [stem] = prob;  		}  	}  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: for (i = 0; i < text.Length; i++) {  	if (char.IsWhiteSpace (text [i])) {  		if (pos != -1 && i - pos > 0) {  			string stemmedWord = StemWord (text.Substring (pos' i - pos));  			if (stemmedWord.Length > 4) {  				stemmedWord = stemmedWord.Substring (0' 4);  			}  			stemmed.Add (stemmedWord);  		}  		pos = -1;  	}  	else {  		if (pos == -1)  			pos = i;  	}  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: for (i = 0; i < text.Length; i++) {  	if (char.IsWhiteSpace (text [i])) {  		if (pos != -1 && i - pos > 0) {  			string stemmedWord = StemWord (text.Substring (pos' i - pos));  			if (stemmedWord.Length > 4) {  				stemmedWord = stemmedWord.Substring (0' 4);  			}  			stemmed.Add (stemmedWord);  		}  		pos = -1;  	}  	else {  		if (pos == -1)  			pos = i;  	}  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (char.IsWhiteSpace (text [i])) {  	if (pos != -1 && i - pos > 0) {  		string stemmedWord = StemWord (text.Substring (pos' i - pos));  		if (stemmedWord.Length > 4) {  			stemmedWord = stemmedWord.Substring (0' 4);  		}  		stemmed.Add (stemmedWord);  	}  	pos = -1;  }  else {  	if (pos == -1)  		pos = i;  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (char.IsWhiteSpace (text [i])) {  	if (pos != -1 && i - pos > 0) {  		string stemmedWord = StemWord (text.Substring (pos' i - pos));  		if (stemmedWord.Length > 4) {  			stemmedWord = stemmedWord.Substring (0' 4);  		}  		stemmed.Add (stemmedWord);  	}  	pos = -1;  }  else {  	if (pos == -1)  		pos = i;  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (pos != -1 && i - pos > 0) {  	string stemmedWord = StemWord (text.Substring (pos' i - pos));  	if (stemmedWord.Length > 4) {  		stemmedWord = stemmedWord.Substring (0' 4);  	}  	stemmed.Add (stemmedWord);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (pos != -1 && i - pos > 0) {  	string stemmedWord = StemWord (text.Substring (pos' i - pos));  	if (stemmedWord.Length > 4) {  		stemmedWord = stemmedWord.Substring (0' 4);  	}  	stemmed.Add (stemmedWord);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: stemmedWord = stemmedWord.Substring (0' 4);  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (pos != -1 && i - pos > 0) {  	string stemmedWord = StemWord (text.Substring (pos' i - pos));  	if (stemmedWord.Length > 4) {  		stemmedWord = stemmedWord.Substring (0' 4);  	}  	stemmed.Add (stemmedWord);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (pos != -1 && i - pos > 0) {  	string stemmedWord = StemWord (text.Substring (pos' i - pos));  	if (stemmedWord.Length > 4) {  		stemmedWord = stemmedWord.Substring (0' 4);  	}  	stemmed.Add (stemmedWord);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStem,The following statement contains a magic number: stemmedWord = stemmedWord.Substring (0' 4);  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStemWord,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStemWord,The following statement contains a magic number: if (stemmedWord.Length > 4) {  	stemmedWord = stemmedWord.Substring (0' 4);  }  
Magic Number,FilterGizaDictionary,Stemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,NGramStemWord,The following statement contains a magic number: stemmedWord = stemmedWord.Substring (0' 4);  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: if (word.Length < 4)  	return word;  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: if (word.Length == 4)  	return word.Substring (0' word.Length - 1);  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: if (word.Length < 7)  	return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: if (word.Length < 7)  	return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,GenericStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemWord,The following statement contains a magic number: return word.Substring (0' word.Length - 3);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep0,The following statement contains a magic number: if (word.EndsWith ("\'s"))  	return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep0,The following statement contains a magic number: return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step1Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		if (step1Endings [end5] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end5]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step1Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		if (step1Endings [end5] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end5]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step1Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		if (step1Endings [end5] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end5]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (step1Endings.ContainsKey (end5)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 5));  	if (step1Endings [end5] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  		sb.Append ("ble");  		return sb.ToString ();  	}  	else {  		sb.Append (step1Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 5));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step1Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		if (step1Endings [end4] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end4]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step1Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		if (step1Endings [end4] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end4]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step1Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		if (step1Endings [end4] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  			sb.Append ("ble");  			return sb.ToString ();  		}  		else {  			sb.Append (step1Endings [end4]);  			return sb.ToString ();  		}  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (step1Endings.ContainsKey (end4)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 4));  	if (step1Endings [end4] == "bl" && sb.ToString ().IndexOfAny (vowels) >= 0) {  		sb.Append ("ble");  		return sb.ToString ();  	}  	else {  		sb.Append (step1Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 4));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step1Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step1Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step1Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step1Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step1Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step1Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (step1Endings.ContainsKey (end3)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 3));  	sb.Append (step1Endings [end3]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 3));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step1Endings.ContainsKey (end2)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 2));  		sb.Append (step1Endings [end2]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step1Endings.ContainsKey (end2)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 2));  		sb.Append (step1Endings [end2]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step1Endings.ContainsKey (end2)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 2));  		sb.Append (step1Endings [end2]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: if (step1Endings.ContainsKey (end2)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 2));  	sb.Append (step1Endings [end2]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep1,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 2));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 7) {  	string end7 = word.Substring (word.Length - 7);  	if (step3Endings.ContainsKey (end7)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 7));  		sb.Append (step3Endings [end7]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 7) {  	string end7 = word.Substring (word.Length - 7);  	if (step3Endings.ContainsKey (end7)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 7));  		sb.Append (step3Endings [end7]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 7) {  	string end7 = word.Substring (word.Length - 7);  	if (step3Endings.ContainsKey (end7)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 7));  		sb.Append (step3Endings [end7]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (step3Endings.ContainsKey (end7)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 7));  	sb.Append (step3Endings [end7]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 7));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 6) {  	string end6 = word.Substring (word.Length - 6);  	if (step3Endings.ContainsKey (end6)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 6));  		sb.Append (step3Endings [end6]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 6) {  	string end6 = word.Substring (word.Length - 6);  	if (step3Endings.ContainsKey (end6)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 6));  		sb.Append (step3Endings [end6]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 6) {  	string end6 = word.Substring (word.Length - 6);  	if (step3Endings.ContainsKey (end6)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 6));  		sb.Append (step3Endings [end6]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (step3Endings.ContainsKey (end6)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 6));  	sb.Append (step3Endings [end6]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 6));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step3Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step3Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step3Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step3Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step3Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step3Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (step3Endings.ContainsKey (end5)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 5));  	sb.Append (step3Endings [end5]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 5));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step3Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step3Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step3Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step3Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step3Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step3Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (step3Endings.ContainsKey (end4)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 4));  	sb.Append (step3Endings [end4]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 4));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step3Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step3Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step3Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step3Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step3Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step3Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: if (step3Endings.ContainsKey (end3)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 3));  	sb.Append (step3Endings [end3]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep3,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 3));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step4Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step4Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step4Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step4Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step4Endings.ContainsKey (end5)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 5));  		sb.Append (step4Endings [end5]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (step4Endings.ContainsKey (end5)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 5));  	sb.Append (step4Endings [end5]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 5));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step4Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step4Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step4Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step4Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step4Endings.ContainsKey (end4)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 4));  		sb.Append (step4Endings [end4]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (step4Endings.ContainsKey (end4)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 4));  	sb.Append (step4Endings [end4]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 4));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step4Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step4Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step4Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step4Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step4Endings.ContainsKey (end3)) {  		StringBuilder sb = new StringBuilder ();  		sb.Append (word.Substring (0' word.Length - 3));  		sb.Append (step4Endings [end3]);  		return sb.ToString ();  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: if (step4Endings.ContainsKey (end3)) {  	StringBuilder sb = new StringBuilder ();  	sb.Append (word.Substring (0' word.Length - 3));  	sb.Append (step4Endings [end3]);  	return sb.ToString ();  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep4,The following statement contains a magic number: sb.Append (word.Substring (0' word.Length - 3));  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step5Endings.ContainsKey (end5)) {  		return word.Substring (0' word.Length - 5);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step5Endings.ContainsKey (end5)) {  		return word.Substring (0' word.Length - 5);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 5) {  	string end5 = word.Substring (word.Length - 5);  	if (step5Endings.ContainsKey (end5)) {  		return word.Substring (0' word.Length - 5);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (step5Endings.ContainsKey (end5)) {  	return word.Substring (0' word.Length - 5);  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: return word.Substring (0' word.Length - 5);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step5Endings.ContainsKey (end4)) {  		return word.Substring (0' word.Length - 4);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step5Endings.ContainsKey (end4)) {  		return word.Substring (0' word.Length - 4);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 4) {  	string end4 = word.Substring (word.Length - 4);  	if (step5Endings.ContainsKey (end4)) {  		return word.Substring (0' word.Length - 4);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (step5Endings.ContainsKey (end4)) {  	return word.Substring (0' word.Length - 4);  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: return word.Substring (0' word.Length - 4);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step5Endings.ContainsKey (end3)) {  		return word.Substring (0' word.Length - 3);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step5Endings.ContainsKey (end3)) {  		return word.Substring (0' word.Length - 3);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 3) {  	string end3 = word.Substring (word.Length - 3);  	if (step5Endings.ContainsKey (end3)) {  		return word.Substring (0' word.Length - 3);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (step5Endings.ContainsKey (end3)) {  	return word.Substring (0' word.Length - 3);  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: return word.Substring (0' word.Length - 3);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step5Endings.ContainsKey (end2)) {  		return word.Substring (0' word.Length - 2);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step5Endings.ContainsKey (end2)) {  		return word.Substring (0' word.Length - 2);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (word.Length >= MinStemLength + 2) {  	string end2 = word.Substring (word.Length - 2);  	if (step5Endings.ContainsKey (end2)) {  		return word.Substring (0' word.Length - 2);  	}  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: if (step5Endings.ContainsKey (end2)) {  	return word.Substring (0' word.Length - 2);  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep5,The following statement contains a magic number: return word.Substring (0' word.Length - 2);  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep6,The following statement contains a magic number: if (word.Length >= MinStemLength && word.EndsWith ("e") && cvc (word [word.Length - 3]' word [word.Length - 2]' word [word.Length - 1])) {  	res = res.Substring (0' res.Length - 1);  }  
Magic Number,FilterGizaDictionary,FullEngilshStemmer,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Stemmers.cs,StemStep6,The following statement contains a magic number: if (word.Length >= MinStemLength && word.EndsWith ("e") && cvc (word [word.Length - 3]' word [word.Length - 2]' word [word.Length - 1])) {  	res = res.Substring (0' res.Length - 1);  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: for (int i = 0; i < lowerCasedTermDictList.Count; i++) {  	if (lowerCasedTermDictList [i].Count > 0) {  		string tmpFile = tempFilePath + i.ToString () + ".tmp";  		if (File.Exists (tmpFile + ".n_best")) {  			NumberFormatInfo nfi = new NumberFormatInfo ();  			nfi.CurrencyDecimalSeparator = ".";  			nfi.NumberDecimalSeparator = ".";  			nfi.PercentDecimalSeparator = ".";  			Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  			StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  			string[] sep =  {  				"|||"  			};  			while (!sr.EndOfStream) {  				string line = sr.ReadLine ();  				string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  				if (dataArr.Length == 4) {  					try {  						string idStr = dataArr [0];  						idStr = idStr.Trim ();  						int id = Convert.ToInt32 (idStr);  						string word = dataArr [1];  						StringProbabEntry spe = new StringProbabEntry ();  						spe.str = word.Trim ().Replace (" "' "");  						string probabStr = dataArr [3];  						probabStr = probabStr.Trim ().Replace ('''' '.');  						spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  						if (spe.probab > 1)  							spe.probab = 1;  						if (id < lowerCasedTermDictList [i].Count) {  							string term = lowerCasedTermDictList [i] [id];  							double min = Math.Min (spe.str.Length' term.Length);  							double max = Math.Max (spe.str.Length' term.Length);  							double lenDiff = min / max;  							//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  							if (lenDiff >= tc.maxLenDiff) {  								if (!existingTranslits.ContainsKey (term))  									existingTranslits.Add (term' new Dictionary<string' bool> ());  								if (!res.ContainsKey (term))  									res.Add (term' new List<StringProbabEntry> ());  								if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  									existingTranslits [term].Add (spe.str' true);  									res [term].Add (spe);  								}  							}  						}  					}  					catch {  					}  				}  			}  			sr.Close ();  		}  		try {  			File.Delete (tmpFile + ".n_best");  			File.Delete (tmpFile);  		}  		catch {  		}  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: for (int i = 0; i < lowerCasedTermDictList.Count; i++) {  	if (lowerCasedTermDictList [i].Count > 0) {  		string tmpFile = tempFilePath + i.ToString () + ".tmp";  		if (File.Exists (tmpFile + ".n_best")) {  			NumberFormatInfo nfi = new NumberFormatInfo ();  			nfi.CurrencyDecimalSeparator = ".";  			nfi.NumberDecimalSeparator = ".";  			nfi.PercentDecimalSeparator = ".";  			Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  			StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  			string[] sep =  {  				"|||"  			};  			while (!sr.EndOfStream) {  				string line = sr.ReadLine ();  				string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  				if (dataArr.Length == 4) {  					try {  						string idStr = dataArr [0];  						idStr = idStr.Trim ();  						int id = Convert.ToInt32 (idStr);  						string word = dataArr [1];  						StringProbabEntry spe = new StringProbabEntry ();  						spe.str = word.Trim ().Replace (" "' "");  						string probabStr = dataArr [3];  						probabStr = probabStr.Trim ().Replace ('''' '.');  						spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  						if (spe.probab > 1)  							spe.probab = 1;  						if (id < lowerCasedTermDictList [i].Count) {  							string term = lowerCasedTermDictList [i] [id];  							double min = Math.Min (spe.str.Length' term.Length);  							double max = Math.Max (spe.str.Length' term.Length);  							double lenDiff = min / max;  							//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  							if (lenDiff >= tc.maxLenDiff) {  								if (!existingTranslits.ContainsKey (term))  									existingTranslits.Add (term' new Dictionary<string' bool> ());  								if (!res.ContainsKey (term))  									res.Add (term' new List<StringProbabEntry> ());  								if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  									existingTranslits [term].Add (spe.str' true);  									res [term].Add (spe);  								}  							}  						}  					}  					catch {  					}  				}  			}  			sr.Close ();  		}  		try {  			File.Delete (tmpFile + ".n_best");  			File.Delete (tmpFile);  		}  		catch {  		}  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (lowerCasedTermDictList [i].Count > 0) {  	string tmpFile = tempFilePath + i.ToString () + ".tmp";  	if (File.Exists (tmpFile + ".n_best")) {  		NumberFormatInfo nfi = new NumberFormatInfo ();  		nfi.CurrencyDecimalSeparator = ".";  		nfi.NumberDecimalSeparator = ".";  		nfi.PercentDecimalSeparator = ".";  		Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  		StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  		string[] sep =  {  			"|||"  		};  		while (!sr.EndOfStream) {  			string line = sr.ReadLine ();  			string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  			if (dataArr.Length == 4) {  				try {  					string idStr = dataArr [0];  					idStr = idStr.Trim ();  					int id = Convert.ToInt32 (idStr);  					string word = dataArr [1];  					StringProbabEntry spe = new StringProbabEntry ();  					spe.str = word.Trim ().Replace (" "' "");  					string probabStr = dataArr [3];  					probabStr = probabStr.Trim ().Replace ('''' '.');  					spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  					if (spe.probab > 1)  						spe.probab = 1;  					if (id < lowerCasedTermDictList [i].Count) {  						string term = lowerCasedTermDictList [i] [id];  						double min = Math.Min (spe.str.Length' term.Length);  						double max = Math.Max (spe.str.Length' term.Length);  						double lenDiff = min / max;  						//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  						if (lenDiff >= tc.maxLenDiff) {  							if (!existingTranslits.ContainsKey (term))  								existingTranslits.Add (term' new Dictionary<string' bool> ());  							if (!res.ContainsKey (term))  								res.Add (term' new List<StringProbabEntry> ());  							if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  								existingTranslits [term].Add (spe.str' true);  								res [term].Add (spe);  							}  						}  					}  				}  				catch {  				}  			}  		}  		sr.Close ();  	}  	try {  		File.Delete (tmpFile + ".n_best");  		File.Delete (tmpFile);  	}  	catch {  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (lowerCasedTermDictList [i].Count > 0) {  	string tmpFile = tempFilePath + i.ToString () + ".tmp";  	if (File.Exists (tmpFile + ".n_best")) {  		NumberFormatInfo nfi = new NumberFormatInfo ();  		nfi.CurrencyDecimalSeparator = ".";  		nfi.NumberDecimalSeparator = ".";  		nfi.PercentDecimalSeparator = ".";  		Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  		StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  		string[] sep =  {  			"|||"  		};  		while (!sr.EndOfStream) {  			string line = sr.ReadLine ();  			string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  			if (dataArr.Length == 4) {  				try {  					string idStr = dataArr [0];  					idStr = idStr.Trim ();  					int id = Convert.ToInt32 (idStr);  					string word = dataArr [1];  					StringProbabEntry spe = new StringProbabEntry ();  					spe.str = word.Trim ().Replace (" "' "");  					string probabStr = dataArr [3];  					probabStr = probabStr.Trim ().Replace ('''' '.');  					spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  					if (spe.probab > 1)  						spe.probab = 1;  					if (id < lowerCasedTermDictList [i].Count) {  						string term = lowerCasedTermDictList [i] [id];  						double min = Math.Min (spe.str.Length' term.Length);  						double max = Math.Max (spe.str.Length' term.Length);  						double lenDiff = min / max;  						//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  						if (lenDiff >= tc.maxLenDiff) {  							if (!existingTranslits.ContainsKey (term))  								existingTranslits.Add (term' new Dictionary<string' bool> ());  							if (!res.ContainsKey (term))  								res.Add (term' new List<StringProbabEntry> ());  							if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  								existingTranslits [term].Add (spe.str' true);  								res [term].Add (spe);  							}  						}  					}  				}  				catch {  				}  			}  		}  		sr.Close ();  	}  	try {  		File.Delete (tmpFile + ".n_best");  		File.Delete (tmpFile);  	}  	catch {  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (File.Exists (tmpFile + ".n_best")) {  	NumberFormatInfo nfi = new NumberFormatInfo ();  	nfi.CurrencyDecimalSeparator = ".";  	nfi.NumberDecimalSeparator = ".";  	nfi.PercentDecimalSeparator = ".";  	Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  	StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  	string[] sep =  {  		"|||"  	};  	while (!sr.EndOfStream) {  		string line = sr.ReadLine ();  		string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (dataArr.Length == 4) {  			try {  				string idStr = dataArr [0];  				idStr = idStr.Trim ();  				int id = Convert.ToInt32 (idStr);  				string word = dataArr [1];  				StringProbabEntry spe = new StringProbabEntry ();  				spe.str = word.Trim ().Replace (" "' "");  				string probabStr = dataArr [3];  				probabStr = probabStr.Trim ().Replace ('''' '.');  				spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  				if (spe.probab > 1)  					spe.probab = 1;  				if (id < lowerCasedTermDictList [i].Count) {  					string term = lowerCasedTermDictList [i] [id];  					double min = Math.Min (spe.str.Length' term.Length);  					double max = Math.Max (spe.str.Length' term.Length);  					double lenDiff = min / max;  					//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  					if (lenDiff >= tc.maxLenDiff) {  						if (!existingTranslits.ContainsKey (term))  							existingTranslits.Add (term' new Dictionary<string' bool> ());  						if (!res.ContainsKey (term))  							res.Add (term' new List<StringProbabEntry> ());  						if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  							existingTranslits [term].Add (spe.str' true);  							res [term].Add (spe);  						}  					}  				}  			}  			catch {  			}  		}  	}  	sr.Close ();  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (File.Exists (tmpFile + ".n_best")) {  	NumberFormatInfo nfi = new NumberFormatInfo ();  	nfi.CurrencyDecimalSeparator = ".";  	nfi.NumberDecimalSeparator = ".";  	nfi.PercentDecimalSeparator = ".";  	Dictionary<string' Dictionary<string' bool>> existingTranslits = new Dictionary<string' Dictionary<string' bool>> ();  	StreamReader sr = new StreamReader (tmpFile + ".n_best"' Encoding.UTF8);  	string[] sep =  {  		"|||"  	};  	while (!sr.EndOfStream) {  		string line = sr.ReadLine ();  		string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  		if (dataArr.Length == 4) {  			try {  				string idStr = dataArr [0];  				idStr = idStr.Trim ();  				int id = Convert.ToInt32 (idStr);  				string word = dataArr [1];  				StringProbabEntry spe = new StringProbabEntry ();  				spe.str = word.Trim ().Replace (" "' "");  				string probabStr = dataArr [3];  				probabStr = probabStr.Trim ().Replace ('''' '.');  				spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  				if (spe.probab > 1)  					spe.probab = 1;  				if (id < lowerCasedTermDictList [i].Count) {  					string term = lowerCasedTermDictList [i] [id];  					double min = Math.Min (spe.str.Length' term.Length);  					double max = Math.Max (spe.str.Length' term.Length);  					double lenDiff = min / max;  					//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  					if (lenDiff >= tc.maxLenDiff) {  						if (!existingTranslits.ContainsKey (term))  							existingTranslits.Add (term' new Dictionary<string' bool> ());  						if (!res.ContainsKey (term))  							res.Add (term' new List<StringProbabEntry> ());  						if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  							existingTranslits [term].Add (spe.str' true);  							res [term].Add (spe);  						}  					}  				}  			}  			catch {  			}  		}  	}  	sr.Close ();  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: while (!sr.EndOfStream) {  	string line = sr.ReadLine ();  	string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  	if (dataArr.Length == 4) {  		try {  			string idStr = dataArr [0];  			idStr = idStr.Trim ();  			int id = Convert.ToInt32 (idStr);  			string word = dataArr [1];  			StringProbabEntry spe = new StringProbabEntry ();  			spe.str = word.Trim ().Replace (" "' "");  			string probabStr = dataArr [3];  			probabStr = probabStr.Trim ().Replace ('''' '.');  			spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  			if (spe.probab > 1)  				spe.probab = 1;  			if (id < lowerCasedTermDictList [i].Count) {  				string term = lowerCasedTermDictList [i] [id];  				double min = Math.Min (spe.str.Length' term.Length);  				double max = Math.Max (spe.str.Length' term.Length);  				double lenDiff = min / max;  				//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  				if (lenDiff >= tc.maxLenDiff) {  					if (!existingTranslits.ContainsKey (term))  						existingTranslits.Add (term' new Dictionary<string' bool> ());  					if (!res.ContainsKey (term))  						res.Add (term' new List<StringProbabEntry> ());  					if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  						existingTranslits [term].Add (spe.str' true);  						res [term].Add (spe);  					}  				}  			}  		}  		catch {  		}  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: while (!sr.EndOfStream) {  	string line = sr.ReadLine ();  	string[] dataArr = line.Split (sep' StringSplitOptions.RemoveEmptyEntries);  	if (dataArr.Length == 4) {  		try {  			string idStr = dataArr [0];  			idStr = idStr.Trim ();  			int id = Convert.ToInt32 (idStr);  			string word = dataArr [1];  			StringProbabEntry spe = new StringProbabEntry ();  			spe.str = word.Trim ().Replace (" "' "");  			string probabStr = dataArr [3];  			probabStr = probabStr.Trim ().Replace ('''' '.');  			spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  			if (spe.probab > 1)  				spe.probab = 1;  			if (id < lowerCasedTermDictList [i].Count) {  				string term = lowerCasedTermDictList [i] [id];  				double min = Math.Min (spe.str.Length' term.Length);  				double max = Math.Max (spe.str.Length' term.Length);  				double lenDiff = min / max;  				//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  				if (lenDiff >= tc.maxLenDiff) {  					if (!existingTranslits.ContainsKey (term))  						existingTranslits.Add (term' new Dictionary<string' bool> ());  					if (!res.ContainsKey (term))  						res.Add (term' new List<StringProbabEntry> ());  					if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  						existingTranslits [term].Add (spe.str' true);  						res [term].Add (spe);  					}  				}  			}  		}  		catch {  		}  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (dataArr.Length == 4) {  	try {  		string idStr = dataArr [0];  		idStr = idStr.Trim ();  		int id = Convert.ToInt32 (idStr);  		string word = dataArr [1];  		StringProbabEntry spe = new StringProbabEntry ();  		spe.str = word.Trim ().Replace (" "' "");  		string probabStr = dataArr [3];  		probabStr = probabStr.Trim ().Replace ('''' '.');  		spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  		if (spe.probab > 1)  			spe.probab = 1;  		if (id < lowerCasedTermDictList [i].Count) {  			string term = lowerCasedTermDictList [i] [id];  			double min = Math.Min (spe.str.Length' term.Length);  			double max = Math.Max (spe.str.Length' term.Length);  			double lenDiff = min / max;  			//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  			if (lenDiff >= tc.maxLenDiff) {  				if (!existingTranslits.ContainsKey (term))  					existingTranslits.Add (term' new Dictionary<string' bool> ());  				if (!res.ContainsKey (term))  					res.Add (term' new List<StringProbabEntry> ());  				if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  					existingTranslits [term].Add (spe.str' true);  					res [term].Add (spe);  				}  			}  		}  	}  	catch {  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: if (dataArr.Length == 4) {  	try {  		string idStr = dataArr [0];  		idStr = idStr.Trim ();  		int id = Convert.ToInt32 (idStr);  		string word = dataArr [1];  		StringProbabEntry spe = new StringProbabEntry ();  		spe.str = word.Trim ().Replace (" "' "");  		string probabStr = dataArr [3];  		probabStr = probabStr.Trim ().Replace ('''' '.');  		spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  		if (spe.probab > 1)  			spe.probab = 1;  		if (id < lowerCasedTermDictList [i].Count) {  			string term = lowerCasedTermDictList [i] [id];  			double min = Math.Min (spe.str.Length' term.Length);  			double max = Math.Max (spe.str.Length' term.Length);  			double lenDiff = min / max;  			//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  			if (lenDiff >= tc.maxLenDiff) {  				if (!existingTranslits.ContainsKey (term))  					existingTranslits.Add (term' new Dictionary<string' bool> ());  				if (!res.ContainsKey (term))  					res.Add (term' new List<StringProbabEntry> ());  				if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  					existingTranslits [term].Add (spe.str' true);  					res [term].Add (spe);  				}  			}  		}  	}  	catch {  	}  }  
Magic Number,FilterGizaDictionary,TransliterationModule,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\TransliterationModule.cs,GetTransliterations,The following statement contains a magic number: try {  	string idStr = dataArr [0];  	idStr = idStr.Trim ();  	int id = Convert.ToInt32 (idStr);  	string word = dataArr [1];  	StringProbabEntry spe = new StringProbabEntry ();  	spe.str = word.Trim ().Replace (" "' "");  	string probabStr = dataArr [3];  	probabStr = probabStr.Trim ().Replace ('''' '.');  	spe.probab = Math.Exp (Convert.ToDouble (probabStr' nfi));  	if (spe.probab > 1)  		spe.probab = 1;  	if (id < lowerCasedTermDictList [i].Count) {  		string term = lowerCasedTermDictList [i] [id];  		double min = Math.Min (spe.str.Length' term.Length);  		double max = Math.Max (spe.str.Length' term.Length);  		double lenDiff = min / max;  		//Log.Write(term+" "+word+" "+lenDiff.ToString()+" "+spe.probab.ToString()'LogLevelType.ERROR);  		if (lenDiff >= tc.maxLenDiff) {  			if (!existingTranslits.ContainsKey (term))  				existingTranslits.Add (term' new Dictionary<string' bool> ());  			if (!res.ContainsKey (term))  				res.Add (term' new List<StringProbabEntry> ());  			if (!existingTranslits [term].ContainsKey (spe.str) && spe.probab >= tc.thr) {  				existingTranslits [term].Add (spe.str' true);  				res [term].Add (spe);  			}  		}  	}  }  catch {  }  
Missing Default,FilterGizaDictionary,MainClass,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\Program.cs,IsValidPhrase,The following switch statement is missing a default case: switch (language.ToUpper ()) {  case "BG":  	baseAlphabet = ValidAlphabets.BG;  	break;  case "CS":  	baseAlphabet = ValidAlphabets.CS;  	break;  case "CA":  	baseAlphabet = ValidAlphabets.CA;  	break;  case "CY":  	baseAlphabet = ValidAlphabets.CY;  	break;  case "DA":  	baseAlphabet = ValidAlphabets.DA;  	break;  case "DE":  	baseAlphabet = ValidAlphabets.DE;  	break;  case "EL":  	baseAlphabet = ValidAlphabets.EL;  	break;  case "EN":  	baseAlphabet = ValidAlphabets.EN;  	break;  case "ES":  	baseAlphabet = ValidAlphabets.ES;  	break;  case "ET":  	baseAlphabet = ValidAlphabets.ET;  	break;  case "EU":  	baseAlphabet = ValidAlphabets.EU;  	break;  case "FI":  	baseAlphabet = ValidAlphabets.FI;  	break;  case "FR":  	baseAlphabet = ValidAlphabets.FR;  	break;  case "GA":  	baseAlphabet = ValidAlphabets.GA;  	break;  case "GD":  	baseAlphabet = ValidAlphabets.GD;  	break;  case "GL":  	baseAlphabet = ValidAlphabets.GL;  	break;  case "HR":  	baseAlphabet = ValidAlphabets.HR;  	break;  case "HU":  	baseAlphabet = ValidAlphabets.HU;  	break;  case "HI":  	baseAlphabet = ValidAlphabets.HI;  	break;  case "IT":  	baseAlphabet = ValidAlphabets.IT;  	break;  case "LT":  	baseAlphabet = ValidAlphabets.LT;  	break;  case "LV":  	baseAlphabet = ValidAlphabets.LV;  	break;  case "MT":  	baseAlphabet = ValidAlphabets.MT;  	break;  case "NL":  	baseAlphabet = ValidAlphabets.NL;  	break;  case "PL":  	baseAlphabet = ValidAlphabets.PL;  	break;  case "PT":  	baseAlphabet = ValidAlphabets.PT;  	break;  case "RO":  	baseAlphabet = ValidAlphabets.RO;  	break;  case "RU":  	baseAlphabet = ValidAlphabets.RU;  	break;  case "SK":  	baseAlphabet = ValidAlphabets.SK;  	break;  case "SL":  	baseAlphabet = ValidAlphabets.SL;  	break;  case "SV":  	baseAlphabet = ValidAlphabets.SV;  	break;  case "TR":  	baseAlphabet = ValidAlphabets.TR;  	break;  case "UR":  	baseAlphabet = ValidAlphabets.UR;  	break;  }  
Missing Default,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,GetAlphabet,The following switch statement is missing a default case: switch (language.ToUpper ()) {  case "BG":  	baseAlphabet = ValidAlphabets.BG;  	break;  case "CS":  	baseAlphabet = ValidAlphabets.CS;  	break;  case "CA":  	baseAlphabet = ValidAlphabets.CA;  	break;  case "CY":  	baseAlphabet = ValidAlphabets.CY;  	break;  case "DA":  	baseAlphabet = ValidAlphabets.DA;  	break;  case "DE":  	baseAlphabet = ValidAlphabets.DE;  	break;  case "EL":  	baseAlphabet = ValidAlphabets.EL;  	break;  case "EN":  	baseAlphabet = ValidAlphabets.EN;  	break;  case "ES":  	baseAlphabet = ValidAlphabets.ES;  	break;  case "ET":  	baseAlphabet = ValidAlphabets.ET;  	break;  case "EU":  	baseAlphabet = ValidAlphabets.EU;  	break;  case "FI":  	baseAlphabet = ValidAlphabets.FI;  	break;  case "FR":  	baseAlphabet = ValidAlphabets.FR;  	break;  case "GA":  	baseAlphabet = ValidAlphabets.GA;  	break;  case "GD":  	baseAlphabet = ValidAlphabets.GD;  	break;  case "GL":  	baseAlphabet = ValidAlphabets.GL;  	break;  case "HR":  	baseAlphabet = ValidAlphabets.HR;  	break;  case "HU":  	baseAlphabet = ValidAlphabets.HU;  	break;  case "HI":  	baseAlphabet = ValidAlphabets.HI;  	break;  case "IT":  	baseAlphabet = ValidAlphabets.IT;  	break;  case "LT":  	baseAlphabet = ValidAlphabets.LT;  	break;  case "LV":  	baseAlphabet = ValidAlphabets.LV;  	break;  case "MT":  	baseAlphabet = ValidAlphabets.MT;  	break;  case "NL":  	baseAlphabet = ValidAlphabets.NL;  	break;  case "PL":  	baseAlphabet = ValidAlphabets.PL;  	break;  case "PT":  	baseAlphabet = ValidAlphabets.PT;  	break;  case "RO":  	baseAlphabet = ValidAlphabets.RO;  	break;  case "RU":  	baseAlphabet = ValidAlphabets.RU;  	break;  case "SK":  	baseAlphabet = ValidAlphabets.SK;  	break;  case "SL":  	baseAlphabet = ValidAlphabets.SL;  	break;  case "SV":  	baseAlphabet = ValidAlphabets.SV;  	break;  case "TR":  	baseAlphabet = ValidAlphabets.TR;  	break;  case "UR":  	baseAlphabet = ValidAlphabets.UR;  	break;  }  
Missing Default,FilterGizaDictionary,ValidAlphabets,C:\repos\pmarcis_dict-filtering\FilterGizaDictionary\ValidAlphabets.cs,IsValidPhrase,The following switch statement is missing a default case: switch (language.ToUpper ()) {  case "BG":  	baseAlphabet = ValidAlphabets.BG;  	break;  case "CS":  	baseAlphabet = ValidAlphabets.CS;  	break;  case "CA":  	baseAlphabet = ValidAlphabets.CA;  	break;  case "CY":  	baseAlphabet = ValidAlphabets.CY;  	break;  case "DA":  	baseAlphabet = ValidAlphabets.DA;  	break;  case "DE":  	baseAlphabet = ValidAlphabets.DE;  	break;  case "EL":  	baseAlphabet = ValidAlphabets.EL;  	break;  case "EN":  	baseAlphabet = ValidAlphabets.EN;  	break;  case "ES":  	baseAlphabet = ValidAlphabets.ES;  	break;  case "ET":  	baseAlphabet = ValidAlphabets.ET;  	break;  case "EU":  	baseAlphabet = ValidAlphabets.EU;  	break;  case "FI":  	baseAlphabet = ValidAlphabets.FI;  	break;  case "FR":  	baseAlphabet = ValidAlphabets.FR;  	break;  case "GA":  	baseAlphabet = ValidAlphabets.GA;  	break;  case "GD":  	baseAlphabet = ValidAlphabets.GD;  	break;  case "GL":  	baseAlphabet = ValidAlphabets.GL;  	break;  case "HR":  	baseAlphabet = ValidAlphabets.HR;  	break;  case "HU":  	baseAlphabet = ValidAlphabets.HU;  	break;  case "HI":  	baseAlphabet = ValidAlphabets.HI;  	break;  case "IT":  	baseAlphabet = ValidAlphabets.IT;  	break;  case "LT":  	baseAlphabet = ValidAlphabets.LT;  	break;  case "LV":  	baseAlphabet = ValidAlphabets.LV;  	break;  case "MT":  	baseAlphabet = ValidAlphabets.MT;  	break;  case "NL":  	baseAlphabet = ValidAlphabets.NL;  	break;  case "PL":  	baseAlphabet = ValidAlphabets.PL;  	break;  case "PT":  	baseAlphabet = ValidAlphabets.PT;  	break;  case "RO":  	baseAlphabet = ValidAlphabets.RO;  	break;  case "RU":  	baseAlphabet = ValidAlphabets.RU;  	break;  case "SK":  	baseAlphabet = ValidAlphabets.SK;  	break;  case "SL":  	baseAlphabet = ValidAlphabets.SL;  	break;  case "SV":  	baseAlphabet = ValidAlphabets.SV;  	break;  case "TR":  	baseAlphabet = ValidAlphabets.TR;  	break;  case "UR":  	baseAlphabet = ValidAlphabets.UR;  	break;  }  
