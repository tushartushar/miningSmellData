Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,Cyclomatic complexity of the method is 23
Complex Method,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,Cyclomatic complexity of the method is 29
Complex Method,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,readTfnns,Cyclomatic complexity of the method is 8
Complex Method,Hjson,JsonUtil,C:\repos\laktak_hjson-cs\Hjson\JsonUtil.cs,ToJson,Cyclomatic complexity of the method is 8
Long Parameter List,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,Save,The method has 7 parameters. Parameters: value' tw' level' hasComment' separator' noIndent' isRootObject
Long Parameter List,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,writeString,The method has 5 parameters. Parameters: value' tw' level' hasComment' separator
Long Statement,Hjson,HjsonDsf,C:\repos\laktak_hjson-cs\Hjson\HjsonDsf.cs,Stringify,The length of the statement  "              throw new Exception("value may not be empty' start with a quote or contain a punctuator character except colon: " + text); " is 122.
Long Statement,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,readKeyName,The length of the statement  "          throw ParseError("Found '"+ch+"' where a key name was expected (check your syntax or use quotes if the key name includes {}[]': or whitespace)"); " is 145.
Long Statement,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,writeString,The length of the statement  "        else if (!value.Any(c => needsEscapeML(c)) && !value.Contains("'''") && !value.All(c => BaseReader.IsWhite(c))) writeMLString(value' tw' level' separator); " is 155.
Complex Conditional,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadStringLiteral,The conditional expression  "allowML!=null && exitCh=='\'' && PeekChar()=='\'' && sb.Length==0"  is complex.
Complex Conditional,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The conditional expression  "ch==''' || ch=='}' || ch==']' || ch=='#' || ch=='/' && (text.Length>p+1 && (text[p+1]=='/' || text[p+1]=='*'))"  is complex.
Complex Conditional,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,readTfnns,The conditional expression  "isEol || c==''' ||            c=='}' || c==']' ||            c=='#' ||            c=='/' && (PeekChar(1)=='/' || PeekChar(1)=='*')"  is complex.
Complex Conditional,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,getWsc,The conditional expression  "c=='\n' ||            c=='#' ||            c=='/' && i+1<str.Length && (str[i+1]=='/' || str[i+1]=='*')"  is complex.
Complex Conditional,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,writeString,The conditional expression  "doEscape ||          BaseReader.IsWhite(left) || BaseReader.IsWhite(right) ||          left=='"' ||          left=='\'' ||          left=='#' ||          left=='/' && (left1=='*' || left1=='/') ||          HjsonValue.IsPunctuatorChar(left) ||          HjsonReader.TryParseNumericLiteral(value' true' out dummy) ||          startsWithKeyword(value)"  is complex.
Empty Catch Block,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,Read,The method has an empty catch block.
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,The following statement contains a magic number: for (int x=0; ; x++)        {          c=PeekChar();          if (c<'0' || c>'9') break;          if (testLeading)          {            if (c=='0') leadingZeros++;            else testLeading = false;          }          val=val*10+(c-'0');          ReadChar();        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,The following statement contains a magic number: if (PeekChar()=='.')        {          int fdigits=0;          double frac=0;          ReadChar();          if (PeekChar()<0) throw ParseError("Invalid JSON numeric literal; extra dot");          double d=10;          for (; ; )          {            c=PeekChar();            if (c<'0' || '9'<c) break;            ReadChar();            frac+=(c-'0')/d;            d*=10;            fdigits++;          }          if (fdigits==0) throw ParseError("Invalid JSON numeric literal; extra dot");          val+=frac;        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,The following statement contains a magic number: if (PeekChar()=='.')        {          int fdigits=0;          double frac=0;          ReadChar();          if (PeekChar()<0) throw ParseError("Invalid JSON numeric literal; extra dot");          double d=10;          for (; ; )          {            c=PeekChar();            if (c<'0' || '9'<c) break;            ReadChar();            frac+=(c-'0')/d;            d*=10;            fdigits++;          }          if (fdigits==0) throw ParseError("Invalid JSON numeric literal; extra dot");          val+=frac;        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,The following statement contains a magic number: if (c=='e' || c=='E')        {          // exponent          int exp=0' expSign=1;            ReadChar();          if (PeekChar()<0) throw new ArgumentException("Invalid JSON numeric literal; incomplete exponent");            c=PeekChar();          if (c=='-')          {            ReadChar();            expSign=-1;          }          else if (c=='+') ReadChar();            if (PeekChar()<0) throw ParseError("Invalid JSON numeric literal; incomplete exponent");            for (; ; )          {            c=PeekChar();            if (c<'0' || c>'9') break;            exp=exp*10+(c-'0');            ReadChar();          }            if (exp!=0)            val*=Math.Pow(10' exp*expSign);        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadNumericLiteral,The following statement contains a magic number: if (c=='e' || c=='E')        {          // exponent          int exp=0' expSign=1;            ReadChar();          if (PeekChar()<0) throw new ArgumentException("Invalid JSON numeric literal; incomplete exponent");            c=PeekChar();          if (c=='-')          {            ReadChar();            expSign=-1;          }          else if (c=='+') ReadChar();            if (PeekChar()<0) throw ParseError("Invalid JSON numeric literal; incomplete exponent");            for (; ; )          {            c=PeekChar();            if (c<'0' || c>'9') break;            exp=exp*10+(c-'0');            ReadChar();          }            if (exp!=0)            val*=Math.Pow(10' exp*expSign);        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadStringLiteral,The following statement contains a magic number: for (; ; )        {          int c=ReadChar();          if (c<0) throw ParseError("JSON string is not closed");          if (c==exitCh)          {            if (allowML!=null && exitCh=='\'' && PeekChar()=='\'' && sb.Length==0)            {              // ''' indicates a multiline string              ReadChar();              return allowML();            }            else return sb.ToString();          }          else if (c=='\n' || c=='\r')          {            throw ParseError("Bad string containing newline");          }          else if (c!='\\')          {            sb.Append((char)c);            continue;          }            // escaped expression          c=ReadChar();          if (c<0)            throw ParseError("Invalid JSON string literal; incomplete escape sequence");          switch (c)          {            case '"':            case '\'':            case '\\':            case '/': sb.Append((char)c); break;            case 'b': sb.Append('\x8'); break;            case 'f': sb.Append('\f'); break;            case 'n': sb.Append('\n'); break;            case 'r': sb.Append('\r'); break;            case 't': sb.Append('\t'); break;            case 'u':              ushort cp=0;              for (int i=0; i<4; i++)              {                cp <<= 4;                if ((c=ReadChar())<0)                  throw ParseError("Incomplete unicode character escape literal");                if (c>='0' && c<='9') cp+=(ushort)(c-'0');                else if (c>='A' && c<='F') cp+=(ushort)(c-'A'+10);                else if (c>='a' && c<='f') cp+=(ushort)(c-'a'+10);                else throw ParseError("Bad \\u char "+(char)c);              }              sb.Append((char)cp);              break;            default:              throw ParseError("Invalid JSON string literal; unexpected escape character");          }        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadStringLiteral,The following statement contains a magic number: for (; ; )        {          int c=ReadChar();          if (c<0) throw ParseError("JSON string is not closed");          if (c==exitCh)          {            if (allowML!=null && exitCh=='\'' && PeekChar()=='\'' && sb.Length==0)            {              // ''' indicates a multiline string              ReadChar();              return allowML();            }            else return sb.ToString();          }          else if (c=='\n' || c=='\r')          {            throw ParseError("Bad string containing newline");          }          else if (c!='\\')          {            sb.Append((char)c);            continue;          }            // escaped expression          c=ReadChar();          if (c<0)            throw ParseError("Invalid JSON string literal; incomplete escape sequence");          switch (c)          {            case '"':            case '\'':            case '\\':            case '/': sb.Append((char)c); break;            case 'b': sb.Append('\x8'); break;            case 'f': sb.Append('\f'); break;            case 'n': sb.Append('\n'); break;            case 'r': sb.Append('\r'); break;            case 't': sb.Append('\t'); break;            case 'u':              ushort cp=0;              for (int i=0; i<4; i++)              {                cp <<= 4;                if ((c=ReadChar())<0)                  throw ParseError("Incomplete unicode character escape literal");                if (c>='0' && c<='9') cp+=(ushort)(c-'0');                else if (c>='A' && c<='F') cp+=(ushort)(c-'A'+10);                else if (c>='a' && c<='f') cp+=(ushort)(c-'a'+10);                else throw ParseError("Bad \\u char "+(char)c);              }              sb.Append((char)cp);              break;            default:              throw ParseError("Invalid JSON string literal; unexpected escape character");          }        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadStringLiteral,The following statement contains a magic number: for (; ; )        {          int c=ReadChar();          if (c<0) throw ParseError("JSON string is not closed");          if (c==exitCh)          {            if (allowML!=null && exitCh=='\'' && PeekChar()=='\'' && sb.Length==0)            {              // ''' indicates a multiline string              ReadChar();              return allowML();            }            else return sb.ToString();          }          else if (c=='\n' || c=='\r')          {            throw ParseError("Bad string containing newline");          }          else if (c!='\\')          {            sb.Append((char)c);            continue;          }            // escaped expression          c=ReadChar();          if (c<0)            throw ParseError("Invalid JSON string literal; incomplete escape sequence");          switch (c)          {            case '"':            case '\'':            case '\\':            case '/': sb.Append((char)c); break;            case 'b': sb.Append('\x8'); break;            case 'f': sb.Append('\f'); break;            case 'n': sb.Append('\n'); break;            case 'r': sb.Append('\r'); break;            case 't': sb.Append('\t'); break;            case 'u':              ushort cp=0;              for (int i=0; i<4; i++)              {                cp <<= 4;                if ((c=ReadChar())<0)                  throw ParseError("Incomplete unicode character escape literal");                if (c>='0' && c<='9') cp+=(ushort)(c-'0');                else if (c>='A' && c<='F') cp+=(ushort)(c-'A'+10);                else if (c>='a' && c<='f') cp+=(ushort)(c-'a'+10);                else throw ParseError("Bad \\u char "+(char)c);              }              sb.Append((char)cp);              break;            default:              throw ParseError("Invalid JSON string literal; unexpected escape character");          }        }
Magic Number,Hjson,BaseReader,C:\repos\laktak_hjson-cs\Hjson\BaseReader.cs,ReadStringLiteral,The following statement contains a magic number: for (; ; )        {          int c=ReadChar();          if (c<0) throw ParseError("JSON string is not closed");          if (c==exitCh)          {            if (allowML!=null && exitCh=='\'' && PeekChar()=='\'' && sb.Length==0)            {              // ''' indicates a multiline string              ReadChar();              return allowML();            }            else return sb.ToString();          }          else if (c=='\n' || c=='\r')          {            throw ParseError("Bad string containing newline");          }          else if (c!='\\')          {            sb.Append((char)c);            continue;          }            // escaped expression          c=ReadChar();          if (c<0)            throw ParseError("Invalid JSON string literal; incomplete escape sequence");          switch (c)          {            case '"':            case '\'':            case '\\':            case '/': sb.Append((char)c); break;            case 'b': sb.Append('\x8'); break;            case 'f': sb.Append('\f'); break;            case 'n': sb.Append('\n'); break;            case 'r': sb.Append('\r'); break;            case 't': sb.Append('\t'); break;            case 'u':              ushort cp=0;              for (int i=0; i<4; i++)              {                cp <<= 4;                if ((c=ReadChar())<0)                  throw ParseError("Incomplete unicode character escape literal");                if (c>='0' && c<='9') cp+=(ushort)(c-'0');                else if (c>='A' && c<='F') cp+=(ushort)(c-'A'+10);                else if (c>='a' && c<='f') cp+=(ushort)(c-'a'+10);                else throw ParseError("Bad \\u char "+(char)c);              }              sb.Append((char)cp);              break;            default:              throw ParseError("Invalid JSON string literal; unexpected escape character");          }        }
Magic Number,Hjson,DsfHex,C:\repos\laktak_hjson-cs\Hjson\HjsonDsf.cs,Parse,The following statement contains a magic number: if (isHex.IsMatch(text))          return long.Parse(text.Substring(2)' NumberStyles.HexNumber);        else          return null;
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,readMlString,The following statement contains a magic number: var indent=Column-3;
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,readMlString,The following statement contains a magic number: while (true)        {          int ch=PeekChar();          if (ch<0) throw ParseError("Bad multiline string");          else if (ch=='\'')          {            triple++;            ReadChar();            if (triple==3)            {              if (sb[sb.Length-1]=='\n') sb.Length--;              return sb.ToString();            }            else continue;          }          else          {            while (triple>0)            {              sb.Append('\'');              triple--;            }          }          if (ch=='\n')          {            sb.Append('\n');            ReadChar();            skipIndent(indent);          }          else          {            if (ch!='\r') sb.Append((char)ch);            ReadChar();          }        }
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The following statement contains a magic number: for (int x=0; ; x++)        {          c=text[p];          if (c<'0' || c>'9') break;          if (testLeading)          {            if (c=='0') leadingZeros++;            else testLeading=false;          }          val=val*10+(c-'0');          p++;        }
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The following statement contains a magic number: if (text[p]=='.')        {          if (leadingZeros<0) return false;          int fdigits=0;          double frac=0;          p++;          if (text[p]==0) return false;          double d=10;          for (; ; )          {            c=text[p];            if (c<'0' || '9'<c) break;            p++;            frac+=(c-'0')/d;            d*=10;            fdigits++;          }          if (fdigits==0) return false;          val+=frac;        }
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The following statement contains a magic number: if (text[p]=='.')        {          if (leadingZeros<0) return false;          int fdigits=0;          double frac=0;          p++;          if (text[p]==0) return false;          double d=10;          for (; ; )          {            c=text[p];            if (c<'0' || '9'<c) break;            p++;            frac+=(c-'0')/d;            d*=10;            fdigits++;          }          if (fdigits==0) return false;          val+=frac;        }
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The following statement contains a magic number: if (c=='e' || c=='E')        {          // exponent          int exp=0' expSign=1;            p++;          if (text[p]==0) return false;            c=text[p];          if (c=='-')          {            p++;            expSign=-1;          }          else if (c=='+') p++;            if (text[p]==0) return false;            for (; ; )          {            c=text[p];            if (c<'0' || c>'9') break;            exp=exp*10+(c-'0');            p++;          }            if (exp!=0)            val*=Math.Pow(10' exp*expSign);        }
Magic Number,Hjson,HjsonReader,C:\repos\laktak_hjson-cs\Hjson\HjsonReader.cs,TryParseNumericLiteral,The following statement contains a magic number: if (c=='e' || c=='E')        {          // exponent          int exp=0' expSign=1;            p++;          if (text[p]==0) return false;            c=text[p];          if (c=='-')          {            p++;            expSign=-1;          }          else if (c=='+') p++;            if (text[p]==0) return false;            for (; ; )          {            c=text[p];            if (c<'0' || c>'9') break;            exp=exp*10+(c-'0');            p++;          }            if (exp!=0)            val*=Math.Pow(10' exp*expSign);        }
Magic Number,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,nl,The following statement contains a magic number: tw.Write(new string(' '' level*2));
Magic Number,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,writeString,The following statement contains a magic number: char left1=value.Length>1?value[1]:'\0'' left2=value.Length>2?value[2]:'\0';
Magic Number,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,writeString,The following statement contains a magic number: char left1=value.Length>1?value[1]:'\0'' left2=value.Length>2?value[2]:'\0';
Magic Number,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,startsWithKeyword,The following statement contains a magic number: if (text.StartsWith("true") || text.StartsWith("null")) p=4;        else if (text.StartsWith("false")) p=5;        else return false;
Magic Number,Hjson,HjsonWriter,C:\repos\laktak_hjson-cs\Hjson\HjsonWriter.cs,startsWithKeyword,The following statement contains a magic number: if (text.StartsWith("true") || text.StartsWith("null")) p=4;        else if (text.StartsWith("false")) p=5;        else return false;
Magic Number,Hjson,JsonWriter,C:\repos\laktak_hjson-cs\Hjson\JsonWriter.cs,nl,The following statement contains a magic number: if (format)        {          tw.Write(JsonValue.eol);          tw.Write(new string(' '' level*2));        }
