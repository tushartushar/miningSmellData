Implementation smell,Namespace,Class,File,Method,Description
Long Method,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The method has 437 lines of code.
Complex Method,OSC.NET,OSCMessage,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCMessage.cs,pack,Cyclomatic complexity of the method is 10
Complex Method,OSC.NET,OSCMessage,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCMessage.cs,Unpack,Cyclomatic complexity of the method is 11
Complex Method,OSC.NET,OSCMessage,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCMessage.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,Cyclomatic complexity of the method is 109
Long Parameter List,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The method has 6 parameters.
Long Parameter List,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The method has 5 parameters.
Long Parameter List,TUIO,TuioCursor,C:\repos\mkalten_TUIO11_NET\TUIO\TuioCursor.cs,TuioCursor,The method has 5 parameters.
Long Parameter List,TUIO,TuioObject,C:\repos\mkalten_TUIO11_NET\TUIO\TuioObject.cs,TuioObject,The method has 6 parameters.
Long Parameter List,TUIO,TuioObject,C:\repos\mkalten_TUIO11_NET\TUIO\TuioObject.cs,TuioObject,The method has 5 parameters.
Long Parameter List,TUIO,TuioObject,C:\repos\mkalten_TUIO11_NET\TUIO\TuioObject.cs,update,The method has 9 parameters.
Long Parameter List,TUIO,TuioObject,C:\repos\mkalten_TUIO11_NET\TUIO\TuioObject.cs,update,The method has 8 parameters.
Long Parameter List,TUIO,TuioBlob,C:\repos\mkalten_TUIO11_NET\TUIO\TuioBlob.cs,TuioBlob,The method has 9 parameters.
Long Parameter List,TUIO,TuioBlob,C:\repos\mkalten_TUIO11_NET\TUIO\TuioBlob.cs,TuioBlob,The method has 8 parameters.
Long Parameter List,TUIO,TuioBlob,C:\repos\mkalten_TUIO11_NET\TUIO\TuioBlob.cs,update,The method has 12 parameters.
Long Parameter List,TUIO,TuioBlob,C:\repos\mkalten_TUIO11_NET\TUIO\TuioBlob.cs,update,The method has 11 parameters.
Long Parameter List,TUIO,TuioBlob,C:\repos\mkalten_TUIO11_NET\TUIO\TuioBlob.cs,update,The method has 7 parameters.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "					if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) { " is 222.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "							updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel); " is 146.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "					if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) { " is 129.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "					if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) { " is 297.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "							addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area); " is 123.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "						if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0)) " is 160.
Long Statement,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The length of the statement  "							updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel); " is 180.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)"  is complex.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0)"  is complex.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)"  is complex.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0)"  is complex.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)"  is complex.
Complex Conditional,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The conditional expression  "(tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0)"  is complex.
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,OSCPacket,The following statement contains a magic number: ASCIIEncoding8Bit = Encoding.GetEncoding (1252);  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackInt,The following statement contains a magic number: for (int i = 0; i < 4; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackLong,The following statement contains a magic number: for (int i = 0; i < 8; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackFloat,The following statement contains a magic number: for (int i = 0; i < 4; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackString,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackString,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackString,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackBlob,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackBlob,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackBlob,The following statement contains a magic number: start = (start + 3) / 4 * 4;  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackColor,The following statement contains a magic number: for (int i = 0; i < 4; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackColor,The following statement contains a magic number: return Color.FromArgb (data [3]' data [0]' data [1]' data [2]);  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackColor,The following statement contains a magic number: return Color.FromArgb (data [3]' data [0]' data [1]' data [2]);  
Magic Number,OSC.NET,OSCPacket,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCPacket.cs,unpackTimeTag,The following statement contains a magic number: for (int i = 0; i < 8; i++' start++)  	data [i] = bytes [start];  
Magic Number,OSC.NET,OscTimeTag,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCTimeTag.cs,OscTimeTag,The following statement contains a magic number: Array.Copy (data' 0' secondsSinceEpochData' 0' 4);  
Magic Number,OSC.NET,OscTimeTag,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCTimeTag.cs,OscTimeTag,The following statement contains a magic number: Array.Copy (data' 4' fractionalSecondData' 0' 4);  
Magic Number,OSC.NET,OscTimeTag,C:\repos\mkalten_TUIO11_NET\OSC.NET\OSCTimeTag.cs,OscTimeTag,The following statement contains a magic number: Array.Copy (data' 4' fractionalSecondData' 0' 4);  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dobj") {  	if (command == "set") {  		long s_id = (int)args [1];  		int f_id = (int)args [2];  		float xpos = (float)args [3];  		float ypos = (float)args [4];  		float angle = (float)args [5];  		float xspeed = (float)args [6];  		float yspeed = (float)args [7];  		float rspeed = (float)args [8];  		float maccel = (float)args [9];  		float raccel = (float)args [10];  		lock (objectSync) {  			if (!objectList.ContainsKey (s_id)) {  				TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				frameObjects.Add (addObject);  			}  			else {  				TuioObject tobj = objectList [s_id];  				if (tobj == null)  					return;  				if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  					TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  					updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  					frameObjects.Add (updateObject);  				}  			}  		}  	}  	else if (command == "alive") {  		newObjectList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newObjectList.Add (s_id);  			// reduce the object list to the lost objects  			if (aliveObjectList.Contains (s_id))  				aliveObjectList.Remove (s_id);  		}  		// remove the remaining objects  		lock (objectSync) {  			for (int i = 0; i < aliveObjectList.Count; i++) {  				long s_id = aliveObjectList [i];  				TuioObject removeObject = objectList [s_id];  				removeObject.remove (currentTime);  				frameObjects.Add (removeObject);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioObject tobj = frameEnum.Current;  				switch (tobj.TuioState) {  				case TuioObject.TUIO_REMOVED:  					TuioObject removeObject = tobj;  					removeObject.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioObject (removeObject);  					}  					lock (objectSync) {  						objectList.Remove (removeObject.SessionID);  					}  					break;  				case TuioObject.TUIO_ADDED:  					TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  					lock (objectSync) {  						objectList.Add (addObject.SessionID' addObject);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioObject (addObject);  					}  					break;  				default:  					TuioObject updateObject = getTuioObject (tobj.SessionID);  					if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  					else  						updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioObject (updateObject);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveObjectList;  			aliveObjectList = newObjectList;  			// recycling the List  			newObjectList = buffer;  		}  		frameObjects.Clear ();  	}  }  else if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	int f_id = (int)args [2];  	float xpos = (float)args [3];  	float ypos = (float)args [4];  	float angle = (float)args [5];  	float xspeed = (float)args [6];  	float yspeed = (float)args [7];  	float rspeed = (float)args [8];  	float maccel = (float)args [9];  	float raccel = (float)args [10];  	lock (objectSync) {  		if (!objectList.ContainsKey (s_id)) {  			TuioObject addObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  			frameObjects.Add (addObject);  		}  		else {  			TuioObject tobj = objectList [s_id];  			if (tobj == null)  				return;  			if ((tobj.X != xpos) || (tobj.Y != ypos) || (tobj.Angle != angle) || (tobj.XSpeed != xspeed) || (tobj.YSpeed != yspeed) || (tobj.RotationSpeed != rspeed) || (tobj.MotionAccel != maccel) || (tobj.RotationAccel != raccel)) {  				TuioObject updateObject = new TuioObject (s_id' f_id' xpos' ypos' angle);  				updateObject.update (xpos' ypos' angle' xspeed' yspeed' rspeed' maccel' raccel);  				frameObjects.Add (updateObject);  			}  		}  	}  }  else if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newObjectList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newObjectList.Add (s_id);  		// reduce the object list to the lost objects  		if (aliveObjectList.Contains (s_id))  			aliveObjectList.Remove (s_id);  	}  	// remove the remaining objects  	lock (objectSync) {  		for (int i = 0; i < aliveObjectList.Count; i++) {  			long s_id = aliveObjectList [i];  			TuioObject removeObject = objectList [s_id];  			removeObject.remove (currentTime);  			frameObjects.Add (removeObject);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioObject> frameEnum = frameObjects.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioObject tobj = frameEnum.Current;  			switch (tobj.TuioState) {  			case TuioObject.TUIO_REMOVED:  				TuioObject removeObject = tobj;  				removeObject.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioObject (removeObject);  				}  				lock (objectSync) {  					objectList.Remove (removeObject.SessionID);  				}  				break;  			case TuioObject.TUIO_ADDED:  				TuioObject addObject = new TuioObject (currentTime' tobj.SessionID' tobj.SymbolID' tobj.X' tobj.Y' tobj.Angle);  				lock (objectSync) {  					objectList.Add (addObject.SessionID' addObject);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioObject (addObject);  				}  				break;  			default:  				TuioObject updateObject = getTuioObject (tobj.SessionID);  				if ((tobj.X != updateObject.X && tobj.XSpeed == 0) || (tobj.Y != updateObject.Y && tobj.YSpeed == 0))  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle);  				else  					updateObject.update (currentTime' tobj.X' tobj.Y' tobj.Angle' tobj.XSpeed' tobj.YSpeed' tobj.RotationSpeed' tobj.MotionAccel' tobj.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioObject (updateObject);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveObjectList;  		aliveObjectList = newObjectList;  		// recycling the List  		newObjectList = buffer;  	}  	frameObjects.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  	currentFrame = fseq;  else  	lateFrame = true;  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dcur") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float xspeed = (float)args [4];  		float yspeed = (float)args [5];  		float maccel = (float)args [6];  		lock (cursorList) {  			if (!cursorList.ContainsKey (s_id)) {  				TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  				frameCursors.Add (addCursor);  			}  			else {  				TuioCursor tcur = (TuioCursor)cursorList [s_id];  				if (tcur == null)  					return;  				if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  					TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  					updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  					frameCursors.Add (updateCursor);  				}  			}  		}  	}  	else if (command == "alive") {  		newCursorList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newCursorList.Add (s_id);  			// reduce the cursor list to the lost cursors  			if (aliveCursorList.Contains (s_id))  				aliveCursorList.Remove (s_id);  		}  		// remove the remaining cursors  		lock (cursorSync) {  			for (int i = 0; i < aliveCursorList.Count; i++) {  				long s_id = aliveCursorList [i];  				if (!cursorList.ContainsKey (s_id))  					continue;  				TuioCursor removeCursor = cursorList [s_id];  				removeCursor.remove (currentTime);  				frameCursors.Add (removeCursor);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioCursor tcur = frameEnum.Current;  				switch (tcur.TuioState) {  				case TuioCursor.TUIO_REMOVED:  					TuioCursor removeCursor = tcur;  					removeCursor.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioCursor (removeCursor);  					}  					lock (cursorSync) {  						cursorList.Remove (removeCursor.SessionID);  						if (removeCursor.CursorID == maxCursorID) {  							maxCursorID = -1;  							if (cursorList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  								while (clist.MoveNext ()) {  									int f_id = clist.Current.Value.CursorID;  									if (f_id > maxCursorID)  										maxCursorID = f_id;  								}  								List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  								IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioCursor testCursor = flist.Current;  									if (testCursor.CursorID < maxCursorID)  										freeCursorBuffer.Add (testCursor);  								}  								freeCursorList = freeCursorBuffer;  							}  							else  								freeCursorList.Clear ();  						}  						else if (removeCursor.CursorID < maxCursorID)  							freeCursorList.Add (removeCursor);  					}  					break;  				case TuioCursor.TUIO_ADDED:  					TuioCursor addCursor;  					lock (cursorSync) {  						int c_id = cursorList.Count;  						if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  							TuioCursor closestCursor = freeCursorList [0];  							IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioCursor testCursor = testList.Current;  								if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  									closestCursor = testCursor;  							}  							c_id = closestCursor.CursorID;  							freeCursorList.Remove (closestCursor);  						}  						else  							maxCursorID = c_id;  						addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  						cursorList.Add (addCursor.SessionID' addCursor);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioCursor (addCursor);  					}  					break;  				default:  					TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  					if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  						updateCursor.update (currentTime' tcur.X' tcur.Y);  					else  						updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioCursor (updateCursor);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveCursorList;  			aliveCursorList = newCursorList;  			// recycling the List  			newCursorList = buffer;  		}  		frameCursors.Clear ();  	}  }  else if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float xspeed = (float)args [4];  	float yspeed = (float)args [5];  	float maccel = (float)args [6];  	lock (cursorList) {  		if (!cursorList.ContainsKey (s_id)) {  			TuioCursor addCursor = new TuioCursor (s_id' -1' xpos' ypos);  			frameCursors.Add (addCursor);  		}  		else {  			TuioCursor tcur = (TuioCursor)cursorList [s_id];  			if (tcur == null)  				return;  			if ((tcur.X != xpos) || (tcur.Y != ypos) || (tcur.XSpeed != xspeed) || (tcur.YSpeed != yspeed) || (tcur.MotionAccel != maccel)) {  				TuioCursor updateCursor = new TuioCursor (s_id' tcur.CursorID' xpos' ypos);  				updateCursor.update (xpos' ypos' xspeed' yspeed' maccel);  				frameCursors.Add (updateCursor);  			}  		}  	}  }  else if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newCursorList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newCursorList.Add (s_id);  		// reduce the cursor list to the lost cursors  		if (aliveCursorList.Contains (s_id))  			aliveCursorList.Remove (s_id);  	}  	// remove the remaining cursors  	lock (cursorSync) {  		for (int i = 0; i < aliveCursorList.Count; i++) {  			long s_id = aliveCursorList [i];  			if (!cursorList.ContainsKey (s_id))  				continue;  			TuioCursor removeCursor = cursorList [s_id];  			removeCursor.remove (currentTime);  			frameCursors.Add (removeCursor);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioCursor> frameEnum = frameCursors.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioCursor tcur = frameEnum.Current;  			switch (tcur.TuioState) {  			case TuioCursor.TUIO_REMOVED:  				TuioCursor removeCursor = tcur;  				removeCursor.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioCursor (removeCursor);  				}  				lock (cursorSync) {  					cursorList.Remove (removeCursor.SessionID);  					if (removeCursor.CursorID == maxCursorID) {  						maxCursorID = -1;  						if (cursorList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioCursor>> clist = cursorList.GetEnumerator ();  							while (clist.MoveNext ()) {  								int f_id = clist.Current.Value.CursorID;  								if (f_id > maxCursorID)  									maxCursorID = f_id;  							}  							List<TuioCursor> freeCursorBuffer = new List<TuioCursor> ();  							IEnumerator<TuioCursor> flist = freeCursorList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioCursor testCursor = flist.Current;  								if (testCursor.CursorID < maxCursorID)  									freeCursorBuffer.Add (testCursor);  							}  							freeCursorList = freeCursorBuffer;  						}  						else  							freeCursorList.Clear ();  					}  					else if (removeCursor.CursorID < maxCursorID)  						freeCursorList.Add (removeCursor);  				}  				break;  			case TuioCursor.TUIO_ADDED:  				TuioCursor addCursor;  				lock (cursorSync) {  					int c_id = cursorList.Count;  					if ((cursorList.Count <= maxCursorID) && (freeCursorList.Count > 0)) {  						TuioCursor closestCursor = freeCursorList [0];  						IEnumerator<TuioCursor> testList = freeCursorList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioCursor testCursor = testList.Current;  							if (testCursor.getDistance (tcur) < closestCursor.getDistance (tcur))  								closestCursor = testCursor;  						}  						c_id = closestCursor.CursorID;  						freeCursorList.Remove (closestCursor);  					}  					else  						maxCursorID = c_id;  					addCursor = new TuioCursor (currentTime' tcur.SessionID' c_id' tcur.X' tcur.Y);  					cursorList.Add (addCursor.SessionID' addCursor);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioCursor (addCursor);  				}  				break;  			default:  				TuioCursor updateCursor = getTuioCursor (tcur.SessionID);  				if ((tcur.X != updateCursor.X && tcur.XSpeed == 0) || (tcur.Y != updateCursor.Y && tcur.YSpeed == 0))  					updateCursor.update (currentTime' tcur.X' tcur.Y);  				else  					updateCursor.update (currentTime' tcur.X' tcur.Y' tcur.XSpeed' tcur.YSpeed' tcur.MotionAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioCursor (updateCursor);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveCursorList;  		aliveCursorList = newCursorList;  		// recycling the List  		newCursorList = buffer;  	}  	frameCursors.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  	currentFrame = fseq;  else  	lateFrame = true;  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (address == "/tuio/2Dblb") {  	if (command == "set") {  		long s_id = (int)args [1];  		float xpos = (float)args [2];  		float ypos = (float)args [3];  		float angle = (float)args [4];  		float width = (float)args [5];  		float height = (float)args [6];  		float area = (float)args [7];  		float xspeed = (float)args [8];  		float yspeed = (float)args [9];  		float rspeed = (float)args [10];  		float maccel = (float)args [11];  		float raccel = (float)args [12];  		lock (blobList) {  			if (!blobList.ContainsKey (s_id)) {  				TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  				frameBlobs.Add (addBlob);  			}  			else {  				TuioBlob tblb = (TuioBlob)blobList [s_id];  				if (tblb == null)  					return;  				if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  					TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  					updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  					frameBlobs.Add (updateBlob);  				}  			}  		}  	}  	else if (command == "alive") {  		newBlobList.Clear ();  		for (int i = 1; i < args.Count; i++) {  			// get the message content  			long s_id = (int)args [i];  			newBlobList.Add (s_id);  			// reduce the blob list to the lost blobs  			if (aliveBlobList.Contains (s_id))  				aliveBlobList.Remove (s_id);  		}  		// remove the remaining blobs  		lock (blobSync) {  			for (int i = 0; i < aliveBlobList.Count; i++) {  				long s_id = aliveBlobList [i];  				if (!blobList.ContainsKey (s_id))  					continue;  				TuioBlob removeBlob = blobList [s_id];  				removeBlob.remove (currentTime);  				frameBlobs.Add (removeBlob);  			}  		}  	}  	else if (command == "fseq") {  		int fseq = (int)args [1];  		bool lateFrame = false;  		if (fseq > 0) {  			if (fseq > currentFrame)  				currentTime = TuioTime.SessionTime;  			if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  				currentFrame = fseq;  			else  				lateFrame = true;  		}  		else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  			currentTime = TuioTime.SessionTime;  		}  		if (!lateFrame) {  			IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  			while (frameEnum.MoveNext ()) {  				TuioBlob tblb = frameEnum.Current;  				switch (tblb.TuioState) {  				case TuioBlob.TUIO_REMOVED:  					TuioBlob removeBlob = tblb;  					removeBlob.remove (currentTime);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.removeTuioBlob (removeBlob);  					}  					lock (blobSync) {  						blobList.Remove (removeBlob.SessionID);  						if (removeBlob.BlobID == maxBlobID) {  							maxBlobID = -1;  							if (blobList.Count > 0) {  								IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  								while (blist.MoveNext ()) {  									int b_id = blist.Current.Value.BlobID;  									if (b_id > maxBlobID)  										maxBlobID = b_id;  								}  								List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  								IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  								while (flist.MoveNext ()) {  									TuioBlob testBlob = flist.Current;  									if (testBlob.BlobID < maxBlobID)  										freeBlobBuffer.Add (testBlob);  								}  								freeBlobList = freeBlobBuffer;  							}  							else  								freeBlobList.Clear ();  						}  						else if (removeBlob.BlobID < maxBlobID)  							freeBlobList.Add (removeBlob);  					}  					break;  				case TuioBlob.TUIO_ADDED:  					TuioBlob addBlob;  					lock (blobSync) {  						int b_id = blobList.Count;  						if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  							TuioBlob closestBlob = freeBlobList [0];  							IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  							while (testList.MoveNext ()) {  								TuioBlob testBlob = testList.Current;  								if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  									closestBlob = testBlob;  							}  							b_id = closestBlob.BlobID;  							freeBlobList.Remove (closestBlob);  						}  						else  							maxBlobID = b_id;  						addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  						blobList.Add (addBlob.SessionID' addBlob);  					}  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.addTuioBlob (addBlob);  					}  					break;  				default:  					TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  					if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					else  						updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  					for (int i = 0; i < listenerList.Count; i++) {  						TuioListener listener = (TuioListener)listenerList [i];  						if (listener != null)  							listener.updateTuioBlob (updateBlob);  					}  					break;  				}  			}  			for (int i = 0; i < listenerList.Count; i++) {  				TuioListener listener = (TuioListener)listenerList [i];  				if (listener != null)  					listener.refresh (new TuioTime (currentTime));  			}  			List<long> buffer = aliveBlobList;  			aliveBlobList = newBlobList;  			// recycling the List  			newBlobList = buffer;  		}  		frameBlobs.Clear ();  	}  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "set") {  	long s_id = (int)args [1];  	float xpos = (float)args [2];  	float ypos = (float)args [3];  	float angle = (float)args [4];  	float width = (float)args [5];  	float height = (float)args [6];  	float area = (float)args [7];  	float xspeed = (float)args [8];  	float yspeed = (float)args [9];  	float rspeed = (float)args [10];  	float maccel = (float)args [11];  	float raccel = (float)args [12];  	lock (blobList) {  		if (!blobList.ContainsKey (s_id)) {  			TuioBlob addBlob = new TuioBlob (s_id' -1' xpos' ypos' angle' width' height' area);  			frameBlobs.Add (addBlob);  		}  		else {  			TuioBlob tblb = (TuioBlob)blobList [s_id];  			if (tblb == null)  				return;  			if ((tblb.X != xpos) || (tblb.Y != ypos) || (tblb.Angle != angle) || (tblb.Width != width) || (tblb.Height != height) || (tblb.Area != area) || (tblb.XSpeed != xspeed) || (tblb.YSpeed != yspeed) || (tblb.RotationSpeed != rspeed) || (tblb.MotionAccel != maccel) || (tblb.RotationAccel != raccel)) {  				TuioBlob updateBlob = new TuioBlob (s_id' tblb.BlobID' xpos' ypos' angle' width' height' area);  				updateBlob.update (xpos' ypos' angle' width' height' area' xspeed' yspeed' rspeed' maccel' raccel);  				frameBlobs.Add (updateBlob);  			}  		}  	}  }  else if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "alive") {  	newBlobList.Clear ();  	for (int i = 1; i < args.Count; i++) {  		// get the message content  		long s_id = (int)args [i];  		newBlobList.Add (s_id);  		// reduce the blob list to the lost blobs  		if (aliveBlobList.Contains (s_id))  			aliveBlobList.Remove (s_id);  	}  	// remove the remaining blobs  	lock (blobSync) {  		for (int i = 0; i < aliveBlobList.Count; i++) {  			long s_id = aliveBlobList [i];  			if (!blobList.ContainsKey (s_id))  				continue;  			TuioBlob removeBlob = blobList [s_id];  			removeBlob.remove (currentTime);  			frameBlobs.Add (removeBlob);  		}  	}  }  else if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (command == "fseq") {  	int fseq = (int)args [1];  	bool lateFrame = false;  	if (fseq > 0) {  		if (fseq > currentFrame)  			currentTime = TuioTime.SessionTime;  		if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  			currentFrame = fseq;  		else  			lateFrame = true;  	}  	else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  		currentTime = TuioTime.SessionTime;  	}  	if (!lateFrame) {  		IEnumerator<TuioBlob> frameEnum = frameBlobs.GetEnumerator ();  		while (frameEnum.MoveNext ()) {  			TuioBlob tblb = frameEnum.Current;  			switch (tblb.TuioState) {  			case TuioBlob.TUIO_REMOVED:  				TuioBlob removeBlob = tblb;  				removeBlob.remove (currentTime);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.removeTuioBlob (removeBlob);  				}  				lock (blobSync) {  					blobList.Remove (removeBlob.SessionID);  					if (removeBlob.BlobID == maxBlobID) {  						maxBlobID = -1;  						if (blobList.Count > 0) {  							IEnumerator<KeyValuePair<long' TuioBlob>> blist = blobList.GetEnumerator ();  							while (blist.MoveNext ()) {  								int b_id = blist.Current.Value.BlobID;  								if (b_id > maxBlobID)  									maxBlobID = b_id;  							}  							List<TuioBlob> freeBlobBuffer = new List<TuioBlob> ();  							IEnumerator<TuioBlob> flist = freeBlobList.GetEnumerator ();  							while (flist.MoveNext ()) {  								TuioBlob testBlob = flist.Current;  								if (testBlob.BlobID < maxBlobID)  									freeBlobBuffer.Add (testBlob);  							}  							freeBlobList = freeBlobBuffer;  						}  						else  							freeBlobList.Clear ();  					}  					else if (removeBlob.BlobID < maxBlobID)  						freeBlobList.Add (removeBlob);  				}  				break;  			case TuioBlob.TUIO_ADDED:  				TuioBlob addBlob;  				lock (blobSync) {  					int b_id = blobList.Count;  					if ((blobList.Count <= maxBlobID) && (freeBlobList.Count > 0)) {  						TuioBlob closestBlob = freeBlobList [0];  						IEnumerator<TuioBlob> testList = freeBlobList.GetEnumerator ();  						while (testList.MoveNext ()) {  							TuioBlob testBlob = testList.Current;  							if (testBlob.getDistance (tblb) < closestBlob.getDistance (tblb))  								closestBlob = testBlob;  						}  						b_id = closestBlob.BlobID;  						freeBlobList.Remove (closestBlob);  					}  					else  						maxBlobID = b_id;  					addBlob = new TuioBlob (currentTime' tblb.SessionID' b_id' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  					blobList.Add (addBlob.SessionID' addBlob);  				}  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.addTuioBlob (addBlob);  				}  				break;  			default:  				TuioBlob updateBlob = getTuioBlob (tblb.SessionID);  				if ((tblb.X != updateBlob.X && tblb.XSpeed == 0) || (tblb.Y != updateBlob.Y && tblb.YSpeed == 0) || (tblb.Angle != updateBlob.Angle && tblb.RotationSpeed == 0))  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area);  				else  					updateBlob.update (currentTime' tblb.X' tblb.Y' tblb.Angle' tblb.Width' tblb.Height' tblb.Area' tblb.XSpeed' tblb.YSpeed' tblb.RotationSpeed' tblb.MotionAccel' tblb.RotationAccel);  				for (int i = 0; i < listenerList.Count; i++) {  					TuioListener listener = (TuioListener)listenerList [i];  					if (listener != null)  						listener.updateTuioBlob (updateBlob);  				}  				break;  			}  		}  		for (int i = 0; i < listenerList.Count; i++) {  			TuioListener listener = (TuioListener)listenerList [i];  			if (listener != null)  				listener.refresh (new TuioTime (currentTime));  		}  		List<long> buffer = aliveBlobList;  		aliveBlobList = newBlobList;  		// recycling the List  		newBlobList = buffer;  	}  	frameBlobs.Clear ();  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if (fseq > 0) {  	if (fseq > currentFrame)  		currentTime = TuioTime.SessionTime;  	if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  		currentFrame = fseq;  	else  		lateFrame = true;  }  else if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((fseq >= currentFrame) || ((currentFrame - fseq) > 100))  	currentFrame = fseq;  else  	lateFrame = true;  
Magic Number,TUIO,TuioClient,C:\repos\mkalten_TUIO11_NET\TUIO\TuioClient.cs,processMessage,The following statement contains a magic number: if ((TuioTime.SessionTime.TotalMilliseconds - currentTime.TotalMilliseconds) > 100) {  	currentTime = TuioTime.SessionTime;  }  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: lock (path) {  	path.AddLast (new TuioPoint (currentTime' xpos' ypos));  	if (path.Count > 128)  		path.RemoveFirst ();  }  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: if (path.Count > 128)  	path.RemoveFirst ();  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: lock (path) {  	path.AddLast (new TuioPoint (currentTime' xpos' ypos));  	if (path.Count > 128)  		path.RemoveFirst ();  }  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: if (path.Count > 128)  	path.RemoveFirst ();  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: lock (path) {  	path.AddLast (new TuioPoint (currentTime' xpos' ypos));  	if (path.Count > 128)  		path.RemoveFirst ();  }  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: if (path.Count > 128)  	path.RemoveFirst ();  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: lock (path) {  	path.AddLast (new TuioPoint (currentTime' xpos' ypos));  	if (path.Count > 128)  		path.RemoveFirst ();  }  
Magic Number,TUIO,TuioContainer,C:\repos\mkalten_TUIO11_NET\TUIO\TuioContainer.cs,update,The following statement contains a magic number: if (path.Count > 128)  	path.RemoveFirst ();  
Magic Number,TUIO,TuioTime,C:\repos\mkalten_TUIO11_NET\TUIO\TuioTime.cs,TuioTime,The following statement contains a magic number: this.seconds = msec / 1000;  
Magic Number,TUIO,TuioTime,C:\repos\mkalten_TUIO11_NET\TUIO\TuioTime.cs,TuioTime,The following statement contains a magic number: this.micro_seconds = 1000 * (msec % 1000);  
Magic Number,TUIO,TuioTime,C:\repos\mkalten_TUIO11_NET\TUIO\TuioTime.cs,TuioTime,The following statement contains a magic number: this.micro_seconds = 1000 * (msec % 1000);  
