Implementation smell,Namespace,Class,File,Method,Description
Long Method,Studyzy.IMEWLConverter.Helpers,FileOperationHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\FileOperationHelper.cs,AutoMatchSourceWLType,The method has 100 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The method has 107 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The method has 116 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The method has 107 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 128 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestArchive,The method has 126 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The method has 248 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLocalEntryHeader,The method has 118 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The method has 117 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,RunUpdates,The method has 137 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The method has 150 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The method has 106 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,PutNextEntry,The method has 221 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,CloseEntry,The method has 105 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,Finish,The method has 132 lines of code.
Complex Method,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,Cyclomatic complexity of the method is 11
Complex Method,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetFirstSecondLastCode,Cyclomatic complexity of the method is 8
Complex Method,Studyzy.IMEWLConverter.Helpers,CollectionHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\CollectionHelper.cs,GetString,Cyclomatic complexity of the method is 8
Complex Method,Studyzy.IMEWLConverter.Helpers,FileOperationHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\FileOperationHelper.cs,AutoMatchSourceWLType,Cyclomatic complexity of the method is 19
Complex Method,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,Cyclomatic complexity of the method is 14
Complex Method,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\WindowsNameTransform.cs,MakeValidName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,BeginUpdate,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,InitialRead,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 18
Complex Method,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,LoadImeList,Cyclomatic complexity of the method is 8
Long Parameter List,Studyzy.IMEWLConverter.Entities,WordLibraryStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\WordLibraryStream.cs,WordLibraryStream,The method has 5 parameters. Parameters: import' export' path' encoding' sw
Long Parameter List,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The method has 7 parameters. Parameters: inflatedBytes' offsetWords' offsetXml' dataLen' wordStringDecoder' xmlStringDecoder' i
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters. Parameters: filter' minSize' maxSize' minDate' maxDate
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\StreamUtils.cs,Copy,The method has 7 parameters. Parameters: source' destination' buffer' progressHandler' updateInterval' sender' name
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\StreamUtils.cs,Copy,The method has 8 parameters. Parameters: source' destination' buffer' progressHandler' updateInterval' sender' name' fixedTarget
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: zipFileName' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: outputStream' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,ExtractZip,The method has 7 parameters. Parameters: zipFileName' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,ExtractZip,The method has 8 parameters. Parameters: inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' isStreamOwner
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters. Parameters: update' destination' source' bytesToCopy' updateCrc
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters. Parameters: update' stream' updateCrc' destinationPosition' sourcePosition
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralFileHeaderSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralDirLocatorSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,Studyzy.IMEWLConverter.IME,MsPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\MsPinyin.cs,Export,The length of the statement  "                "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<ns1:Dictionary xmlns:ns1=\"http://www.microsoft.com/ime/dctx\">"); " is 133.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESStream.cs,Read,The length of the statement  "                            throw new Exception("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n" " is 150.
Long Statement,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/IME WL Converter WPF;component/wpf/mainwindow.xaml"' System.UriKind.Relative); " is 124.
Complex Conditional,Studyzy.IMEWLConverter.Helpers,PinyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\PinyinHelper.cs,AddToneToPinyin,The conditional expression  "pinyin == py + "0" || pinyin == py + "1" || pinyin == py + "2" || pinyin == py + "3" ||                          pinyin == py + "4" || pinyin == py + "5""  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The conditional expression  "(index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= MAX_BLOCK_SIZE) || // Block is full                  (blockStart < WSIZE && storedLength >= MAX_DIST) || // Block may move out of window                  flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH &&                      (hashHead = InsertString()) != 0 &&                      strategy != DeflateStrategy.HuffmanOnly &&                      strstart - hashHead <= MAX_DIST &&                      FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 &&                              (strategy == DeflateStrategy.Filtered ||                               (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) ||                  (startCentralDirDisk == 0xffff) ||                  (entriesForThisDisk == 0xffff) ||                  (entriesForWholeCentralDir == 0xffff) ||                  (centralDirSize == 0xffffffff) ||                  (offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature ||                  header == ZipConstants.EndOfCentralDirectorySignature ||                  header == ZipConstants.CentralHeaderDigitalSignature ||                  header == ZipConstants.ArchiveExtraDataSignature ||                  header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int) CompressionMethod.Stored &&                  (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,BodyRead,The conditional expression  "(flags & 8) == 0 &&                              (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)"  is complex.
Empty Catch Block,Studyzy.IMEWLConverter.IME,MsPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\MsPinyin.cs,Export,The method has an empty catch block.
Empty Catch Block,Studyzy.IMEWLConverter.IME,PinyinJiaJia,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\PinyinJiaJia.cs,ImportText,The method has an empty catch block.
Magic Number,Studyzy.IMEWLConverter.Entities,FilterConfig,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\FilterConfig.cs,FilterConfig,The following statement contains a magic number: WordLengthTo = 100;
Magic Number,Studyzy.IMEWLConverter.Entities,FilterConfig,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\FilterConfig.cs,FilterConfig,The following statement contains a magic number: WordRankTo = 999999;
Magic Number,Studyzy.IMEWLConverter.Entities,FilterConfig,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\FilterConfig.cs,FilterConfig,The following statement contains a magic number: WordRankPercentage = 100;
Magic Number,Studyzy.IMEWLConverter.Entities,ParsePattern,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\ParsePattern.cs,ParsePattern,The following statement contains a magic number: Sort = new List<int> {1' 2' 3};
Magic Number,Studyzy.IMEWLConverter.Entities,ParsePattern,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\ParsePattern.cs,ParsePattern,The following statement contains a magic number: Sort = new List<int> {1' 2' 3};
Magic Number,Studyzy.IMEWLConverter.Entities,ParsePattern,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Entities\ParsePattern.cs,BuildWlString,The following statement contains a magic number: dic.Add(Sort[2]' cp);
Magic Number,Studyzy.IMEWLConverter.Filters,LengthFilter,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Filters\LengthFilter.cs,LengthFilter,The following statement contains a magic number: MaxLength = 9999;
Magic Number,Studyzy.IMEWLConverter.Filters,RankFilter,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Filters\RankFilter.cs,RankFilter,The following statement contains a magic number: MaxLength = 999999;
Magic Number,Studyzy.IMEWLConverter.Filters,RankPercentageFilter,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Filters\RankPercentageFilter.cs,Filter,The following statement contains a magic number: if (Percentage == 100)              {                  return list;              }
Magic Number,Studyzy.IMEWLConverter.Filters,RankPercentageFilter,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Filters\RankPercentageFilter.cs,Filter,The following statement contains a magic number: int count = list.Count*Percentage/100;
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //第一个字2码（首尾码），第二字3码（取首次尾码）              {                  codes.Add(GetFirstAndLastCode(str[0]));                  codes.Add(GetFirstSecondLastCode(str[1]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 3) //221取码              {                  codes.Add(GetFirstAndLastCode(str[0]));                  IList<string> code2 = GetFirstAndLastCode(str[1]);                  codes.Add(code2);                  if (code2[0].Length == 1) //212取码                  {                      codes.Add(GetFirstAndLastCode(str[2]));                  }                  else                  {                      codes.Add(GetLastCode(str[2]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 3) //221取码              {                  codes.Add(GetFirstAndLastCode(str[0]));                  IList<string> code2 = GetFirstAndLastCode(str[1]);                  codes.Add(code2);                  if (code2[0].Length == 1) //212取码                  {                      codes.Add(GetFirstAndLastCode(str[2]));                  }                  else                  {                      codes.Add(GetLastCode(str[2]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 3) //221取码              {                  codes.Add(GetFirstAndLastCode(str[0]));                  IList<string> code2 = GetFirstAndLastCode(str[1]);                  codes.Add(code2);                  if (code2[0].Length == 1) //212取码                  {                      codes.Add(GetFirstAndLastCode(str[2]));                  }                  else                  {                      codes.Add(GetLastCode(str[2]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 4) //首2字当字首取2码，剩下的2字当字身3码（第3字2码，第4字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  IList<string> code3 = GetFirstAndLastCode(str[2]);                  codes.Add(code3);                  if (code3[0].Length == 1)                  {                      codes.Add(GetFirstAndLastCode(str[3]));                  }                  else                  {                      codes.Add(GetLastCode(str[3]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 4) //首2字当字首取2码，剩下的2字当字身3码（第3字2码，第4字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  IList<string> code3 = GetFirstAndLastCode(str[2]);                  codes.Add(code3);                  if (code3[0].Length == 1)                  {                      codes.Add(GetFirstAndLastCode(str[3]));                  }                  else                  {                      codes.Add(GetLastCode(str[3]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 4) //首2字当字首取2码，剩下的2字当字身3码（第3字2码，第4字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  IList<string> code3 = GetFirstAndLastCode(str[2]);                  codes.Add(code3);                  if (code3[0].Length == 1)                  {                      codes.Add(GetFirstAndLastCode(str[3]));                  }                  else                  {                      codes.Add(GetLastCode(str[3]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 4) //首2字当字首取2码，剩下的2字当字身3码（第3字2码，第4字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  IList<string> code3 = GetFirstAndLastCode(str[2]);                  codes.Add(code3);                  if (code3[0].Length == 1)                  {                      codes.Add(GetFirstAndLastCode(str[3]));                  }                  else                  {                      codes.Add(GetLastCode(str[3]));                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length >= 5) //首2字当字首取2码，剩下的3字当字身3码（第3字1码，第4字尾码  '5字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  codes.Add(GetFirstCode(str[2]));                  codes.Add(GetLastCode(str[str.Length - 2]));                  codes.Add(GetLastCode(str[str.Length - 1]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length >= 5) //首2字当字首取2码，剩下的3字当字身3码（第3字1码，第4字尾码  '5字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  codes.Add(GetFirstCode(str[2]));                  codes.Add(GetLastCode(str[str.Length - 2]));                  codes.Add(GetLastCode(str[str.Length - 1]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length >= 5) //首2字当字首取2码，剩下的3字当字身3码（第3字1码，第4字尾码  '5字尾码）。              {                  codes.Add(GetFirstCode(str[0]));                  codes.Add(GetLastCode(str[1]));                  codes.Add(GetFirstCode(str[2]));                  codes.Add(GetLastCode(str[str.Length - 2]));                  codes.Add(GetLastCode(str[str.Length - 1]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetFirstSecondLastCode,The following statement contains a magic number: foreach (Cangjie cangjy in x)              {                  try                  {                      if (cangjy.Code.Length == 1)                      {                          result.Add(cangjy.Code);                          continue;                      }                      string code = cangjy.Code[0].ToString() + cangjy.Code[1];                      if (cangjy.Code.Length > 2)                      {                          char lastCode = cangjy.Code[cangjy.Code.Length - 1];                          if (cangjy.SplitCode != null && !IgnoreContainRule)                          {                              string[] arr = cangjy.SplitCode.Split('\'');                                if (arr[0].Length > 2)                              {                                  lastCode = arr[0][arr[0].Length - 1];                              }                          }                          code += lastCode;                      }                      if (!result.Contains(code))                          result.Add(code);                  }                  catch (Exception ex)                  {                      Debug.WriteLine(ex.Message);                      throw ex;                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Cangjie5Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Cangjie5Generater.cs,GetFirstSecondLastCode,The following statement contains a magic number: foreach (Cangjie cangjy in x)              {                  try                  {                      if (cangjy.Code.Length == 1)                      {                          result.Add(cangjy.Code);                          continue;                      }                      string code = cangjy.Code[0].ToString() + cangjy.Code[1];                      if (cangjy.Code.Length > 2)                      {                          char lastCode = cangjy.Code[cangjy.Code.Length - 1];                          if (cangjy.SplitCode != null && !IgnoreContainRule)                          {                              string[] arr = cangjy.SplitCode.Split('\'');                                if (arr[0].Length > 2)                              {                                  lastCode = arr[0][arr[0].Length - 1];                              }                          }                          code += lastCode;                      }                      if (!result.Contains(code))                          result.Add(code);                  }                  catch (Exception ex)                  {                      Debug.WriteLine(ex.Message);                      throw ex;                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ErbiGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ErbiGenerater.cs,GetErbiCode,The following statement contains a magic number: try              {                  if (str.Length == 1)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                  }                  else if (str.Length == 2) //各取2码                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(Get1CharCode(str[1]' py[1]));                  }                  else if (str.Length == 3)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(new List<string> {py[1][0].ToString()});                      codes.Add(new List<string> {py[2][0].ToString()});                  }                  else                  {                      codes.Add(new List<string> {py[0][0].ToString() + py[1][0] + py[2][0] + py[str.Length - 1][0]});                  }              }              catch (Exception ex)              {                  Debug.WriteLine(ex.Message);                  return null;              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ErbiGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ErbiGenerater.cs,GetErbiCode,The following statement contains a magic number: try              {                  if (str.Length == 1)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                  }                  else if (str.Length == 2) //各取2码                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(Get1CharCode(str[1]' py[1]));                  }                  else if (str.Length == 3)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(new List<string> {py[1][0].ToString()});                      codes.Add(new List<string> {py[2][0].ToString()});                  }                  else                  {                      codes.Add(new List<string> {py[0][0].ToString() + py[1][0] + py[2][0] + py[str.Length - 1][0]});                  }              }              catch (Exception ex)              {                  Debug.WriteLine(ex.Message);                  return null;              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ErbiGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ErbiGenerater.cs,GetErbiCode,The following statement contains a magic number: try              {                  if (str.Length == 1)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                  }                  else if (str.Length == 2) //各取2码                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(Get1CharCode(str[1]' py[1]));                  }                  else if (str.Length == 3)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(new List<string> {py[1][0].ToString()});                      codes.Add(new List<string> {py[2][0].ToString()});                  }                  else                  {                      codes.Add(new List<string> {py[0][0].ToString() + py[1][0] + py[2][0] + py[str.Length - 1][0]});                  }              }              catch (Exception ex)              {                  Debug.WriteLine(ex.Message);                  return null;              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ErbiGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ErbiGenerater.cs,GetErbiCode,The following statement contains a magic number: try              {                  if (str.Length == 1)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                  }                  else if (str.Length == 2) //各取2码                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(Get1CharCode(str[1]' py[1]));                  }                  else if (str.Length == 3)                  {                      codes.Add(Get1CharCode(str[0]' py[0]));                      codes.Add(new List<string> {py[1][0].ToString()});                      codes.Add(new List<string> {py[2][0].ToString()});                  }                  else                  {                      codes.Add(new List<string> {py[0][0].ToString() + py[1][0] + py[2][0] + py[str.Length - 1][0]});                  }              }              catch (Exception ex)              {                  Debug.WriteLine(ex.Message);                  return null;              }
Magic Number,Studyzy.IMEWLConverter.Generaters,SelfDefiningCodeGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\SelfDefiningCodeGenerater.cs,GetCodeOfString,The following statement contains a magic number: foreach (string line in arr)              {                  string[] kv = line.Split('=');                  string key = kv[0].Substring(5);                  string value = kv[1];                    format.Add(key' value);              }
Magic Number,Studyzy.IMEWLConverter.Generaters,SelfDefiningCodeGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\SelfDefiningCodeGenerater.cs,GetStringCode,The following statement contains a magic number: foreach (string s in flist)              {                  char pn = s[0]; //可能P也可能N，p表示左取，n表示右取                  int pindex = Convert.ToInt32(s[1].ToString());                  char c = ' ';                  if (pn == 'p')                      c = str[pindex - 1];                    else if (pn == 'n')                      c = str[str.Length - pindex];                  string pcode = GetDefaultCodeOfChar(c);                  int cindex = Convert.ToInt32(s[2].ToString());                  if (pcode.Length >= cindex)                        result += pcode[cindex - 1];                    else                  {                      Debug.WriteLine(str + " 编码生成错误");                  }              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 2)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  return code1.Substring(0' 2) + code2.Substring(0' 2);              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 2)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  return code1.Substring(0' 2) + code2.Substring(0' 2);              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 2)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  return code1.Substring(0' 2) + code2.Substring(0' 2);              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 3)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  return code1[0].ToString() + code2[0] + code3.Substring(0' 2);              }              else              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  string code4 = GetDefaultCodeOfChar(str[str.Length - 1]);                  return code1[0].ToString() + code2[0] + code3[0] + code4[0];              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 3)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  return code1[0].ToString() + code2[0] + code3.Substring(0' 2);              }              else              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  string code4 = GetDefaultCodeOfChar(str[str.Length - 1]);                  return code1[0].ToString() + code2[0] + code3[0] + code4[0];              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 3)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  return code1[0].ToString() + code2[0] + code3.Substring(0' 2);              }              else              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  string code4 = GetDefaultCodeOfChar(str[str.Length - 1]);                  return code1[0].ToString() + code2[0] + code3[0] + code4[0];              }
Magic Number,Studyzy.IMEWLConverter.Generaters,Wubi86Generater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\Wubi86Generater.cs,GetStringWubiCode,The following statement contains a magic number: if (str.Length == 3)              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  return code1[0].ToString() + code2[0] + code3.Substring(0' 2);              }              else              {                  string code1 = GetDefaultCodeOfChar(str[0]);                  string code2 = GetDefaultCodeOfChar(str[1]);                  string code3 = GetDefaultCodeOfChar(str[2]);                  string code4 = GetDefaultCodeOfChar(str[str.Length - 1]);                  return code1[0].ToString() + code2[0] + code3[0] + code4[0];              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ZhengmaGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ZhengmaGenerater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //二字词组 2+2              {                  codes.Append(Get2Code(str[0]));                  codes.Append(Get2Code(str[1]));              }              else if (str.Length == 3) //三字词组 1+2+1              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get2Code(str[1]));                  codes.Append(Get1Code(str[2]));              }              else              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get1Code(str[1]));                  codes.Append(Get1Code(str[2]));                  codes.Append(Get1Code(str[3]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ZhengmaGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ZhengmaGenerater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //二字词组 2+2              {                  codes.Append(Get2Code(str[0]));                  codes.Append(Get2Code(str[1]));              }              else if (str.Length == 3) //三字词组 1+2+1              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get2Code(str[1]));                  codes.Append(Get1Code(str[2]));              }              else              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get1Code(str[1]));                  codes.Append(Get1Code(str[2]));                  codes.Append(Get1Code(str[3]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ZhengmaGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ZhengmaGenerater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //二字词组 2+2              {                  codes.Append(Get2Code(str[0]));                  codes.Append(Get2Code(str[1]));              }              else if (str.Length == 3) //三字词组 1+2+1              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get2Code(str[1]));                  codes.Append(Get1Code(str[2]));              }              else              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get1Code(str[1]));                  codes.Append(Get1Code(str[2]));                  codes.Append(Get1Code(str[3]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ZhengmaGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ZhengmaGenerater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //二字词组 2+2              {                  codes.Append(Get2Code(str[0]));                  codes.Append(Get2Code(str[1]));              }              else if (str.Length == 3) //三字词组 1+2+1              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get2Code(str[1]));                  codes.Append(Get1Code(str[2]));              }              else              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get1Code(str[1]));                  codes.Append(Get1Code(str[2]));                  codes.Append(Get1Code(str[3]));              }
Magic Number,Studyzy.IMEWLConverter.Generaters,ZhengmaGenerater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Generaters\ZhengmaGenerater.cs,GetCodeOfString,The following statement contains a magic number: if (str.Length == 2) //二字词组 2+2              {                  codes.Append(Get2Code(str[0]));                  codes.Append(Get2Code(str[1]));              }              else if (str.Length == 3) //三字词组 1+2+1              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get2Code(str[1]));                  codes.Append(Get1Code(str[2]));              }              else              {                  codes.Append(Get1Code(str[0]));                  codes.Append(Get1Code(str[1]));                  codes.Append(Get1Code(str[2]));                  codes.Append(Get1Code(str[3]));              }
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt16,The following statement contains a magic number: var temp = new byte[2];
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt16,The following statement contains a magic number: fs.Read(temp' 0' 2);
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt32,The following statement contains a magic number: var temp = new byte[4];
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt32,The following statement contains a magic number: fs.Read(temp' 0' 4);
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt64,The following statement contains a magic number: var temp = new byte[8];
Magic Number,Studyzy.IMEWLConverter.Helpers,BinFileHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\BinFileHelper.cs,ReadInt64,The following statement contains a magic number: fs.Read(temp' 0' 8);
Magic Number,Studyzy.IMEWLConverter.Helpers,FileOperationHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\FileOperationHelper.cs,AutoMatchSourceWLType,The following statement contains a magic number: using (var sr = new StreamReader(filePath' code))              {                  for (int i = 0; i < 5; i++)                  {                      example = sr.ReadLine();                  }                  sr.Close();              }
Magic Number,Studyzy.IMEWLConverter.Helpers,FileOperationHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\FileOperationHelper.cs,GetType,The following statement contains a magic number: using (var r = new BinaryReader(fs))              {                  byte[] ss = r.ReadBytes(3);                    //编码类型 Coding=编码类型.ASCII;                     if (ss[0] >= 0xEF)                  {                      if (ss[0] == 0xEF && ss[1] == 0xBB && ss[2] == 0xBF) // start of UTF-8 BOM                      {                          return Encoding.UTF8;                      }                      if (ss[0] == 0xFE && ss[1] == 0xFF) // UTF-16 BE BOM                      {                          return Encoding.BigEndianUnicode;                      }                      if (ss[0] == 0xFF && ss[1] == 0xFE) // Unicode BOM (UTF-16 LE or UTF-32 LE)                      {                          return Encoding.Unicode;                      }                      return IsUtf8OrGb18030(fs);                  }                  return IsUtf8OrGb18030(fs);              }
Magic Number,Studyzy.IMEWLConverter.Helpers,FileOperationHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\FileOperationHelper.cs,GetType,The following statement contains a magic number: using (var r = new BinaryReader(fs))              {                  byte[] ss = r.ReadBytes(3);                    //编码类型 Coding=编码类型.ASCII;                     if (ss[0] >= 0xEF)                  {                      if (ss[0] == 0xEF && ss[1] == 0xBB && ss[2] == 0xBF) // start of UTF-8 BOM                      {                          return Encoding.UTF8;                      }                      if (ss[0] == 0xFE && ss[1] == 0xFF) // UTF-16 BE BOM                      {                          return Encoding.BigEndianUnicode;                      }                      if (ss[0] == 0xFF && ss[1] == 0xFE) // Unicode BOM (UTF-16 LE or UTF-32 LE)                      {                          return Encoding.Unicode;                      }                      return IsUtf8OrGb18030(fs);                  }                  return IsUtf8OrGb18030(fs);              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetZhuyin,The following statement contains a magic number: int yindiao = 10;
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoZhuyin,The following statement contains a magic number: switch (yindiao)              {                  case 1:                      return "";                  case 2:                      return "ˊ";                  case 3:                      return "ˇ";                  case 4:                      return "ˋ";                  case 5:                      return "·";                  default:                      return "";              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoZhuyin,The following statement contains a magic number: switch (yindiao)              {                  case 1:                      return "";                  case 2:                      return "ˊ";                  case 3:                      return "ˇ";                  case 4:                      return "ˋ";                  case 5:                      return "·";                  default:                      return "";              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoZhuyin,The following statement contains a magic number: switch (yindiao)              {                  case 1:                      return "";                  case 2:                      return "ˊ";                  case 3:                      return "ˇ";                  case 4:                      return "ˋ";                  case 5:                      return "·";                  default:                      return "";              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoZhuyin,The following statement contains a magic number: switch (yindiao)              {                  case 1:                      return "";                  case 2:                      return "ˊ";                  case 3:                      return "ˇ";                  case 4:                      return "ˋ";                  case 5:                      return "·";                  default:                      return "";              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoPinyin,The following statement contains a magic number: switch (yindiao)              {                  case 'ˊ':                      return 2;                  case 'ˇ':                      return 3;                  case 'ˋ':                      return 4;                  case '·':                      return 5;                  default:                      return 1;              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoPinyin,The following statement contains a magic number: switch (yindiao)              {                  case 'ˊ':                      return 2;                  case 'ˇ':                      return 3;                  case 'ˋ':                      return 4;                  case '·':                      return 5;                  default:                      return 1;              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoPinyin,The following statement contains a magic number: switch (yindiao)              {                  case 'ˊ':                      return 2;                  case 'ˇ':                      return 3;                  case 'ˋ':                      return 4;                  case '·':                      return 5;                  default:                      return 1;              }
Magic Number,Studyzy.IMEWLConverter.Helpers,ZhuyinHelper,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\Helpers\ZhuyinHelper.cs,GetYindiaoPinyin,The following statement contains a magic number: switch (yindiao)              {                  case 'ˊ':                      return 2;                  case 'ˇ':                      return 3;                  case 'ˋ':                      return 4;                  case '·':                      return 5;                  default:                      return 1;              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyin.cs,ImportLine,The following statement contains a magic number: if (array.Length == 2) //English              {                  wl.IsEnglish = true;                  wl.Rank = Convert.ToInt32(array[1]);              }              else              {                  string py = line.Split('\t')[1];                  wl.PinYin = py.Split(new[] {'\''}' StringSplitOptions.RemoveEmptyEntries);                  wl.Rank = Convert.ToInt32(array[2]);              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyin.cs,ImportLine,The following statement contains a magic number: if (array.Length == 2) //English              {                  wl.IsEnglish = true;                  wl.Rank = Convert.ToInt32(array[1]);              }              else              {                  string py = line.Split('\t')[1];                  wl.PinYin = py.Split(new[] {'\''}' StringSplitOptions.RemoveEmptyEntries);                  wl.Rank = Convert.ToInt32(array[2]);              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: var temp = new byte[4];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: fs.Read(temp' 0' 4);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: if (len > 1000)              {                  throw new Exception("有异常的词库，解析失败");              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  temp = new byte[2];                  fs.Read(temp' 0' 2);                  try                  {                      string sm = Shengmu[temp[0]];                      string ym = Yunmu[temp[1]];                        pinyinList.Add(sm + ym);                  }                  catch (Exception e)                  {                      Debug.WriteLine(e.Message);                      show = temp[0];                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  temp = new byte[2];                  fs.Read(temp' 0' 2);                  try                  {                      string sm = Shengmu[temp[0]];                      string ym = Yunmu[temp[1]];                        pinyinList.Add(sm + ym);                  }                  catch (Exception e)                  {                      Debug.WriteLine(e.Message);                      show = temp[0];                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: temp = new byte[2*len];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,ImportWord,The following statement contains a magic number: fs.Read(temp' 0' 2*len);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: var temp = new byte[2];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: fs.Read(temp' 0' 2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: fs.Read(temp' 0' 2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: temp = new byte[pinyinLen*2];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: fs.Read(temp' 0' pinyinLen*2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: temp = new byte[wordLen*2];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduPinyinBdict,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduPinyinBdict.cs,SpecialWord,The following statement contains a magic number: fs.Read(temp' 0' wordLen*2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: var temp = new byte[2];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: fs.Read(temp' 0' 2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: fs.Read(temp' 0' 2);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  temp = new byte[2];                  fs.Read(temp' 0' 2);                    pinyinList.Add(Shengmu[temp[0]] + Yunmu[temp[1]]);              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  temp = new byte[2];                  fs.Read(temp' 0' 2);                    pinyinList.Add(Shengmu[temp[0]] + Yunmu[temp[1]]);              }
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: temp = new byte[2*len];
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiBcd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiBcd.cs,ImportWord,The following statement contains a magic number: fs.Read(temp' 0' 2*len);
Magic Number,Studyzy.IMEWLConverter.IME,BaiduShoujiEng,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\BaiduShoujiEng.cs,ExportLine,The following statement contains a magic number: return wl.Word + "\t" + (54999 + wl.Rank);
Magic Number,Studyzy.IMEWLConverter.IME,GooglePinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\GooglePinyin.cs,ImportLine,The following statement contains a magic number: wl.PinYin = c[2].Split(new[] {' '}' StringSplitOptions.RemoveEmptyEntries);
Magic Number,Studyzy.IMEWLConverter.IME,iFlyIME,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\iFlyIME.cs,Export,The following statement contains a magic number: const int MAX_COUNT = 16000;
Magic Number,Studyzy.IMEWLConverter.IME,iFlyIME,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\iFlyIME.cs,Export,The following statement contains a magic number: for (int count = 1; count <= fileCount; count++)              {                  var sb = new StringBuilder();                  int rowCount = 0;                  for (int i = 0; i < (count == fileCount ? wlList.Count%MAX_COUNT : MAX_COUNT); i++)                  {                      var wl = wlList[(count-1)*MAX_COUNT+i];                      if (wl.Word.Length > 1 && wl.Word.Length < 17)                      {                          sb.Append(wl.Word);                          sb.Append("\n");                          rowCount++;                      }                  }                    result.Add(string.Format(headFormat' rowCount) + "\n" + sb.ToString());              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Parse,The following statement contains a magic number: using (var fs = new FileStream(ld2File' FileMode.Open' FileAccess.Read))              {                  Debug.WriteLine("文件：" + ld2File);                  byte[] bs = BinFileHelper.ReadArray(fs' 4);                  string v = Encoding.ASCII.GetString(bs);                  Debug.WriteLine("类型：" + v);                  fs.Position = 0x18;                  Debug.WriteLine("版本：" + BinFileHelper.ReadInt16(fs) + "." + BinFileHelper.ReadInt16(fs));                  Debug.WriteLine("ID: 0x" + (BinFileHelper.ReadInt64(fs).ToString("x")));                    fs.Position = 0x5c;                  int offsetData = BinFileHelper.ReadInt32(fs) + 0x60;                  if (fs.Length > offsetData)                  {                      Debug.WriteLine("简介地址：0x" + (offsetData).ToString("x"));                      fs.Position = offsetData;                      int type = BinFileHelper.ReadInt32(fs);                      Debug.WriteLine("简介类型：0x" + (type).ToString("x"));                      fs.Position = offsetData + 4;                      int offsetWithInfo = BinFileHelper.ReadInt32(fs) + offsetData + 12;                      if (type == 3)                      {                          // without additional information                          return ReadDictionary(fs' offsetData);                      }                      if (fs.Length > offsetWithInfo - 0x1C)                      {                          return ReadDictionary(fs' offsetWithInfo);                      }                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                  else                  {                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                      return null;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Parse,The following statement contains a magic number: using (var fs = new FileStream(ld2File' FileMode.Open' FileAccess.Read))              {                  Debug.WriteLine("文件：" + ld2File);                  byte[] bs = BinFileHelper.ReadArray(fs' 4);                  string v = Encoding.ASCII.GetString(bs);                  Debug.WriteLine("类型：" + v);                  fs.Position = 0x18;                  Debug.WriteLine("版本：" + BinFileHelper.ReadInt16(fs) + "." + BinFileHelper.ReadInt16(fs));                  Debug.WriteLine("ID: 0x" + (BinFileHelper.ReadInt64(fs).ToString("x")));                    fs.Position = 0x5c;                  int offsetData = BinFileHelper.ReadInt32(fs) + 0x60;                  if (fs.Length > offsetData)                  {                      Debug.WriteLine("简介地址：0x" + (offsetData).ToString("x"));                      fs.Position = offsetData;                      int type = BinFileHelper.ReadInt32(fs);                      Debug.WriteLine("简介类型：0x" + (type).ToString("x"));                      fs.Position = offsetData + 4;                      int offsetWithInfo = BinFileHelper.ReadInt32(fs) + offsetData + 12;                      if (type == 3)                      {                          // without additional information                          return ReadDictionary(fs' offsetData);                      }                      if (fs.Length > offsetWithInfo - 0x1C)                      {                          return ReadDictionary(fs' offsetWithInfo);                      }                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                  else                  {                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                      return null;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Parse,The following statement contains a magic number: using (var fs = new FileStream(ld2File' FileMode.Open' FileAccess.Read))              {                  Debug.WriteLine("文件：" + ld2File);                  byte[] bs = BinFileHelper.ReadArray(fs' 4);                  string v = Encoding.ASCII.GetString(bs);                  Debug.WriteLine("类型：" + v);                  fs.Position = 0x18;                  Debug.WriteLine("版本：" + BinFileHelper.ReadInt16(fs) + "." + BinFileHelper.ReadInt16(fs));                  Debug.WriteLine("ID: 0x" + (BinFileHelper.ReadInt64(fs).ToString("x")));                    fs.Position = 0x5c;                  int offsetData = BinFileHelper.ReadInt32(fs) + 0x60;                  if (fs.Length > offsetData)                  {                      Debug.WriteLine("简介地址：0x" + (offsetData).ToString("x"));                      fs.Position = offsetData;                      int type = BinFileHelper.ReadInt32(fs);                      Debug.WriteLine("简介类型：0x" + (type).ToString("x"));                      fs.Position = offsetData + 4;                      int offsetWithInfo = BinFileHelper.ReadInt32(fs) + offsetData + 12;                      if (type == 3)                      {                          // without additional information                          return ReadDictionary(fs' offsetData);                      }                      if (fs.Length > offsetWithInfo - 0x1C)                      {                          return ReadDictionary(fs' offsetWithInfo);                      }                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                  else                  {                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                      return null;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Parse,The following statement contains a magic number: using (var fs = new FileStream(ld2File' FileMode.Open' FileAccess.Read))              {                  Debug.WriteLine("文件：" + ld2File);                  byte[] bs = BinFileHelper.ReadArray(fs' 4);                  string v = Encoding.ASCII.GetString(bs);                  Debug.WriteLine("类型：" + v);                  fs.Position = 0x18;                  Debug.WriteLine("版本：" + BinFileHelper.ReadInt16(fs) + "." + BinFileHelper.ReadInt16(fs));                  Debug.WriteLine("ID: 0x" + (BinFileHelper.ReadInt64(fs).ToString("x")));                    fs.Position = 0x5c;                  int offsetData = BinFileHelper.ReadInt32(fs) + 0x60;                  if (fs.Length > offsetData)                  {                      Debug.WriteLine("简介地址：0x" + (offsetData).ToString("x"));                      fs.Position = offsetData;                      int type = BinFileHelper.ReadInt32(fs);                      Debug.WriteLine("简介类型：0x" + (type).ToString("x"));                      fs.Position = offsetData + 4;                      int offsetWithInfo = BinFileHelper.ReadInt32(fs) + offsetData + 12;                      if (type == 3)                      {                          // without additional information                          return ReadDictionary(fs' offsetData);                      }                      if (fs.Length > offsetWithInfo - 0x1C)                      {                          return ReadDictionary(fs' offsetWithInfo);                      }                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                  else                  {                      Debug.WriteLine("文件不包含字典数据。网上字典？");                  }                      return null;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDictionary,The following statement contains a magic number: int limit = BinFileHelper.ReadInt32(fs) + offsetWithIndex + 8;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDictionary,The following statement contains a magic number: int definitions = (offsetCompressedDataHeader - offsetIndex)/4;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDictionary,The following statement contains a magic number: fs.Position = offsetCompressedDataHeader + 8;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDictionary,The following statement contains a magic number: Debug.WriteLine("文件大小（解压缩后）：" + (inflatedWordsIndexLength + inflatedWordsLength + inflatedXmlLength)/1024                              + " KB");
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: var in1 = new InflaterInputStream(stream' inflator' 1024*8);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: var in1 = new InflaterInputStream(stream' inflator' 1024*8);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: var buffer = new byte[1024*8];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: var buffer = new byte[1024*8];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: while ((len = in1.Read(buffer' 0' 1024*8)) > 0)              {                  for (int i = 0; i < len; i++)                  {                      t.Add(buffer[i]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Decompress,The following statement contains a magic number: while ((len = in1.Read(buffer' 0' 1024*8)) > 0)              {                  for (int i = 0; i < len; i++)                  {                      t.Add(buffer[i]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,Extract,The following statement contains a magic number: int dataLen = 10;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: var idxData = new int[6];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: int flags = idxData[2];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: int refs = idxData[3];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: int currentWordOffset = idxData[4];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: int currenXmlOffset = idxData[5];
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: while (refs-- > 0)              {                  int position = (offsetWords + lastWordPos);                  int ref1 = BitConverter.ToInt32(inflatedBytes' position);                  GetIdxData(inflatedBytes' dataLen*ref1' idxData);                  lastXmlPos = idxData[1];                  currenXmlOffset = idxData[5];                  if (string.IsNullOrEmpty(xml))                  {                      xml = xmlStringDecoder.GetString(inflatedBytes' offsetXml + lastXmlPos' currenXmlOffset - lastXmlPos);                  }                  else                  {                      xml =                          xmlStringDecoder.GetString(inflatedBytes' offsetXml + lastXmlPos' currenXmlOffset - lastXmlPos) +                          "' " + xml;                  }                  lastWordPos += 4;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,ReadDefinitionData,The following statement contains a magic number: while (refs-- > 0)              {                  int position = (offsetWords + lastWordPos);                  int ref1 = BitConverter.ToInt32(inflatedBytes' position);                  GetIdxData(inflatedBytes' dataLen*ref1' idxData);                  lastXmlPos = idxData[1];                  currenXmlOffset = idxData[5];                  if (string.IsNullOrEmpty(xml))                  {                      xml = xmlStringDecoder.GetString(inflatedBytes' offsetXml + lastXmlPos' currenXmlOffset - lastXmlPos);                  }                  else                  {                      xml =                          xmlStringDecoder.GetString(inflatedBytes' offsetXml + lastXmlPos' currenXmlOffset - lastXmlPos) +                          "' " + xml;                  }                  lastWordPos += 4;              }
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[1] = BitConverter.ToInt32(dataRawBytes' position + 4);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[2] = dataRawBytes[position + 8] & 0xff;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[2] = dataRawBytes[position + 8] & 0xff;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[3] = dataRawBytes[position + 9] & 0xff;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[3] = dataRawBytes[position + 9] & 0xff;
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[4] = BitConverter.ToInt32(dataRawBytes' position + 10);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[4] = BitConverter.ToInt32(dataRawBytes' position + 10);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[5] = BitConverter.ToInt32(dataRawBytes' position + 14);
Magic Number,Studyzy.IMEWLConverter.IME,LingoesLd2,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\LingoesLd2.cs,GetIdxData,The following statement contains a magic number: wordIdxData[5] = BitConverter.ToInt32(dataRawBytes' position + 14);
Magic Number,Studyzy.IMEWLConverter.IME,QQPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\QQPinyin.cs,ImportLine,The following statement contains a magic number: int count = Convert.ToInt32(sp[2]);
Magic Number,Studyzy.IMEWLConverter.IME,QQPinyinQpyd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\QQPinyinQpyd.cs,ParseQpyd,The following statement contains a magic number: var startAddressByte = new byte[4];
Magic Number,Studyzy.IMEWLConverter.IME,QQPinyinQpyd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\QQPinyinQpyd.cs,ParseQpyd,The following statement contains a magic number: fs.Read(startAddressByte' 0' 4);
Magic Number,Studyzy.IMEWLConverter.IME,QQPinyinQpyd,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\QQPinyinQpyd.cs,ParseQpyd,The following statement contains a magic number: int bufferSize = 2048;
Magic Number,Studyzy.IMEWLConverter.IME,QQShouji,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\QQShouji.cs,Export,The following statement contains a magic number: for (int i = 0; i < wlList.Count; i++)              {                  number = (int) Math.Ceiling((wlList.Count - i)*100.0/wlList.Count);                  sb.Append(ExportLine(wlList[i]));                  sb.Append("\r\n");              }
Magic Number,Studyzy.IMEWLConverter.IME,Rime,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\Rime.cs,ImportLine,The following statement contains a magic number: wl.Rank = Convert.ToInt32(lineArray[2]);
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildLineFormat,The following statement contains a magic number: if (UserDefiningPattern.ContainRank)              {                  dictionary.Add(UserDefiningPattern.Sort[2]' "{2}");              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (index1 == 2 && UserDefiningPattern.ContainRank) //第一个是词频              {                  rank = Convert.ToInt32(strlist[0]);              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 1)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[1]); //中间的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //一个是Code                  {                      code = strlist[1];                  }                  if (index2 == 1)                  {                      word = strlist[1];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[1]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SelfDefining,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SelfDefining.cs,BuildWordLibrary,The following statement contains a magic number: if (strlist.Length > 2)              {                  int index2 = UserDefiningPattern.Sort.FindIndex(i => i == newSort[2]); //最大的一个                  if (index2 == 0 && UserDefiningPattern.ContainCode) //第一个是拼音                  {                      code = strlist[2];                  }                  if (index2 == 1)                  {                      word = strlist[2];                  }                  if (index2 == 2 && UserDefiningPattern.ContainRank)                  {                      rank = Convert.ToInt32(strlist[2]);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,ShouxinPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ShouxinPinyin.cs,ImportLine,The following statement contains a magic number: wl.Rank = Convert.ToInt32(c[2]);
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinBin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinBin.cs,Import,The following statement contains a magic number: while (CurrentStatus < CountWord)              {                  int samePyCount = BinFileHelper.ReadInt16(fs);                  int unkown1 = BinFileHelper.ReadInt16(fs);                  short pyLength = BinFileHelper.ReadInt16(fs);                  var pyArray = new string[pyLength/2];                  for (int i = 0; i < pyLength/2; i++)                  {                      short idx = BinFileHelper.ReadInt16(fs);                      try                      {                          pyArray[i] = PinYinDic[idx];                      }                      catch                      {                          pyArray[i] = "--";                      }                  }                  for (int i = 0; i < samePyCount; i++)                  {                      short wordByteLength = BinFileHelper.ReadInt16(fs);                      var wordArray = new byte[wordByteLength];                      fs.Read(wordArray' 0' wordByteLength);                      string word = Encoding.Unicode.GetString(wordArray);                      short count = BinFileHelper.ReadInt16(fs);                      short count2 = BinFileHelper.ReadInt16(fs);                      int unknown = BinFileHelper.ReadInt32(fs); //不知道干啥的                      if (pyArray.Length == word.Length)                      {                          var wl = new WordLibrary {Rank = count' Word = word' PinYin = pyArray};                          pyAndWord.Add(wl);                      }                      else                      {                          Debug.WriteLine("Error data: word:[" + word + "] pinyin:[" + string.Join("'"' pyArray) + "]");                      }                      CurrentStatus++;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinBin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinBin.cs,Import,The following statement contains a magic number: while (CurrentStatus < CountWord)              {                  int samePyCount = BinFileHelper.ReadInt16(fs);                  int unkown1 = BinFileHelper.ReadInt16(fs);                  short pyLength = BinFileHelper.ReadInt16(fs);                  var pyArray = new string[pyLength/2];                  for (int i = 0; i < pyLength/2; i++)                  {                      short idx = BinFileHelper.ReadInt16(fs);                      try                      {                          pyArray[i] = PinYinDic[idx];                      }                      catch                      {                          pyArray[i] = "--";                      }                  }                  for (int i = 0; i < samePyCount; i++)                  {                      short wordByteLength = BinFileHelper.ReadInt16(fs);                      var wordArray = new byte[wordByteLength];                      fs.Read(wordArray' 0' wordByteLength);                      string word = Encoding.Unicode.GetString(wordArray);                      short count = BinFileHelper.ReadInt16(fs);                      short count2 = BinFileHelper.ReadInt16(fs);                      int unknown = BinFileHelper.ReadInt32(fs); //不知道干啥的                      if (pyArray.Length == word.Length)                      {                          var wl = new WordLibrary {Rank = count' Word = word' PinYin = pyArray};                          pyAndWord.Add(wl);                      }                      else                      {                          Debug.WriteLine("Error data: word:[" + word + "] pinyin:[" + string.Join("'"' pyArray) + "]");                      }                      CurrentStatus++;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: var str = new byte[128];
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: var outstr = new byte[128];
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: fs.Read(str' 0' 128);
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: if (str[4] == 0x44)              {                  hzPosition = 0x2628;              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: if (str[4] == 0x45)              {                  hzPosition = 0x26C4;              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: str = new byte[4];
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: fs.Read(str' 0' 4);
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: while (true)              {                  num = new byte[4];                  fs.Read(num' 0' 4);                  int mark = num[0] + num[1]*256;                  str = new byte[128];                  fs.Read(str' 0' (num[2]));                  string py = Encoding.Unicode.GetString(str);                  py = py.Substring(0' py.IndexOf('\0'));                  pyDic.Add(mark' py);                  if (py == "zuo") //最后一个拼音                  {                      break;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: while (true)              {                  num = new byte[4];                  fs.Read(num' 0' 4);                  int mark = num[0] + num[1]*256;                  str = new byte[128];                  fs.Read(str' 0' (num[2]));                  string py = Encoding.Unicode.GetString(str);                  py = py.Substring(0' py.IndexOf('\0'));                  pyDic.Add(mark' py);                  if (py == "zuo") //最后一个拼音                  {                      break;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: while (true)              {                  num = new byte[4];                  fs.Read(num' 0' 4);                  int mark = num[0] + num[1]*256;                  str = new byte[128];                  fs.Read(str' 0' (num[2]));                  string py = Encoding.Unicode.GetString(str);                  py = py.Substring(0' py.IndexOf('\0'));                  pyDic.Add(mark' py);                  if (py == "zuo") //最后一个拼音                  {                      break;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: while (true)              {                  num = new byte[4];                  fs.Read(num' 0' 4);                  int mark = num[0] + num[1]*256;                  str = new byte[128];                  fs.Read(str' 0' (num[2]));                  string py = Encoding.Unicode.GetString(str);                  py = py.Substring(0' py.IndexOf('\0'));                  pyDic.Add(mark' py);                  if (py == "zuo") //最后一个拼音                  {                      break;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadScel,The following statement contains a magic number: while (true)              {                  num = new byte[4];                  fs.Read(num' 0' 4);                  int mark = num[0] + num[1]*256;                  str = new byte[128];                  fs.Read(str' 0' (num[2]));                  string py = Encoding.Unicode.GetString(str);                  py = py.Substring(0' py.IndexOf('\0'));                  pyDic.Add(mark' py);                  if (py == "zuo") //最后一个拼音                  {                      break;                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: var num = new byte[4];
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: fs.Read(num' 0' 4);
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: int samePYcount = num[0] + num[1]*256;
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: int count = num[2] + num[3]*256;
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: int count = num[2] + num[3]*256;
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: int count = num[2] + num[3]*256;
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: var str = new byte[256];
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int i = 0; i < count/2; i++)              {                  int key = str[i*2] + str[i*2 + 1]*256;                  wordPY.Add(pyDic[key]);              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int i = 0; i < count/2; i++)              {                  int key = str[i*2] + str[i*2 + 1]*256;                  wordPY.Add(pyDic[key]);              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int i = 0; i < count/2; i++)              {                  int key = str[i*2] + str[i*2 + 1]*256;                  wordPY.Add(pyDic[key]);              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int i = 0; i < count/2; i++)              {                  int key = str[i*2] + str[i*2 + 1]*256;                  wordPY.Add(pyDic[key]);              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int s = 0; s < samePYcount; s++) //同音词，使用前面相同的拼音              {                  num = new byte[2];                  fs.Read(num' 0' 2);                  int hzBytecount = num[0] + num[1]*256;                  str = new byte[hzBytecount];                  fs.Read(str' 0' hzBytecount);                  string word = Encoding.Unicode.GetString(str);                  short unknown1 = BinFileHelper.ReadInt16(fs); //全部是10'肯定不是词频，具体是什么不知道                  int unknown2 = BinFileHelper.ReadInt32(fs); //每个字对应的数字不一样，不知道是不是词频                  pyAndWord.Add(new WordLibrary {Word = word' PinYin = wordPY.ToArray()' Rank = DefaultRank});                  CurrentStatus++;                  //接下来10个字节什么意思呢？暂时先忽略了                  var temp = new byte[6];                  for (int i = 0; i < 6; i++)                  {                      temp[i] = (byte) fs.ReadByte();                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int s = 0; s < samePYcount; s++) //同音词，使用前面相同的拼音              {                  num = new byte[2];                  fs.Read(num' 0' 2);                  int hzBytecount = num[0] + num[1]*256;                  str = new byte[hzBytecount];                  fs.Read(str' 0' hzBytecount);                  string word = Encoding.Unicode.GetString(str);                  short unknown1 = BinFileHelper.ReadInt16(fs); //全部是10'肯定不是词频，具体是什么不知道                  int unknown2 = BinFileHelper.ReadInt32(fs); //每个字对应的数字不一样，不知道是不是词频                  pyAndWord.Add(new WordLibrary {Word = word' PinYin = wordPY.ToArray()' Rank = DefaultRank});                  CurrentStatus++;                  //接下来10个字节什么意思呢？暂时先忽略了                  var temp = new byte[6];                  for (int i = 0; i < 6; i++)                  {                      temp[i] = (byte) fs.ReadByte();                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int s = 0; s < samePYcount; s++) //同音词，使用前面相同的拼音              {                  num = new byte[2];                  fs.Read(num' 0' 2);                  int hzBytecount = num[0] + num[1]*256;                  str = new byte[hzBytecount];                  fs.Read(str' 0' hzBytecount);                  string word = Encoding.Unicode.GetString(str);                  short unknown1 = BinFileHelper.ReadInt16(fs); //全部是10'肯定不是词频，具体是什么不知道                  int unknown2 = BinFileHelper.ReadInt32(fs); //每个字对应的数字不一样，不知道是不是词频                  pyAndWord.Add(new WordLibrary {Word = word' PinYin = wordPY.ToArray()' Rank = DefaultRank});                  CurrentStatus++;                  //接下来10个字节什么意思呢？暂时先忽略了                  var temp = new byte[6];                  for (int i = 0; i < 6; i++)                  {                      temp[i] = (byte) fs.ReadByte();                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int s = 0; s < samePYcount; s++) //同音词，使用前面相同的拼音              {                  num = new byte[2];                  fs.Read(num' 0' 2);                  int hzBytecount = num[0] + num[1]*256;                  str = new byte[hzBytecount];                  fs.Read(str' 0' hzBytecount);                  string word = Encoding.Unicode.GetString(str);                  short unknown1 = BinFileHelper.ReadInt16(fs); //全部是10'肯定不是词频，具体是什么不知道                  int unknown2 = BinFileHelper.ReadInt32(fs); //每个字对应的数字不一样，不知道是不是词频                  pyAndWord.Add(new WordLibrary {Word = word' PinYin = wordPY.ToArray()' Rank = DefaultRank});                  CurrentStatus++;                  //接下来10个字节什么意思呢？暂时先忽略了                  var temp = new byte[6];                  for (int i = 0; i < 6; i++)                  {                      temp[i] = (byte) fs.ReadByte();                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,SougouPinyinScel,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\SougouPinyinScel.cs,ReadAPinyinWord,The following statement contains a magic number: for (int s = 0; s < samePYcount; s++) //同音词，使用前面相同的拼音              {                  num = new byte[2];                  fs.Read(num' 0' 2);                  int hzBytecount = num[0] + num[1]*256;                  str = new byte[hzBytecount];                  fs.Read(str' 0' hzBytecount);                  string word = Encoding.Unicode.GetString(str);                  short unknown1 = BinFileHelper.ReadInt16(fs); //全部是10'肯定不是词频，具体是什么不知道                  int unknown2 = BinFileHelper.ReadInt32(fs); //每个字对应的数字不一样，不知道是不是词频                  pyAndWord.Add(new WordLibrary {Word = word' PinYin = wordPY.ToArray()' Rank = DefaultRank});                  CurrentStatus++;                  //接下来10个字节什么意思呢？暂时先忽略了                  var temp = new byte[6];                  for (int i = 0; i < 6; i++)                  {                      temp[i] = (byte) fs.ReadByte();                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,YahooKeyKey,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\YahooKeyKey.cs,IsWordLine,The following statement contains a magic number: return line.Split('\t').Length == 4;
Magic Number,Studyzy.IMEWLConverter.IME,ZiGuangPinyin,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyin.cs,ImportText,The following statement contains a magic number: for (int i = 3; i < lines.Length; i++)              {                  string line = lines[i];                  CurrentStatus = i;                  wlList.AddWordLibraryList(ImportLine(line));              }
Magic Number,Studyzy.IMEWLConverter.IME,ZiGuangPinyinUwl,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Import,The following statement contains a magic number: for (int i = 0; i < segmentCount; i++)              {                  try                  {                      fs.Position = 0xC00 + 1024*i;                      var segment = new Segment(fs);                      pyAndWord.AddWordLibraryList(segment.WordLibraryList);                      CurrentStatus += segment.WordLibraryList.Count;                  }                  catch (Exception e)                  {                      Debug.WriteLine(e.Message);                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: int len = LenDic.IndexOf((byte) lenCode) + 2;
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: lenByte = len*4 + 4;
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: lenByte = len*4 + 4;
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: var rankB = new byte[4];
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  var b = (byte) stream.ReadByte();                  rankB[i] = b;              }
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: wl.Rank = (BitConverter.ToInt32(rankB' 0) - 1)/32;
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: int pyLen = Math.Min(8' len);
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: for (int i = 0; i < pyLen; i++)              {                  int smB = stream.ReadByte();                  int ymB = stream.ReadByte();                  int smIndex = smB & 31;                  //var ymPre = smB & 224;                  int ymIndex = (smB >> 5) + (ymB << 3);                  //拼音编码对应的拼音                  //wl.PinYin[i] = smIndex + "~" + ymIndex;                  try                  {                      wlPinYin[i] = Shengmu[smIndex] + Yunmu[ymIndex];                  }                  catch                  {  #if DEBUG                      wlPinYin[i] = smIndex + "~" + ymIndex;                      Debug.WriteLine(stream.Position);  #else                      return null;  #endif                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: for (int i = 0; i < pyLen; i++)              {                  int smB = stream.ReadByte();                  int ymB = stream.ReadByte();                  int smIndex = smB & 31;                  //var ymPre = smB & 224;                  int ymIndex = (smB >> 5) + (ymB << 3);                  //拼音编码对应的拼音                  //wl.PinYin[i] = smIndex + "~" + ymIndex;                  try                  {                      wlPinYin[i] = Shengmu[smIndex] + Yunmu[ymIndex];                  }                  catch                  {  #if DEBUG                      wlPinYin[i] = smIndex + "~" + ymIndex;                      Debug.WriteLine(stream.Position);  #else                      return null;  #endif                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: for (int i = 0; i < pyLen; i++)              {                  int smB = stream.ReadByte();                  int ymB = stream.ReadByte();                  int smIndex = smB & 31;                  //var ymPre = smB & 224;                  int ymIndex = (smB >> 5) + (ymB << 3);                  //拼音编码对应的拼音                  //wl.PinYin[i] = smIndex + "~" + ymIndex;                  try                  {                      wlPinYin[i] = Shengmu[smIndex] + Yunmu[ymIndex];                  }                  catch                  {  #if DEBUG                      wlPinYin[i] = smIndex + "~" + ymIndex;                      Debug.WriteLine(stream.Position);  #else                      return null;  #endif                  }              }
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: var hzB = new byte[len*2];
Magic Number,Studyzy.IMEWLConverter.IME,Segment,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\ZiGuangPinyinUwl.cs,Parse,The following statement contains a magic number: stream.Read(hzB' 0' len*2);
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0)              {                  // We can defer the modulo operation:                  // s1 maximally grows from 65521 to 65521 + 255 * 3800                  // s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31                  int n = 3800;                  if (n > count)                  {                      n = count;                  }                  count -= n;                  while (--n >= 0)                  {                      s1 = s1 + (uint) (buffer[offset++] & 0xff);                      s2 = s2 + s1;                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--count >= 0)              {                  crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);              }
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: int temp = (globalCrc >> 24) ^ value;
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: if (temp < 0)              {                  temp = 256 + temp;              }
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int) ((globalCrc << 8) ^ crc32Table[temp]));
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128)              {                  throw new ArgumentException("Buffer is too small"' "buffer");              }
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128)              {                  throw new ArgumentException("Buffer is too small"' "buffer");              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0))              {                  if ((path[0] == '\\') || (path[0] == '/'))                  {                      // UNC name ?                      if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/')))                      {                          int index = 2;                          int elements = 2;                            // Scan for two separate elements \\machine\share\restofpath                          while ((index <= path.Length) &&                                 (((path[index] != '\\') && (path[index] != '/')) || (--elements > 0)))                          {                              index++;                          }                            index++;                            if (index < path.Length)                          {                              result = path.Substring(index);                          }                          else                          {                              result = "";                          }                      }                  }                  else if ((path.Length > 1) && (path[1] == ':'))                  {                      int dropCount = 2;                      if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/')))                      {                          dropCount = 3;                      }                      result = result.Remove(0' dropCount);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)              {                  newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);                  newKeys[1] = newKeys[1] + (byte) newKeys[0];                  newKeys[1] = newKeys[1]*134775813 + 1;                  newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte) (newKeys[1] >> 24));              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)              {                  newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);                  newKeys[1] = newKeys[1] + (byte) newKeys[0];                  newKeys[1] = newKeys[1]*134775813 + 1;                  newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte) (newKeys[1] >> 24));              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)              {                  newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);                  newKeys[1] = newKeys[1] + (byte) newKeys[0];                  newKeys[1] = newKeys[1]*134775813 + 1;                  newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte) (newKeys[1] >> 24));              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)              {                  newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);                  newKeys[1] = newKeys[1] + (byte) newKeys[0];                  newKeys[1] = newKeys[1]*134775813 + 1;                  newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte) (newKeys[1] >> 24));              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: var result = new byte[12];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[1] = (byte) ((newKeys[0] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte) ((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte) ((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte) ((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte) ((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[4] = (byte) (newKeys[1] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte) ((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte) ((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte) ((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte) ((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte) ((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte) ((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte) (newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte) (newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte) ((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte) ((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte) ((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte) ((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte) ((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte) ((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte) ((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte) ((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte) ((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte) ((temp*(temp ^ 1)) >> 8);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12)              {                  throw new InvalidOperationException("Key length is not valid");              }
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint) ((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint) ((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint) ((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint) ((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint) ((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint) ((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint) ((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[1] = keys[1]*134775813 + 1;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte) (keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte) (keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte) (keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys[2] = 0;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESStream.cs,ZipAESStream,The following statement contains a magic number: _slideBuffer = new byte[1024];
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32) // 24 valid for AES but not supported by Winzip                  throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32) // 24 valid for AES but not supported by Winzip                  throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize/2)                  throw new Exception("Invalid salt len. Must be " + blockSize/2 + " for blocksize " + blockSize);
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize/2)                  throw new Exception("Invalid salt len. Must be " + blockSize/2 + " for blocksize " + blockSize);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION)              {                  level = 6;              }              else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION)              {                  level = 6;              }              else if (level < NO_COMPRESSION || level > BEST_COMPRESSION)              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE)              {                  // output header                  int header = (DEFLATED +                                ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;                  int level_flags = (level - 1) >> 1;                  if (level_flags < 0 || level_flags > 3)                  {                      level_flags = 3;                  }                  header |= level_flags << 6;                  if ((state & IS_SETDICT) != 0)                  {                      // Dictionary was set                      header |= DeflaterConstants.PRESET_DICT;                  }                  header += 31 - (header%31);                    pending.WriteShortMSB(header);                  if ((state & IS_SETDICT) != 0)                  {                      int chksum = engine.Adler;                      engine.ResetAdler();                      pending.WriteShortMSB(chksum >> 16);                      pending.WriteShortMSB(chksum & 0xffff);                  }                    state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;)              {                  int count = pending.Flush(output' offset' length);                  offset += count;                  totalOut += count;                  length -= count;                    if (length == 0 || state == FINISHED_STATE)                  {                      break;                  }                    if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0))                  {                      if (state == BUSY_STATE)                      {                          // We need more input now                          return origLength - length;                      }                      if (state == FLUSHING_STATE)                      {                          if (level != NO_COMPRESSION)                          {                              /* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */                              int neededbits = 8 + ((-pending.BitCount) & 7);                              while (neededbits > 0)                              {                                  /* write a static tree block consisting solely of  								 * an EOF:  								 */                                  pending.WriteBits(2' 10);                                  neededbits -= 10;                              }                          }                          state = BUSY_STATE;                      }                      else if (state == FINISHING_STATE)                      {                          pending.AlignToByte();                            // Compressed data is complete.  Write footer information if required.                          if (!noZlibHeaderOrFooter)                          {                              int adler = engine.Adler;                              pending.WriteShortMSB(adler >> 16);                              pending.WriteShortMSB(adler & 0xffff);                          }                          state = FINISHED_STATE;                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2*WSIZE];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9))              {                  throw new ArgumentOutOfRangeException("level");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < MIN_LOOKAHEAD && inputOff < inputEnd)              {                  int more = 2*WSIZE - lookahead - strstart;                    if (more > inputEnd - inputOff)                  {                      more = inputEnd - inputOff;                  }                    Array.Copy(inputBuf' inputOff' window' strstart + lookahead' more);                  adler.Update(inputBuf' inputOff' more);                    inputOff += more;                  totalIn += more;                  lookahead += more;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= goodLength)              {                  chainLength >>= 2;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do              {  #if DebugDeflation    				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )  				{  					throw new InvalidOperationException("no future");  				}  #endif                  if (window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1])                  {                      continue;                  }                    match = curMatch + 2;                  scan += 2;                    /* We check for insufficient lookahead only every 8th comparison;  				* the 256th check will be made at strstart + 258.  				*/                  while (                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend))                  {                      // Do nothing                  }                    if (scan > best_end)                  {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )  						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));  #endif                      matchStart = curMatch;                      best_end = scan;                      best_len = scan - strstart;                        if (best_len >= niceLength)                      {                          break;                      }                        scan_end1 = window[best_end - 1];                      scan_end = window[best_end];                  }                  scan = strstart;              } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do              {  #if DebugDeflation    				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )  				{  					throw new InvalidOperationException("no future");  				}  #endif                  if (window[curMatch + best_len] != scan_end ||                      window[curMatch + best_len - 1] != scan_end1 ||                      window[curMatch] != window[scan] ||                      window[curMatch + 1] != window[scan + 1])                  {                      continue;                  }                    match = curMatch + 2;                  scan += 2;                    /* We check for insufficient lookahead only every 8th comparison;  				* the 256th check will be made at strstart + 258.  				*/                  while (                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      window[++scan] == window[++match] &&                      (scan < strend))                  {                      // Do nothing                  }                    if (scan > best_end)                  {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )  						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));  #endif                      matchStart = curMatch;                      best_end = scan;                      best_len = scan - strstart;                        if (best_len >= niceLength)                      {                          break;                      }                        scan_end1 = window[best_end - 1];                      scan_end = window[best_end];                  }                  scan = strstart;              } while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      // We are flushing everything                      huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);                      blockStart = strstart;                      return false;                  }                    if (strstart > 2*WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */                      SlideWindow();                  }                    int hashHead;                  if (lookahead >= MIN_MATCH &&                      (hashHead = InsertString()) != 0 &&                      strategy != DeflateStrategy.HuffmanOnly &&                      strstart - hashHead <= MAX_DIST &&                      FindLongestMatch(hashHead))                  {                      // longestMatch sets matchStart and matchLen  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  						for (int i = 0 ; i < matchLen; i++) {  							if (window[strstart + i] != window[matchStart + i]) {  								throw new SharpZipBaseException("Match failure");  							}  						}  					}  #endif                        bool full = huffman.TallyDist(strstart - matchStart' matchLen);                        lookahead -= matchLen;                      if (matchLen <= max_lazy && lookahead >= MIN_MATCH)                      {                          while (--matchLen > 0)                          {                              ++strstart;                              InsertString();                          }                          ++strstart;                      }                      else                      {                          strstart += matchLen;                          if (lookahead >= MIN_MATCH - 1)                          {                              UpdateHash();                          }                      }                      matchLen = MIN_MATCH - 1;                      if (!full)                      {                          continue;                      }                  }                  else                  {                      // No match found                      huffman.TallyLit(window[strstart] & 0xff);                      ++strstart;                      --lookahead;                  }                    if (huffman.IsFull())                  {                      bool lastBlock = finish && (lookahead == 0);                      huffman.FlushBlock(window' blockStart' strstart - blockStart' lastBlock);                      blockStart = strstart;                      return !lastBlock;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                      huffman.FlushBlock(window' blockStart' strstart - blockStart'                          finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2*WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                      int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                          // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 &&                              (strategy == DeflateStrategy.Filtered ||                               (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart ++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                      huffman.FlushBlock(window' blockStart' strstart - blockStart'                          finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2*WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                      int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                          // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 &&                              (strategy == DeflateStrategy.Filtered ||                               (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart ++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush)              {                  if (lookahead == 0)                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = false;                        // We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                      huffman.FlushBlock(window' blockStart' strstart - blockStart'                          finish);                      blockStart = strstart;                      return false;                  }                    if (strstart >= 2*WSIZE - MIN_LOOKAHEAD)                  {                      /* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */                      SlideWindow();                  }                    int prevMatch = matchStart;                  int prevLen = matchLen;                  if (lookahead >= MIN_MATCH)                  {                      int hashHead = InsertString();                        if (strategy != DeflateStrategy.HuffmanOnly &&                          hashHead != 0 &&                          strstart - hashHead <= MAX_DIST &&                          FindLongestMatch(hashHead))                      {                          // longestMatch sets matchStart and matchLen                            // Discard match if too small and too far away                          if (matchLen <= 5 &&                              (strategy == DeflateStrategy.Filtered ||                               (matchLen == MIN_MATCH && strstart - matchStart > TooFar)))                          {                              matchLen = MIN_MATCH - 1;                          }                      }                  }                    // previous match was better                  if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen))                  {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif                      huffman.TallyDist(strstart - 1 - prevMatch' prevLen);                      prevLen -= 2;                      do                      {                          strstart++;                          lookahead--;                          if (lookahead >= MIN_MATCH)                          {                              InsertString();                          }                      } while (--prevLen > 0);                        strstart ++;                      lookahead--;                      prevAvailable = false;                      matchLen = MIN_MATCH - 1;                  }                  else                  {                      if (prevAvailable)                      {                          huffman.TallyLit(window[strstart - 1] & 0xff);                      }                      prevAvailable = true;                      strstart++;                      lookahead--;                  }                    if (huffman.IsFull())                  {                      int len = strstart - blockStart;                      if (prevAvailable)                      {                          len--;                      }                      bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);                      huffman.FlushBlock(window' blockStart' len' lastBlock);                      blockStart += len;                      return !lastBlock;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144)              {                  staticLCodes[i] = BitReverse((0x030 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256)              {                  staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);                  staticLLength[i++] = 9;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280)              {                  staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);                  staticLLength[i++] = 7;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM)              {                  staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);                  staticLLength[i++] = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++)              {                  staticDCodes[i] = BitReverse(i << 11);                  staticDLength[i] = 5;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++)              {                  staticDCodes[i] = BitReverse(i << 11);                  staticDLength[i] = 5;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree(this' DIST_NUM' 1' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(distTree.numCodes - 1' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++)              {                  pending.WriteBits(blTree.length[BL_ORDER[rank]]' 3);              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");                      //					}                        int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261)/4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc/2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						if (litlen > 32 && litlen < 127) {                      //							Console.Write("("+(char)litlen+"): ");                      //						} else {                      //							Console.Write("{"+litlen+"}: ");                      //						}                      //					}                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");                      //					}                        int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261)/4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc/2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						if (litlen > 32 && litlen < 127) {                      //							Console.Write("("+(char)litlen+"): ");                      //						} else {                      //							Console.Write("{"+litlen+"}: ");                      //						}                      //					}                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");                      //					}                        int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261)/4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc/2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						if (litlen > 32 && litlen < 127) {                      //							Console.Write("("+(char)litlen+"): ");                      //						} else {                      //							Console.Write("{"+litlen+"}: ");                      //						}                      //					}                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++)              {                  int litlen = l_buf[i] & 0xff;                  int dist = d_buf[i];                  if (dist-- != 0)                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");                      //					}                        int lc = Lcode(litlen);                      literalTree.WriteSymbol(lc);                        int bits = (lc - 261)/4;                      if (bits > 0 && bits <= 5)                      {                          pending.WriteBits(litlen & ((1 << bits) - 1)' bits);                      }                        int dc = Dcode(dist);                      distTree.WriteSymbol(dc);                        bits = dc/2 - 1;                      if (bits > 0)                      {                          pending.WriteBits(dist & ((1 << bits) - 1)' bits);                      }                  }                  else                  {                      //					if (DeflaterConstants.DEBUGGING) {                      //						if (litlen > 32 && litlen < 127) {                      //							Console.Write("("+(char)litlen+"): ");                      //						} else {                      //							Console.Write("{"+litlen+"}: ");                      //						}                      //					}                      literalTree.WriteSymbol(litlen);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int blTreeCodes = 4;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--)              {                  if (blTree.length[BL_ORDER[i]] > 0)                  {                      blTreeCodes = i + 1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes*3 + blTree.GetEncodedLength() +                            literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                            extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes*3 + blTree.GetEncodedLength() +                            literalTree.GetEncodedLength() + distTree.GetEncodedLength() +                            extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  // Store Block                    //				if (DeflaterConstants.DEBUGGING) {                  //					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len                  //					                  + " <= " + static_len);                  //				}                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  // Encode with static tree                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  // Encode with dynamic tree                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  // Store Block                    //				if (DeflaterConstants.DEBUGGING) {                  //					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len                  //					                  + " <= " + static_len);                  //				}                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  // Encode with static tree                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  // Encode with dynamic tree                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  // Store Block                    //				if (DeflaterConstants.DEBUGGING) {                  //					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len                  //					                  + " <= " + static_len);                  //				}                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  // Encode with static tree                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  // Encode with dynamic tree                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3)              {                  // Store Block                    //				if (DeflaterConstants.DEBUGGING) {                  //					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len                  //					                  + " <= " + static_len);                  //				}                  FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);              }              else if (opt_len == static_len)              {                  // Encode with static tree                  pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  literalTree.SetStaticCodes(staticLCodes' staticLLength);                  distTree.SetStaticCodes(staticDCodes' staticDLength);                  CompressBlock();                  Reset();              }              else              {                  // Encode with dynamic tree                  pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);                  SendAllTrees(blTreeCodes);                  CompressBlock();                  Reset();              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf[last_lit++] = (byte) (length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: int lc = Lcode(length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261)/4;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261)/4;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261)/4;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285)              {                  extra_bits += (lc - 261)/4;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4)              {                  extra_bits += dc/2 - 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4)              {                  extra_bits += dc/2 - 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |                              bit4Reverse[(toReverse >> 4) & 0xF] << 8 |                              bit4Reverse[(toReverse >> 8) & 0xF] << 4 |                              bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255)              {                  return 285;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255)              {                  return 285;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: int code = 257;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8)              {                  code += 4;                  length >>= 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8)              {                  code += 4;                  length >>= 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4)              {                  code += 2;                  distance >>= 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4)              {                  code += 2;                  distance >>= 1;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int bits = 0; bits < maxLength; bits++)                  {                      nextCode[bits] = code;                      code += bl_counts[bits] << (15 - bits);                        //					if (DeflaterConstants.DEBUGGING) {                      //						//Console.WriteLine("bits: " + ( bits + 1) + " count: " + bl_counts[bits]                      //						                  +" nextCode: "+code);                      //					}                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int i = 0; i < numCodes; i++)                  {                      int bits = length[i];                      if (bits > 0)                      {                          //						if (DeflaterConstants.DEBUGGING) {                          //								//Console.WriteLine("codes["+i+"] = rev(" + nextCode[bits-1]+")'                          //								                  +bits);                          //						}                            codes[i] = BitReverse(nextCode[bits - 1]);                          nextCode[bits - 1] += 1 << (16 - bits);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int n = 0; n < numSymbols; n++)                  {                      int freq = freqs[n];                      if (freq != 0)                      {                          // Insert n into heap                          int pos = heapLen++;                          int ppos;                          while (pos > 0 && freqs[heap[ppos = (pos - 1)/2]] > freq)                          {                              heap[pos] = heap[ppos];                              pos = ppos;                          }                          heap[pos] = n;                            maxCode = n;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2)                  {                      int node = maxCode < 2 ? ++maxCode : 0;                      heap[heapLen++] = node;                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2)                  {                      int node = maxCode < 2 ? ++maxCode : 0;                      heap[heapLen++] = node;                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: var childs = new int[4*heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: var childs = new int[4*heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: var values = new int[2*heapLen - 1];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2*i] = node;                      childs[2*i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2*i] = node;                      childs[2*i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++)                  {                      int node = heap[i];                      childs[2*i] = node;                      childs[2*i + 1] = -1;                      values[i] = freqs[node] << 8;                      heap[i] = i;                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do                  {                      int first = heap[0];                      int last = heap[--heapLen];                        // Propagate the hole to the leafs of the heap                      int ppos = 0;                      int path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = path*2 + 1;                      }                        /* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/                      int lastVal = values[last];                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                          int second = heap[0];                        // Create a new node father of first and second                      last = numNodes++;                      childs[2*last] = first;                      childs[2*last + 1] = second;                      int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);                      values[last] = lastVal = values[first] + values[second] - mindepth + 1;                        // Again' propagate the hole to the leafs                      ppos = 0;                      path = 1;                        while (path < heapLen)                      {                          if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]])                          {                              path++;                          }                            heap[ppos] = heap[path];                          ppos = path;                          path = ppos*2 + 1;                      }                        // Now propagate the new element down along path                      while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal)                      {                          heap[path] = heap[ppos];                      }                      heap[path] = last;                  } while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: if (heap[0] != childs.Length/2 - 1)                  {                      throw new SharpZipBaseException("Heap invariant violated");                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short) count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short) count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short) count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short) count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.freqs[nextlen]++;                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          blTree.freqs[curlen] += (short) count;                      }                      else if (curlen != 0)                      {                          blTree.freqs[REP_3_6]++;                      }                      else if (count <= 10)                      {                          blTree.freqs[REP_3_10]++;                      }                      else                      {                          blTree.freqs[REP_11_138]++;                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes)                  {                      count = 1;                      int nextlen = length[i];                      if (nextlen == 0)                      {                          max_count = 138;                          min_count = 3;                      }                      else                      {                          max_count = 6;                          min_count = 3;                          if (curlen != nextlen)                          {                              blTree.WriteSymbol(nextlen);                              count = 0;                          }                      }                      curlen = nextlen;                      i++;                        while (i < numCodes && curlen == length[i])                      {                          i++;                          if (++count >= max_count)                          {                              break;                          }                      }                        if (count < min_count)                      {                          while (count-- > 0)                          {                              blTree.WriteSymbol(curlen);                          }                      }                      else if (curlen != 0)                      {                          blTree.WriteSymbol(REP_3_6);                          dh.pending.WriteBits(count - 3' 2);                      }                      else if (count <= 10)                      {                          blTree.WriteSymbol(REP_3_10);                          dh.pending.WriteBits(count - 3' 3);                      }                      else                      {                          blTree.WriteSymbol(REP_11_138);                          dh.pending.WriteBits(count - 11' 7);                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numNodes = childs.Length/2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numLeafs = (numNodes + 1)/2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2*i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2*i]] = lengths[childs[2*i + 1]] = bitLength;                      }                      else                      {                          // A leaf node                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          length[childs[2*i]] = (byte) lengths[i];                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2*i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2*i]] = lengths[childs[2*i + 1]] = bitLength;                      }                      else                      {                          // A leaf node                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          length[childs[2*i]] = (byte) lengths[i];                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2*i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2*i]] = lengths[childs[2*i + 1]] = bitLength;                      }                      else                      {                          // A leaf node                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          length[childs[2*i]] = (byte) lengths[i];                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--)                  {                      if (childs[2*i + 1] != -1)                      {                          int bitLength = lengths[i] + 1;                          if (bitLength > maxLength)                          {                              bitLength = maxLength;                              overflow++;                          }                          lengths[childs[2*i]] = lengths[childs[2*i + 1]] = bitLength;                      }                      else                      {                          // A leaf node                          int bitLength = lengths[i];                          bl_counts[bitLength - 1]++;                          length[childs[2*i]] = (byte) lengths[i];                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: bl_counts[maxLength - 2] -= overflow;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int nodePtr = 2*numLeafs;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int bits = maxLength; bits != 0; bits--)                  {                      int n = bl_counts[bits - 1];                      while (n > 0)                      {                          int childPtr = 2*childs[nodePtr++];                          if (childs[childPtr + 1] == -1)                          {                              // We found another leaf                              length[childs[childPtr]] = (byte) bits;                              n--;                          }                      }                  }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header%31 != 0)              {                  throw new SharpZipBaseException("Header checksum illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8))              {                  throw new SharpZipBaseException("Compression Method unknown");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0)              {                  // Dictionary flag?                  mode = DECODE_BLOCKS;              }              else              {                  mode = DECODE_DICT;                  neededBits = 32;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0)              {                  int dictByte = input.PeekBits(8);                  if (dictByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | dictByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              // symbol == 256: end of block                              distTree = null;                              litlenTree = null;                              mode = DECODE_BLOCKS;                              return true;                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new SharpZipBaseException("Inflater unknown mode");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              // symbol == 256: end of block                              distTree = null;                              litlenTree = null;                              mode = DECODE_BLOCKS;                              return true;                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new SharpZipBaseException("Inflater unknown mode");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              // symbol == 256: end of block                              distTree = null;                              litlenTree = null;                              mode = DECODE_BLOCKS;                              return true;                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new SharpZipBaseException("Inflater unknown mode");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              // symbol == 256: end of block                              distTree = null;                              litlenTree = null;                              mode = DECODE_BLOCKS;                              return true;                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new SharpZipBaseException("Inflater unknown mode");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)              {                  int symbol;                  switch (mode)                  {                      case DECODE_HUFFMAN:                          // This is the inner loop so it is optimized a bit                          while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)                          {                              outputWindow.Write(symbol);                              if (--free < 258)                              {                                  return true;                              }                          }                            if (symbol < 257)                          {                              if (symbol < 0)                              {                                  return false;                              }                              // symbol == 256: end of block                              distTree = null;                              litlenTree = null;                              mode = DECODE_BLOCKS;                              return true;                          }                            try                          {                              repLength = CPLENS[symbol - 257];                              neededBits = CPLEXT[symbol - 257];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep length code");                          }                          goto case DECODE_HUFFMAN_LENBITS; // fall through                        case DECODE_HUFFMAN_LENBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_LENBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repLength += i;                          }                          mode = DECODE_HUFFMAN_DIST;                          goto case DECODE_HUFFMAN_DIST; // fall through                        case DECODE_HUFFMAN_DIST:                          symbol = distTree.GetSymbol(input);                          if (symbol < 0)                          {                              return false;                          }                            try                          {                              repDist = CPDIST[symbol];                              neededBits = CPDEXT[symbol];                          }                          catch (Exception)                          {                              throw new SharpZipBaseException("Illegal rep dist code");                          }                            goto case DECODE_HUFFMAN_DISTBITS; // fall through                        case DECODE_HUFFMAN_DISTBITS:                          if (neededBits > 0)                          {                              mode = DECODE_HUFFMAN_DISTBITS;                              int i = input.PeekBits(neededBits);                              if (i < 0)                              {                                  return false;                              }                              input.DropBits(neededBits);                              repDist += i;                          }                            outputWindow.Repeat(repLength' repDist);                          free -= repLength;                          mode = DECODE_HUFFMAN;                          break;                        default:                          throw new SharpZipBaseException("Inflater unknown mode");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0)              {                  int chkByte = input.PeekBits(8);                  if (chkByte < 0)                  {                      return false;                  }                  input.DropBits(8);                  readAdler = (readAdler << 8) | chkByte;                  neededBits -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode)              {                  case DECODE_HEADER:                      return DecodeHeader();                    case DECODE_DICT:                      return DecodeDict();                    case DECODE_CHKSUM:                      return DecodeChksum();                    case DECODE_BLOCKS:                      if (isLastBlock)                      {                          if (noHeader)                          {                              mode = FINISHED;                              return false;                          }                          input.SkipToByteBoundary();                          neededBits = 32;                          mode = DECODE_CHKSUM;                          return true;                      }                        int type = input.PeekBits(3);                      if (type < 0)                      {                          return false;                      }                      input.DropBits(3);                        if ((type & 1) != 0)                      {                          isLastBlock = true;                      }                      switch (type >> 1)                      {                          case DeflaterConstants.STORED_BLOCK:                              input.SkipToByteBoundary();                              mode = DECODE_STORED_LEN1;                              break;                          case DeflaterConstants.STATIC_TREES:                              litlenTree = InflaterHuffmanTree.defLitLenTree;                              distTree = InflaterHuffmanTree.defDistTree;                              mode = DECODE_HUFFMAN;                              break;                          case DeflaterConstants.DYN_TREES:                              dynHeader = new InflaterDynHeader();                              mode = DECODE_DYN_HEADER;                              break;                          default:                              throw new SharpZipBaseException("Unknown block type " + type);                      }                      return true;                    case DECODE_STORED_LEN1:                  {                      if ((uncomprLen = input.PeekBits(16)) < 0)                      {                          return false;                      }                      input.DropBits(16);                      mode = DECODE_STORED_LEN2;                  }                      goto case DECODE_STORED_LEN2; // fall through                    case DECODE_STORED_LEN2:                  {                      int nlen = input.PeekBits(16);                      if (nlen < 0)                      {                          return false;                      }                      input.DropBits(16);                      if (nlen != (uncomprLen ^ 0xffff))                      {                          throw new SharpZipBaseException("broken uncompressed block");                      }                      mode = DECODE_STORED;                  }                      goto case DECODE_STORED; // fall through                    case DECODE_STORED:                  {                      int more = outputWindow.CopyStored(input' uncomprLen);                      uncomprLen -= more;                      if (uncomprLen == 0)                      {                          mode = DECODE_BLOCKS;                          return true;                      }                      return !input.IsNeedingInput;                  }                    case DECODE_DYN_HEADER:                      if (!dynHeader.Decode(input))                      {                          return false;                      }                        litlenTree = dynHeader.BuildLitLenTree();                      distTree = dynHeader.BuildDistTree();                      mode = DECODE_HUFFMAN;                      goto case DECODE_HUFFMAN; // fall through                    case DECODE_HUFFMAN:                  case DECODE_HUFFMAN_LENBITS:                  case DECODE_HUFFMAN_DIST:                  case DECODE_HUFFMAN_DISTBITS:                      return DecodeHuffman();                    case FINISHED:                      return false;                    default:                      throw new SharpZipBaseException("Inflater.Decode unknown mode");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:              for (;;)              {                  switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try              {                  var codeLengths = new byte[288];                  int i = 0;                  while (i < 144)                  {                      codeLengths[i++] = 8;                  }                  while (i < 256)                  {                      codeLengths[i++] = 9;                  }                  while (i < 280)                  {                      codeLengths[i++] = 7;                  }                  while (i < 288)                  {                      codeLengths[i++] = 8;                  }                  defLitLenTree = new InflaterHuffmanTree(codeLengths);                    codeLengths = new byte[32];                  i = 0;                  while (i < 32)                  {                      codeLengths[i++] = 5;                  }                  defDistTree = new InflaterHuffmanTree(codeLengths);              }              catch (Exception)              {                  throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      /* We need an extra table for bit lengths >= 10. */                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      /* We need an extra table for bit lengths >= 10. */                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++)              {                  nextCode[bits] = code;                  code += blCount[bits] << (16 - bits);                  if (bits >= 10)                  {                      /* We need an extra table for bit lengths >= 10. */                      int start = nextCode[bits] & 0x1ff80;                      int end = code & 0x1ff80;                      treeSize += (end - start) >> (16 - bits);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--)              {                  int end = code & 0x1ff80;                  code -= blCount[bits] << (16 - bits);                  int start = code & 0x1ff80;                  for (int i = start; i < end; i += 1 << 7)                  {                      tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);                      treePtr += 1 << (bits - 9);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++)              {                  int bits = codeLengths[i];                  if (bits == 0)                  {                      continue;                  }                  code = nextCode[bits];                  int revcode = DeflaterHuffman.BitReverse(code);                  if (bits <= 9)                  {                      do                      {                          tree[revcode] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < 512);                  }                  else                  {                      int subTree = tree[revcode & 511];                      int treeLen = 1 << (subTree & 15);                      subTree = -(subTree >> 4);                      do                      {                          tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);                          revcode += 1 << bits;                      } while (revcode < treeLen);                  }                  nextCode[bits] = code + (1 << (16 - bits));              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0)              {                  if ((symbol = tree[lookahead]) >= 0)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  int subtree = -(symbol >> 4);                  int bitlen = symbol & 15;                  if ((lookahead = input.PeekBits(bitlen)) >= 0)                  {                      symbol = tree[subtree | (lookahead >> 9)];                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      int bits = input.AvailableBits;                      lookahead = input.PeekBits(bits);                      symbol = tree[subtree | (lookahead >> 9)];                      if ((symbol & 15) <= bits)                      {                          input.DropBits(symbol & 15);                          return symbol >> 4;                      }                      else                      {                          return -1;                      }                  }              }              else              {                  int bits = input.AvailableBits;                  lookahead = input.PeekBits(bits);                  symbol = tree[lookahead];                  if (symbol >= 0 && (symbol & 15) <= bits)                  {                      input.DropBits(symbol & 15);                      return symbol >> 4;                  }                  else                  {                      return -1;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 24));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)              {                  buffer_[end++] = unchecked((byte) bits);                  if (bitCount > 8)                  {                      buffer_[end++] = unchecked((byte) (bits >> 8));                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)              {                  buffer_[end++] = unchecked((byte) bits);                  if (bitCount > 8)                  {                      buffer_[end++] = unchecked((byte) (bits >> 8));                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte) bits);                  buffer_[end++] = unchecked((byte) (bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte) bits);                  buffer_[end++] = unchecked((byte) (bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte) bits);                  buffer_[end++] = unchecked((byte) (bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16)              {                  buffer_[end++] = unchecked((byte) bits);                  buffer_[end++] = unchecked((byte) (bits >> 8));                  bits >>= 16;                  bitCount -= 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (s >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte) bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte) bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8)              {                  buffer_[end++] = unchecked((byte) bits);                  bits >>= 8;                  bitCount -= 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512)              {                  throw new ArgumentOutOfRangeException("bufferSize");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\DeflaterOutputStream.cs,InitializeAESPassword,The following statement contains a magic number: int blockSize = entry.AESKeySize/8;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024)              {                  bufferSize = 1024;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024)              {                  bufferSize = 1024;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte() | (ReadLeByte() << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort() | (ReadLeShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint) ReadLeInt() | ((long) ReadLeInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: int length = 2048;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount)              {                  if (windowStart_ == windowEnd_)                  {                      return -1; // ok                  }                  buffer_ |= (uint) ((window_[windowStart_++] & 0xff |                                      (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);                  bitsInBuffer_ += 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount)              {                  if (windowStart_ == windowEnd_)                  {                      return -1; // ok                  }                  buffer_ |= (uint) ((window_[windowStart_++] & 0xff |                                      (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);                  bitsInBuffer_ += 16;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0)              {                  // bits_in_buffer may only be 0 or a multiple of 8                  throw new InvalidOperationException("Bit buffer is not byte aligned!");              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0))              {                  output[offset++] = (byte) buffer_;                  buffer_ >>= 8;                  bitsInBuffer_ -= 8;                  length--;                  count++;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0))              {                  output[offset++] = (byte) buffer_;                  buffer_ >>= 8;                  bitsInBuffer_ -= 8;                  length--;                  count++;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0)              {                  // We always want an even number of bytes in input' see peekBits                  buffer_ = (uint) (window_[windowStart_++] & 0xff);                  bitsInBuffer_ = 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0)              {                  // We always want an even number of bytes in input' see PeekBits                  buffer_ |= (uint) ((buffer[offset++] & 0xff) << bitsInBuffer_);                  bitsInBuffer_ += 8;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if (buffer_ == null)              {                  buffer_ = new byte[4096];              }
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (proceed)              {                  if (events_ != null)                  {                      continueRunning_ = events_.OnProcessFile(entry.Name);                  }                    if (continueRunning_)                  {                      try                      {                          using (FileStream outputStream = File.Create(targetName))                          {                              if (buffer_ == null)                              {                                  buffer_ = new byte[4096];                              }                              if ((events_ != null) && (events_.Progress != null))                              {                                  StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_'                                      events_.Progress' events_.ProgressInterval' this' entry.Name'                                      entry.Size);                              }                              else                              {                                  StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_);                              }                                if (events_ != null)                              {                                  continueRunning_ = events_.OnCompletedFile(entry.Name);                              }                          }    #if !NETCF_1_0 && !NETCF_2_0                          if (restoreDateTimeOnExtract_)                          {                              File.SetLastWriteTime(targetName' entry.DateTime);                          }                            if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1))                          {                              var fileAttributes = (FileAttributes) entry.ExternalFileAttributes;                              // TODO: FastZip - Setting of other file attributes on extraction is a little trickier.                              fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly |                                                 FileAttributes.Hidden);                              File.SetAttributes(targetName' fileAttributes);                          }  #endif                      }                      catch (Exception ex)                      {                          if (events_ != null)                          {                              continueRunning_ = events_.OnFileFailure(targetName' ex);                          }                          else                          {                              continueRunning_ = false;                              throw;                          }                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: int howMany = invalidPathChars.Length + 3;
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 2] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 3] = ':';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10))              {                  throw new ArgumentOutOfRangeException("versionRequiredToExtract");              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(0x0001))              {                  // Version required to extract is ignored here as some archivers dont set it correctly                  // in theory it should be version 45 or higher                    // The recorded size will change but remember that this is zip64.                  forceZip64_ = true;                    if (extraData.ValueLength < 4)                  {                      throw new ZipException("Extra data extended Zip64 information length is invalid");                  }                    if (localHeader || (size == uint.MaxValue))                  {                      size = (ulong) extraData.ReadLong();                  }                    if (localHeader || (compressedSize == uint.MaxValue))                  {                      compressedSize = (ulong) extraData.ReadLong();                  }                    if (!localHeader && (offset == uint.MaxValue))                  {                      offset = extraData.ReadLong();                  }                    // Disk number on which file starts is ignored              }              else              {                  if (                      ((versionToExtract & 0xff) >= ZipConstants.VersionZip64) &&                      ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))                      )                  {                      throw new ZipException("Zip64 Extended information required but is missing.");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(10))              {                  // No room for any tags.                  if (extraData.ValueLength < 4)                  {                      throw new ZipException("NTFS Extra data invalid");                  }                    extraData.ReadInt(); // Reserved                    while (extraData.UnreadCount >= 4)                  {                      int ntfsTag = extraData.ReadShort();                      int ntfsLength = extraData.ReadShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModification = extraData.ReadLong();                              long lastAccess = extraData.ReadLong();                              long createTime = extraData.ReadLong();                                DateTime = DateTime.FromFileTime(lastModification);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      extraData.Skip(ntfsLength);                  }              }              else if (extraData.Find(0x5455))              {                  int length = extraData.ValueLength;                  int flags = extraData.ReadByte();                    // Can include other times but these are ignored.  Length of data should                  // actually be 1 + 4 * no of bits in flags.                  if (((flags & 1) != 0) && (length >= 5))                  {                      int iTime = extraData.ReadInt();                        DateTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                  new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find(0x9901))              {                  // Set version and flag for Zipfile.CreateAndInitDecryptionStream                  versionToExtract = ZipConstants.VERSION_AES; // Ver 5.1 = AES see "Version" getter                  // Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream                  Flags = Flags | (int) GeneralBitFlags.StrongEncryption;                  //                  // Unpack AES extra data field see http://www.winzip.com/aes_info.htm                  int length = extraData.ValueLength; // Data size currently 7                  if (length < 7)                      throw new ZipException("AES Extra Data Length " + length + " invalid.");                  int ver = extraData.ReadShort(); // Version number (1=AE-1 2=AE-2)                  int vendorId = extraData.ReadShort(); // 2-character vendor ID 0x4541 = "AE"                  int encrStrength = extraData.ReadByte(); // encryption strength 1 = 128 2 = 192 3 = 256                  int actualCompress = extraData.ReadShort(); // The actual compression method used to compress the file                  _aesVer = ver;                  _aesEncryptionStrength = encrStrength;                  method = (CompressionMethod) actualCompress;              }              else                  throw new ZipException("AES Extra Data missing");
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (var ms = new MemoryStream(data' index' count' false))              using (var helperStream = new ZipHelperStream(ms))              {                  // bit 0           if set' modification time is present                  // bit 1           if set' access time is present                  // bit 2           if set' creation time is present                    _flags = (Flags) helperStream.ReadByte();                  if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))                  {                      int iTime = helperStream.ReadLEInt();                        _modificationTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                           new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.AccessTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _lastAccessTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                         new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.CreateTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _createTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                     new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (var ms = new MemoryStream(data' index' count' false))              using (var helperStream = new ZipHelperStream(ms))              {                  // bit 0           if set' modification time is present                  // bit 1           if set' access time is present                  // bit 2           if set' creation time is present                    _flags = (Flags) helperStream.ReadByte();                  if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))                  {                      int iTime = helperStream.ReadLEInt();                        _modificationTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                           new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.AccessTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _lastAccessTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                         new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.CreateTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _createTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                     new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (var ms = new MemoryStream(data' index' count' false))              using (var helperStream = new ZipHelperStream(ms))              {                  // bit 0           if set' modification time is present                  // bit 1           if set' access time is present                  // bit 2           if set' creation time is present                    _flags = (Flags) helperStream.ReadByte();                  if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))                  {                      int iTime = helperStream.ReadLEInt();                        _modificationTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                           new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.AccessTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _lastAccessTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                         new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.CreateTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _createTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                     new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (var ms = new MemoryStream(data' index' count' false))              using (var helperStream = new ZipHelperStream(ms))              {                  // bit 0           if set' modification time is present                  // bit 1           if set' access time is present                  // bit 2           if set' creation time is present                    _flags = (Flags) helperStream.ReadByte();                  if (((_flags & Flags.ModificationTime) != 0) && (count >= 5))                  {                      int iTime = helperStream.ReadLEInt();                        _modificationTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                           new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.AccessTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _lastAccessTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                         new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }                    if ((_flags & Flags.CreateTime) != 0)                  {                      int iTime = helperStream.ReadLEInt();                        _createTime = (new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +                                     new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var helperStream = new ZipHelperStream(ms))              {                  helperStream.IsStreamOwner = false;                  helperStream.WriteByte((byte) _flags); // Flags                  if ((_flags & Flags.ModificationTime) != 0)                  {                      TimeSpan span = _modificationTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.AccessTime) != 0)                  {                      TimeSpan span = _lastAccessTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.CreateTime) != 0)                  {                      TimeSpan span = _createTime.ToUniversalTime() - new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  return ms.ToArray();              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var helperStream = new ZipHelperStream(ms))              {                  helperStream.IsStreamOwner = false;                  helperStream.WriteByte((byte) _flags); // Flags                  if ((_flags & Flags.ModificationTime) != 0)                  {                      TimeSpan span = _modificationTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.AccessTime) != 0)                  {                      TimeSpan span = _lastAccessTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.CreateTime) != 0)                  {                      TimeSpan span = _createTime.ToUniversalTime() - new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  return ms.ToArray();              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var helperStream = new ZipHelperStream(ms))              {                  helperStream.IsStreamOwner = false;                  helperStream.WriteByte((byte) _flags); // Flags                  if ((_flags & Flags.ModificationTime) != 0)                  {                      TimeSpan span = _modificationTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.AccessTime) != 0)                  {                      TimeSpan span = _lastAccessTime.ToUniversalTime() -                                      new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  if ((_flags & Flags.CreateTime) != 0)                  {                      TimeSpan span = _createTime.ToUniversalTime() - new DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();                      var seconds = (int) span.TotalSeconds;                      helperStream.WriteLEInt(seconds);                  }                  return ms.ToArray();              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||                      (value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (var ms = new MemoryStream(data' index' count' false))              using (var helperStream = new ZipHelperStream(ms))              {                  helperStream.ReadLEInt(); // Reserved                  while (helperStream.Position < helperStream.Length)                  {                      int ntfsTag = helperStream.ReadLEShort();                      int ntfsLength = helperStream.ReadLEShort();                      if (ntfsTag == 1)                      {                          if (ntfsLength >= 24)                          {                              long lastModificationTicks = helperStream.ReadLELong();                              _lastModificationTime = DateTime.FromFileTime(lastModificationTicks);                                long lastAccessTicks = helperStream.ReadLELong();                              _lastAccessTime = DateTime.FromFileTime(lastAccessTicks);                                long createTimeTicks = helperStream.ReadLELong();                              _createTime = DateTime.FromFileTime(createTimeTicks);                          }                          break;                      }                      // An unknown NTFS tag so simply skip it.                      helperStream.Seek(ntfsLength' SeekOrigin.Current);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var helperStream = new ZipHelperStream(ms))              {                  helperStream.IsStreamOwner = false;                  helperStream.WriteLEInt(0); // Reserved                  helperStream.WriteLEShort(1); // Tag                  helperStream.WriteLEShort(24); // Length = 3 x 8.                  helperStream.WriteLELong(_lastModificationTime.ToFileTime());                  helperStream.WriteLELong(_lastAccessTime.ToFileTime());                  helperStream.WriteLELong(_createTime.ToFileTime());                  return ms.ToArray();              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3))              {                  localTag = ReadShortInternal();                  localLength = ReadShortInternal();                  if (localTag != headerID)                  {                      _index += localLength;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: int newLength = _data.Length + addLength + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find(headerID))              {                  newLength -= (ValueLength + 4);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked              {                  _newEntry.WriteByte((byte) toAdd);                  _newEntry.WriteByte((byte) (toAdd >> 8));              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked              {                  AddLeShort((short) toAdd);                  AddLeShort((short) (toAdd >> 16));              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked              {                  AddLeInt((int) (toAdd & 0xffffffff));                  AddLeInt((int) (toAdd >> 32));              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID))              {                  result = true;                  int trueStart = _readValueStart - 4;                    var newData = new byte[_data.Length - (ValueLength + 4)];                  Array.Copy(_data' 0' newData' 0' trueStart);                    int trueEnd = trueStart + ValueLength + 4;                  Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);                  _data = newData;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID))              {                  result = true;                  int trueStart = _readValueStart - 4;                    var newData = new byte[_data.Length - (ValueLength + 4)];                  Array.Copy(_data' 0' newData' 0' trueStart);                    int trueEnd = trueStart + ValueLength + 4;                  Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);                  _data = newData;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID))              {                  result = true;                  int trueStart = _readValueStart - 4;                    var newData = new byte[_data.Length - (ValueLength + 4)];                  Array.Copy(_data' 0' newData' 0' trueStart);                    int trueEnd = trueStart + ValueLength + 4;                  Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);                  _data = newData;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck(8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt() & 0xffffffff) | (((long) ReadInt()) << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck(4);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +                           (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +                           (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +                           (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +                           (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +                           (_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck(2);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) ||                  (_readValueStart < 4))              {                  throw new ZipException("Find must be called before calling a Read method");              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4)              {                  throw new ZipException("Cannot read before start of tag");              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2)              {                  throw new ZipException("End of extra data");              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data[index + 1] = (byte) (source >> 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try              {                  int entryIndex = 0;                    while (testing && (entryIndex < Count))                  {                      if (resultHandler != null)                      {                          status.SetEntry(this[entryIndex]);                          status.SetOperation(TestOperation.EntryHeader);                          resultHandler(status' null);                      }                        try                      {                          TestLocalHeader(this[entryIndex]' test);                      }                      catch (ZipException ex)                      {                          status.AddError();                            if (resultHandler != null)                          {                              resultHandler(status'                                  string.Format("Exception during test - '{0}'"' ex.Message));                          }                            if (strategy == TestStrategy.FindFirstError)                          {                              testing = false;                          }                      }                        if (testing && testData && this[entryIndex].IsFile)                      {                          if (resultHandler != null)                          {                              status.SetOperation(TestOperation.EntryData);                              resultHandler(status' null);                          }                            var crc = new Crc32();                            using (Stream entryStream = GetInputStream(this[entryIndex]))                          {                              var buffer = new byte[4096];                              long totalBytes = 0;                              int bytesRead;                              while ((bytesRead = entryStream.Read(buffer' 0' buffer.Length)) > 0)                              {                                  crc.Update(buffer' 0' bytesRead);                                    if (resultHandler != null)                                  {                                      totalBytes += bytesRead;                                      status.SetBytesTested(totalBytes);                                      resultHandler(status' null);                                  }                              }                          }                            if (this[entryIndex].Crc != crc.Value)                          {                              status.AddError();                                if (resultHandler != null)                              {                                  resultHandler(status' "CRC mismatch");                              }                                if (strategy == TestStrategy.FindFirstError)                              {                                  testing = false;                              }                          }                            if ((this[entryIndex].Flags & (int) GeneralBitFlags.Descriptor) != 0)                          {                              var helper = new ZipHelperStream(baseStream_);                              var data = new DescriptorData();                              helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64' data);                              if (this[entryIndex].Crc != data.Crc)                              {                                  status.AddError();                              }                                if (this[entryIndex].CompressedSize != data.CompressedSize)                              {                                  status.AddError();                              }                                if (this[entryIndex].Size != data.Size)                              {                                  status.AddError();                              }                          }                      }                        if (resultHandler != null)                      {                          status.SetOperation(TestOperation.EntryComplete);                          resultHandler(status' null);                      }                        entryIndex += 1;                  }                    if (resultHandler != null)                  {                      status.SetOperation(TestOperation.MiscellaneousTests);                      resultHandler(status' null);                  }                    // TODO: the 'Corrina Johns' test where local headers are missing from                  // the central directory.  They are therefore invisible to many archivers.              }              catch (Exception ex)              {                  status.AddError();                    if (resultHandler != null)                  {                      resultHandler(status' string.Format("Exception during test - '{0}'"' ex.Message));                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_)              {                  bool testHeader = (tests & HeaderTest.Header) != 0;                  bool testData = (tests & HeaderTest.Extract) != 0;                    baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);                  if ((int) ReadLEUint() != ZipConstants.LocalHeaderSignature)                  {                      throw new ZipException(string.Format("Wrong local header signature @{0:X}"'                          offsetOfFirstEntry + entry.Offset));                  }                    var extractVersion = (short) ReadLEUshort();                  var localFlags = (short) ReadLEUshort();                  var compressionMethod = (short) ReadLEUshort();                  var fileTime = (short) ReadLEUshort();                  var fileDate = (short) ReadLEUshort();                  uint crcValue = ReadLEUint();                  long compressedSize = ReadLEUint();                  long size = ReadLEUint();                  int storedNameLength = ReadLEUshort();                  int extraDataLength = ReadLEUshort();                    var nameData = new byte[storedNameLength];                  StreamUtils.ReadFully(baseStream_' nameData);                    var extraData = new byte[extraDataLength];                  StreamUtils.ReadFully(baseStream_' extraData);                    var localExtraData = new ZipExtraData(extraData);                    // Extra data / zip64 checks                  if (localExtraData.Find(1))                  {                      // 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64                      // and size or compressedSize = MaxValue' due to rogue creators.                        size = localExtraData.ReadLong();                      compressedSize = localExtraData.ReadLong();                        if ((localFlags & (int) GeneralBitFlags.Descriptor) != 0)                      {                          // These may be valid if patched later                          if ((size != -1) && (size != entry.Size))                          {                              throw new ZipException("Size invalid for descriptor");                          }                            if ((compressedSize != -1) && (compressedSize != entry.CompressedSize))                          {                              throw new ZipException("Compressed size invalid for descriptor");                          }                      }                  }                  else                  {                      // No zip64 extra data but entry requires it.                      if ((extractVersion >= ZipConstants.VersionZip64) &&                          (((uint) size == uint.MaxValue) || ((uint) compressedSize == uint.MaxValue)))                      {                          throw new ZipException("Required Zip64 extended information missing");                      }                  }                    if (testData)                  {                      if (entry.IsFile)                      {                          if (!entry.IsCompressionMethodSupported())                          {                              throw new ZipException("Compression method not supported");                          }                            if ((extractVersion > ZipConstants.VersionMadeBy)                              || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)))                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry not supported ({0})"'                                      extractVersion));                          }                            if ((localFlags &                               (int)                                   (GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption |                                    GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0)                          {                              throw new ZipException(                                  "The library does not support the zip version required to extract this entry");                          }                      }                  }                    if (testHeader)                  {                      if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..                          (extractVersion != 10) &&                          (extractVersion != 11) &&                          (extractVersion != 20) &&                          (extractVersion != 21) &&                          (extractVersion != 25) &&                          (extractVersion != 27) &&                          (extractVersion != 45) &&                          (extractVersion != 46) &&                          (extractVersion != 50) &&                          (extractVersion != 51) &&                          (extractVersion != 52) &&                          (extractVersion != 61) &&                          (extractVersion != 62) &&                          (extractVersion != 63)                          )                      {                          throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"'                              extractVersion));                      }                        // Local entry flags dont have reserved bit set on.                      if ((localFlags &                           (int)                               (GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 |                                GeneralBitFlags.ReservedPkware15)) != 0)                      {                          throw new ZipException("Reserved bit flags cannot be set.");                      }                        // Encryption requires extract version >= 20                      if (((localFlags & (int) GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20))                      {                          throw new ZipException(                              string.Format("Version required to extract this entry is too low for encryption ({0})"'                                  extractVersion));                      }                        // Strong encryption requires encryption flag to be set and extract version >= 50.                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if ((localFlags & (int) GeneralBitFlags.Encrypted) == 0)                          {                              throw new ZipException("Strong encryption flag set but encryption flag is not set");                          }                            if (extractVersion < 50)                          {                              throw new ZipException(                                  string.Format("Version required to extract this entry is too low for encryption ({0})"'                                      extractVersion));                          }                      }                        // Patched entries require extract version >= 27                      if (((localFlags & (int) GeneralBitFlags.Patched) != 0) && (extractVersion < 27))                      {                          throw new ZipException(string.Format("Patched data requires higher version than ({0})"'                              extractVersion));                      }                        // Central header flags match local entry flags.                      if (localFlags != entry.Flags)                      {                          throw new ZipException("Central header/local header flags mismatch");                      }                        // Central header compression method matches local entry                      if (entry.CompressionMethod != (CompressionMethod) compressionMethod)                      {                          throw new ZipException("Central header/local header compression method mismatch");                      }                        if (entry.Version != extractVersion)                      {                          throw new ZipException("Extract version mismatch");                      }                        // Strong encryption and extract version match                      if ((localFlags & (int) GeneralBitFlags.StrongEncryption) != 0)                      {                          if (extractVersion < 62)                          {                              throw new ZipException("Strong encryption flag set but version not high enough");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.HeaderMasked) != 0)                      {                          if ((fileTime != 0) || (fileDate != 0))                          {                              throw new ZipException("Header masked set but date/time values non-zero");                          }                      }                        if ((localFlags & (int) GeneralBitFlags.Descriptor) == 0)                      {                          if (crcValue != (uint) entry.Crc)                          {                              throw new ZipException("Central header/local header crc mismatch");                          }                      }                        // Crc valid for empty entry.                      // This will also apply to streamed entries where size isnt known and the header cant be patched                      if ((size == 0) && (compressedSize == 0))                      {                          if (crcValue != 0)                          {                              throw new ZipException("Invalid CRC for empty entry");                          }                      }                        // TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings                      // Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably                      if (entry.Name.Length > storedNameLength)                      {                          throw new ZipException("File name length mismatch");                      }                        // Name data has already been read convert it and compare.                      string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);                        // Central directory and local entry name match                      if (localName != entry.Name)                      {                          throw new ZipException("Central header and local header file name mismatch");                      }                        // Directories have zero actual size but can have compressed size                      if (entry.IsDirectory)                      {                          if (size > 0)                          {                              throw new ZipException("Directory cannot have size");                          }                            // There may be other cases where the compressed size can be greater than this?                          // If so until details are known we will be strict.                          if (entry.IsCrypted)                          {                              if (compressedSize > ZipConstants.CryptoHeaderSize + 2)                              {                                  throw new ZipException("Directory compressed size invalid");                              }                          }                          else if (compressedSize > 2)                          {                              // When not compressed the directory size can validly be 2 bytes                              // if the true size wasnt known when data was originally being written.                              // NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes                              throw new ZipException("Directory compressed size invalid");                          }                      }                        if (!ZipNameTransform.IsValidName(localName' true))                      {                          throw new ZipException("Name is invalid");                      }                  }                    // Tests that apply to both data and header.                    // Size can be verified only if it is known in the local header.                  // it will always be known in the central header.                  if (((localFlags & (int) GeneralBitFlags.Descriptor) == 0) ||                      ((size > 0) || (compressedSize > 0)))                  {                      if (size != entry.Size)                      {                          throw new ZipException(                              string.Format("Size mismatch between central header({0}) and local header({1})"'                                  entry.Size' size));                      }                        if (compressedSize != entry.CompressedSize &&                          compressedSize != 0xFFFFFFFF && compressedSize != -1)                      {                          throw new ZipException(                              string.Format("Compressed size mismatch between central header({0}) and local header({1})"'                                  entry.CompressedSize' compressedSize));                      }                  }                    int extraLength = storedNameLength + extraDataLength;                  return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte((byte) ((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort((ushort) (value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt((int) (value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint((uint) (value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1)              {                  WriteLEInt(entry.ExternalFileAttributes);              }              else              {                  if (entry.IsDirectory)                  {                      WriteLEUint(16);                  }                  else                  {                      WriteLEUint(0);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int) GeneralBitFlags.Descriptor) != 0)              {                  result = ZipConstants.DataDescriptorSize - 4;                  if (update.Entry.LocalHeaderRequiresZip64)                  {                      result = ZipConstants.Zip64DataDescriptorSize - 4;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int) GeneralBitFlags.Descriptor) != 0)              {                  result = ZipConstants.DataDescriptorSize - 4;                  if (update.Entry.LocalHeaderRequiresZip64)                  {                      result = ZipConstants.Zip64DataDescriptorSize - 4;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch (entry.CompressionMethod)              {                  case CompressionMethod.Stored:                      result = new UncompressedStream(result);                      break;                    case CompressionMethod.Deflated:                      var dos = new DeflaterOutputStream(result' new Deflater(9' true));                      dos.IsStreamOwner = false;                      result = dos;                      break;                    default:                      throw new ZipException("Unknown compression method " + entry.CompressionMethod);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CopyEntryDirect,The following statement contains a magic number: const int NameLengthOffset = 26;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if (update.Entry.CompressedSize > 0)              {                  const int NameLengthOffset = 26;                    long entryDataOffset = update.Entry.Offset + NameLengthOffset;                    // TODO: This wont work for SFX files!                  baseStream_.Seek(entryDataOffset' SeekOrigin.Begin);                    uint nameLength = ReadLEUshort();                  uint extraLength = ReadLEUshort();                    baseStream_.Seek(nameLength + extraLength' SeekOrigin.Current);                    CopyBytes(update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using (updateFile)              {                  long locatedCentralDirOffset =                      updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature'                          baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);                  if (locatedCentralDirOffset < 0)                  {                      throw new ZipException("Cannot find central directory");                  }                    const int CentralHeaderCommentSizeOffset = 16;                  updateFile.Position += CentralHeaderCommentSizeOffset;                    byte[] rawComment = newComment_.RawComment;                    updateFile.WriteLEShort(rawComment.Length);                  updateFile.Write(rawComment' 0' rawComment.Length);                  updateFile.SetLength(updateFile.Position);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort) ((ushort) data1 | (ushort) (data2 << 8)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint) (ReadLEUshort() | (ReadLEUshort() << 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint() | ((ulong) ReadLEUint() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long) centralDirSize)))              {                  offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long) centralDirSize + offsetOfCentralDir);                  if (offsetOfFirstEntry <= 0)                  {                      throw new ZipException("Invalid embedded zip archive");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long) centralDirSize)))              {                  offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long) centralDirSize + offsetOfCentralDir);                  if (offsetOfFirstEntry <= 0)                  {                      throw new ZipException("Invalid embedded zip archive");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++)              {                  if (ReadLEUint() != ZipConstants.CentralHeaderSignature)                  {                      throw new ZipException("Wrong Central Directory signature");                  }                    int versionMadeBy = ReadLEUshort();                  int versionToExtract = ReadLEUshort();                  int bitFlags = ReadLEUshort();                  int method = ReadLEUshort();                  uint dostime = ReadLEUint();                  uint crc = ReadLEUint();                  long csize = ReadLEUint();                  long size = ReadLEUint();                  int nameLen = ReadLEUshort();                  int extraLen = ReadLEUshort();                  int commentLen = ReadLEUshort();                    int diskStartNo = ReadLEUshort(); // Not currently used                  int internalAttributes = ReadLEUshort(); // Not currently used                    uint externalAttributes = ReadLEUint();                  long offset = ReadLEUint();                    var buffer = new byte[Math.Max(nameLen' commentLen)];                    StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);                  string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);                    var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod) method);                  entry.Crc = crc & 0xffffffffL;                  entry.Size = size & 0xffffffffL;                  entry.CompressedSize = csize & 0xffffffffL;                  entry.Flags = bitFlags;                  entry.DosTime = dostime;                  entry.ZipFileIndex = (long) i;                  entry.Offset = offset;                  entry.ExternalFileAttributes = (int) externalAttributes;                    if ((bitFlags & 8) == 0)                  {                      entry.CryptoCheckValue = (byte) (crc >> 24);                  }                  else                  {                      entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);                  }                    if (extraLen > 0)                  {                      var extra = new byte[extraLen];                      StreamUtils.ReadFully(baseStream_' extra);                      entry.ExtraData = extra;                  }                    entry.ProcessExtraData(false);                    if (commentLen > 0)                  {                      StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);                      entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);                  }                    entries_[i] = entry;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++)              {                  if (ReadLEUint() != ZipConstants.CentralHeaderSignature)                  {                      throw new ZipException("Wrong Central Directory signature");                  }                    int versionMadeBy = ReadLEUshort();                  int versionToExtract = ReadLEUshort();                  int bitFlags = ReadLEUshort();                  int method = ReadLEUshort();                  uint dostime = ReadLEUint();                  uint crc = ReadLEUint();                  long csize = ReadLEUint();                  long size = ReadLEUint();                  int nameLen = ReadLEUshort();                  int extraLen = ReadLEUshort();                  int commentLen = ReadLEUshort();                    int diskStartNo = ReadLEUshort(); // Not currently used                  int internalAttributes = ReadLEUshort(); // Not currently used                    uint externalAttributes = ReadLEUint();                  long offset = ReadLEUint();                    var buffer = new byte[Math.Max(nameLen' commentLen)];                    StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);                  string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);                    var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod) method);                  entry.Crc = crc & 0xffffffffL;                  entry.Size = size & 0xffffffffL;                  entry.CompressedSize = csize & 0xffffffffL;                  entry.Flags = bitFlags;                  entry.DosTime = dostime;                  entry.ZipFileIndex = (long) i;                  entry.Offset = offset;                  entry.ExternalFileAttributes = (int) externalAttributes;                    if ((bitFlags & 8) == 0)                  {                      entry.CryptoCheckValue = (byte) (crc >> 24);                  }                  else                  {                      entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);                  }                    if (extraLen > 0)                  {                      var extra = new byte[extraLen];                      StreamUtils.ReadFully(baseStream_' extra);                      entry.ExtraData = extra;                  }                    entry.ProcessExtraData(false);                    if (commentLen > 0)                  {                      StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);                      entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);                  }                    entries_[i] = entry;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++)              {                  if (ReadLEUint() != ZipConstants.CentralHeaderSignature)                  {                      throw new ZipException("Wrong Central Directory signature");                  }                    int versionMadeBy = ReadLEUshort();                  int versionToExtract = ReadLEUshort();                  int bitFlags = ReadLEUshort();                  int method = ReadLEUshort();                  uint dostime = ReadLEUint();                  uint crc = ReadLEUint();                  long csize = ReadLEUint();                  long size = ReadLEUint();                  int nameLen = ReadLEUshort();                  int extraLen = ReadLEUshort();                  int commentLen = ReadLEUshort();                    int diskStartNo = ReadLEUshort(); // Not currently used                  int internalAttributes = ReadLEUshort(); // Not currently used                    uint externalAttributes = ReadLEUint();                  long offset = ReadLEUint();                    var buffer = new byte[Math.Max(nameLen' commentLen)];                    StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);                  string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);                    var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod) method);                  entry.Crc = crc & 0xffffffffL;                  entry.Size = size & 0xffffffffL;                  entry.CompressedSize = csize & 0xffffffffL;                  entry.Flags = bitFlags;                  entry.DosTime = dostime;                  entry.ZipFileIndex = (long) i;                  entry.Offset = offset;                  entry.ExternalFileAttributes = (int) externalAttributes;                    if ((bitFlags & 8) == 0)                  {                      entry.CryptoCheckValue = (byte) (crc >> 24);                  }                  else                  {                      entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);                  }                    if (extraLen > 0)                  {                      var extra = new byte[extraLen];                      StreamUtils.ReadFully(baseStream_' extra);                      entry.ExtraData = extra;                  }                    entry.ProcessExtraData(false);                    if (commentLen > 0)                  {                      StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);                      entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);                  }                    entries_[i] = entry;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)                  || (entry.Flags & (int) GeneralBitFlags.StrongEncryption) == 0)              {                  var classicManaged = new PkzipClassicManaged();                    OnKeysRequired(entry.Name);                  if (HaveKeys == false)                  {                      throw new ZipException("No password available for encrypted stream");                  }                    result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);                  CheckClassicPassword(result' entry);              }              else              {  #if !NET_1_1 && !NETCF_2_0                  if (entry.Version == ZipConstants.VERSION_AES)                  {                      //                      OnKeysRequired(entry.Name);                      if (HaveKeys == false)                      {                          throw new ZipException("No password available for AES encrypted stream");                      }                      int saltLen = entry.AESSaltLen;                      var saltBytes = new byte[saltLen];                      int saltIn = baseStream.Read(saltBytes' 0' saltLen);                      if (saltIn != saltLen)                          throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);                      //                      var pwdVerifyRead = new byte[2];                      baseStream.Read(pwdVerifyRead' 0' 2);                      int blockSize = entry.AESKeySize/8; // bits to bytes                        var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);                      byte[] pwdVerifyCalc = decryptor.PwdVerifier;                      if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])                          throw new Exception("Invalid password for AES");                      result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);                  }                  else  #endif                  {                      throw new ZipException("Decryption method not supported");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)                  || (entry.Flags & (int) GeneralBitFlags.StrongEncryption) == 0)              {                  var classicManaged = new PkzipClassicManaged();                    OnKeysRequired(entry.Name);                  if (HaveKeys == false)                  {                      throw new ZipException("No password available for encrypted stream");                  }                    result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);                  CheckClassicPassword(result' entry);              }              else              {  #if !NET_1_1 && !NETCF_2_0                  if (entry.Version == ZipConstants.VERSION_AES)                  {                      //                      OnKeysRequired(entry.Name);                      if (HaveKeys == false)                      {                          throw new ZipException("No password available for AES encrypted stream");                      }                      int saltLen = entry.AESSaltLen;                      var saltBytes = new byte[saltLen];                      int saltIn = baseStream.Read(saltBytes' 0' saltLen);                      if (saltIn != saltLen)                          throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);                      //                      var pwdVerifyRead = new byte[2];                      baseStream.Read(pwdVerifyRead' 0' 2);                      int blockSize = entry.AESKeySize/8; // bits to bytes                        var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);                      byte[] pwdVerifyCalc = decryptor.PwdVerifier;                      if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])                          throw new Exception("Invalid password for AES");                      result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);                  }                  else  #endif                  {                      throw new ZipException("Decryption method not supported");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)                  || (entry.Flags & (int) GeneralBitFlags.StrongEncryption) == 0)              {                  var classicManaged = new PkzipClassicManaged();                    OnKeysRequired(entry.Name);                  if (HaveKeys == false)                  {                      throw new ZipException("No password available for encrypted stream");                  }                    result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);                  CheckClassicPassword(result' entry);              }              else              {  #if !NET_1_1 && !NETCF_2_0                  if (entry.Version == ZipConstants.VERSION_AES)                  {                      //                      OnKeysRequired(entry.Name);                      if (HaveKeys == false)                      {                          throw new ZipException("No password available for AES encrypted stream");                      }                      int saltLen = entry.AESSaltLen;                      var saltBytes = new byte[saltLen];                      int saltIn = baseStream.Read(saltBytes' 0' saltLen);                      if (saltIn != saltLen)                          throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);                      //                      var pwdVerifyRead = new byte[2];                      baseStream.Read(pwdVerifyRead' 0' 2);                      int blockSize = entry.AESKeySize/8; // bits to bytes                        var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);                      byte[] pwdVerifyCalc = decryptor.PwdVerifier;                      if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])                          throw new Exception("Invalid password for AES");                      result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);                  }                  else  #endif                  {                      throw new ZipException("Decryption method not supported");                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)                  || (entry.Flags & (int) GeneralBitFlags.StrongEncryption) == 0)              {                  var classicManaged = new PkzipClassicManaged();                    OnKeysRequired(entry.Name);                  if (HaveKeys == false)                  {                      throw new ZipException("No password available for encrypted stream");                  }                    // Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream                  // which doesnt do this.                  result = new CryptoStream(new UncompressedStream(baseStream)'                      classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);                    if ((entry.Crc < 0) || (entry.Flags & 8) != 0)                  {                      WriteEncryptionHeader(result' entry.DosTime << 16);                  }                  else                  {                      WriteEncryptionHeader(result' entry.Crc);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)                  || (entry.Flags & (int) GeneralBitFlags.StrongEncryption) == 0)              {                  var classicManaged = new PkzipClassicManaged();                    OnKeysRequired(entry.Name);                  if (HaveKeys == false)                  {                      throw new ZipException("No password available for encrypted stream");                  }                    // Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream                  // which doesnt do this.                  result = new CryptoStream(new UncompressedStream(baseStream)'                      classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);                    if ((entry.Crc < 0) || (entry.Flags & 8) != 0)                  {                      WriteEncryptionHeader(result' entry.DosTime << 16);                  }                  else                  {                      WriteEncryptionHeader(result' entry.Crc);                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte) (crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte) (crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy(stream' temporaryStream_' new byte[4096]);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite)              {                  result = new MemoryStream();                    if (stream != null)                  {                      stream.Position = 0;                      StreamUtils.Copy(stream' result' new byte[4096]);                        stream.Close();                  }              }              else              {                  result = stream;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong(44);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort() | (ReadLEShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint) ReadLEInt() | ((long) ReadLEInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte((byte) ((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort((ushort) (value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt((int) (value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint((uint) (value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int) GeneralBitFlags.Descriptor) != 0)              {                  // The signature is not PKZIP originally but is now described as optional                  // in the PKZIP Appnote documenting trhe format.                  WriteLEInt(ZipConstants.DataDescriptorSignature);                  WriteLEInt(unchecked((int) (entry.Crc)));                    result += 8;                    if (entry.LocalHeaderRequiresZip64)                  {                      WriteLELong(entry.CompressedSize);                      WriteLELong(entry.Size);                      result += 16;                  }                  else                  {                      WriteLEInt((int) entry.CompressedSize);                      WriteLEInt((int) entry.Size);                      result += 8;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int) GeneralBitFlags.Descriptor) != 0)              {                  // The signature is not PKZIP originally but is now described as optional                  // in the PKZIP Appnote documenting trhe format.                  WriteLEInt(ZipConstants.DataDescriptorSignature);                  WriteLEInt(unchecked((int) (entry.Crc)));                    result += 8;                    if (entry.LocalHeaderRequiresZip64)                  {                      WriteLELong(entry.CompressedSize);                      WriteLELong(entry.Size);                      result += 16;                  }                  else                  {                      WriteLEInt((int) entry.CompressedSize);                      WriteLEInt((int) entry.Size);                      result += 8;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int) GeneralBitFlags.Descriptor) != 0)              {                  // The signature is not PKZIP originally but is now described as optional                  // in the PKZIP Appnote documenting trhe format.                  WriteLEInt(ZipConstants.DataDescriptorSignature);                  WriteLEInt(unchecked((int) (entry.Crc)));                    result += 8;                    if (entry.LocalHeaderRequiresZip64)                  {                      WriteLELong(entry.CompressedSize);                      WriteLELong(entry.Size);                      result += 16;                  }                  else                  {                      WriteLEInt((int) entry.CompressedSize);                      WriteLEInt((int) entry.Size);                      result += 8;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0)              {                  entry.Crc = crc2 & 0xFFFFFFFFL;                  entry.Size = size & 0xFFFFFFFFL;                  entry.CompressedSize = csize & 0xFFFFFFFFL;                    entry.CryptoCheckValue = (byte) ((crc2 >> 24) & 0xff);              }              else              {                  // This allows for GNU' WinZip and possibly other archives' the PKZIP spec                  // says these values are zero under these circumstances.                  if (crc2 != 0)                  {                      entry.Crc = crc2 & 0xFFFFFFFFL;                  }                    if (size != 0)                  {                      entry.Size = size & 0xFFFFFFFFL;                  }                    if (csize != 0)                  {                      entry.CompressedSize = csize & 0xFFFFFFFFL;                  }                    entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0)              {                  entry.Crc = crc2 & 0xFFFFFFFFL;                  entry.Size = size & 0xFFFFFFFFL;                  entry.CompressedSize = csize & 0xFFFFFFFFL;                    entry.CryptoCheckValue = (byte) ((crc2 >> 24) & 0xff);              }              else              {                  // This allows for GNU' WinZip and possibly other archives' the PKZIP spec                  // says these values are zero under these circumstances.                  if (crc2 != 0)                  {                      entry.Crc = crc2 & 0xFFFFFFFFL;                  }                    if (size != 0)                  {                      entry.Size = size & 0xFFFFFFFFL;                  }                    if (csize != 0)                  {                      entry.CompressedSize = csize & 0xFFFFFFFFL;                  }                    entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0)              {                  entry.Crc = crc2 & 0xFFFFFFFFL;                  entry.Size = size & 0xFFFFFFFFL;                  entry.CompressedSize = csize & 0xFFFFFFFFL;                    entry.CryptoCheckValue = (byte) ((crc2 >> 24) & 0xff);              }              else              {                  // This allows for GNU' WinZip and possibly other archives' the PKZIP spec                  // says these values are zero under these circumstances.                  if (crc2 != 0)                  {                      entry.Crc = crc2 & 0xFFFFFFFFL;                  }                    if (size != 0)                  {                      entry.Size = size & 0xFFFFFFFFL;                  }                    if (csize != 0)                  {                      entry.CompressedSize = csize & 0xFFFFFFFFL;                  }                    entry.CryptoCheckValue = (byte) ((dostime >> 8) & 0xff);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0)              {                  ReadDataDescriptor();              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int) CompressionMethod.Deflated)              {                  if ((flags & 8) != 0)                  {                      // We don't know how much we must skip' read until end.                      var tmp = new byte[4096];                        // Read will close this entry                      while (Read(tmp' 0' tmp.Length) > 0)                      {                      }                      return;                  }                    csize -= inf.TotalIn;                  inputBuffer.Available += inf.RemainingInput;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int) CompressionMethod.Deflated)              {                  if ((flags & 8) != 0)                  {                      // We don't know how much we must skip' read until end.                      var tmp = new byte[4096];                        // Read will close this entry                      while (Read(tmp' 0' tmp.Length) > 0)                      {                      }                      return;                  }                    csize -= inf.TotalIn;                  inputBuffer.Available += inf.RemainingInput;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method)              {                  case (int) CompressionMethod.Deflated:                      count = base.Read(buffer' offset' count);                      if (count <= 0)                      {                          if (!inf.IsFinished)                          {                              throw new ZipException("Inflater not finished!");                          }                          inputBuffer.Available = inf.RemainingInput;                            // A csize of -1 is from an unpatched local header                          if ((flags & 8) == 0 &&                              (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size))                          {                              throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" +                                                     inf.TotalOut);                          }                          inf.Reset();                          finished = true;                      }                      break;                    case (int) CompressionMethod.Stored:                      if ((count > csize) && (csize >= 0))                      {                          count = (int) csize;                      }                        if (count > 0)                      {                          count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);                          if (count > 0)                          {                              csize -= count;                              size -= count;                          }                      }                        if (csize == 0)                      {                          finished = true;                      }                      else                      {                          if (count < 0)                          {                              throw new ZipException("EOF in stored block");                          }                      }                      break;              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: int howMany = invalidPathChars.Length + 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed[howMany - 2] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 2] = '\\';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 3] = '*';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 4] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked              {                  baseOutputStream_.WriteByte((byte) (value & 0xff));                  baseOutputStream_.WriteByte((byte) ((value >> 8) & 0xff));              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked              {                  WriteLeShort(value);                  WriteLeShort(value >> 16);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked              {                  WriteLeInt((int) value);                  WriteLeInt((int) (value >> 32));              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false)              {                  if (CanPatchEntries == false)                  {                      // Only way to record size and compressed size is to append a data descriptor                      // after compressed data.                        // Stored entries of this form have already been converted to deflating.                      entry.Flags |= 8;                  }                  else                  {                      patchEntryHeader = true;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null)              {                  entry.IsCrypted = true;                  if (entry.Crc < 0)                  {                      // Need to append a data descriptor as the crc isnt available for use                      // with encryption' the date is used instead.  Setting the flag                      // indicates this to the decompressor.                      entry.Flags |= 8;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted)              {  #if !NET_1_1 && !NETCF_2_0                  if (entry.AESKeySize > 0)                  {                      WriteAESHeader(entry);                  }                  else  #endif                  {                      if (entry.Crc < 0)                      {                          // so testing Zip will says its ok                          WriteEncryptionHeader(entry.DosTime << 16);                      }                      else                      {                          WriteEncryptionHeader(entry.Crc);                      }                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if (curEntry.AESKeySize > 0)              {                  baseOutputStream_.Write(AESAuthCode' 0' 10);              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0)              {                  WriteLeInt(ZipConstants.DataDescriptorSignature);                  WriteLeInt(unchecked((int) curEntry.Crc));                    if (curEntry.LocalHeaderRequiresZip64)                  {                      WriteLeLong(curEntry.CompressedSize);                      WriteLeLong(curEntry.Size);                      offset += ZipConstants.Zip64DataDescriptorSize;                  }                  else                  {                      WriteLeInt((int) curEntry.CompressedSize);                      WriteLeInt((int) curEntry.Size);                      offset += ZipConstants.DataDescriptorSize;                  }              }
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte) (crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte) (crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,AddExtraDataAES,The following statement contains a magic number: const int VENDOR_VERSION = 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,CopyAndEncrypt,The following statement contains a magic number: const int CopyBufferSize = 4096;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries)              {                  WriteLeInt(ZipConstants.CentralHeaderSignature);                  WriteLeShort(ZipConstants.VersionMadeBy);                  WriteLeShort(entry.Version);                  WriteLeShort(entry.Flags);                  WriteLeShort((short) entry.CompressionMethodForHeader);                  WriteLeInt((int) entry.DosTime);                  WriteLeInt((int) entry.Crc);                    if (entry.IsZip64Forced() ||                      (entry.CompressedSize >= uint.MaxValue))                  {                      WriteLeInt(-1);                  }                  else                  {                      WriteLeInt((int) entry.CompressedSize);                  }                    if (entry.IsZip64Forced() ||                      (entry.Size >= uint.MaxValue))                  {                      WriteLeInt(-1);                  }                  else                  {                      WriteLeInt((int) entry.Size);                  }                    byte[] name = ZipConstants.ConvertToArray(entry.Flags' entry.Name);                    if (name.Length > 0xffff)                  {                      throw new ZipException("Name too long.");                  }                    var ed = new ZipExtraData(entry.ExtraData);                    if (entry.CentralHeaderRequiresZip64)                  {                      ed.StartNewEntry();                      if (entry.IsZip64Forced() ||                          (entry.Size >= 0xffffffff))                      {                          ed.AddLeLong(entry.Size);                      }                        if (entry.IsZip64Forced() ||                          (entry.CompressedSize >= 0xffffffff))                      {                          ed.AddLeLong(entry.CompressedSize);                      }                        if (entry.Offset >= 0xffffffff)                      {                          ed.AddLeLong(entry.Offset);                      }                        ed.AddNewEntry(1);                  }                  else                  {                      ed.Delete(1);                  }    #if !NET_1_1 && !NETCF_2_0                  if (entry.AESKeySize > 0)                  {                      AddExtraDataAES(entry' ed);                  }  #endif                  byte[] extra = ed.GetEntryData();                    byte[] entryComment =                      (entry.Comment != null)                          ? ZipConstants.ConvertToArray(entry.Flags' entry.Comment)                          : new byte[0];                    if (entryComment.Length > 0xffff)                  {                      throw new ZipException("Comment too long.");                  }                    WriteLeShort(name.Length);                  WriteLeShort(extra.Length);                  WriteLeShort(entryComment.Length);                  WriteLeShort(0); // disk number                  WriteLeShort(0); // internal file attributes                  // external file attributes                    if (entry.ExternalFileAttributes != -1)                  {                      WriteLeInt(entry.ExternalFileAttributes);                  }                  else                  {                      if (entry.IsDirectory)                      {                          // mark entry as directory (from nikolam.AT.perfectinfo.com)                          WriteLeInt(16);                      }                      else                      {                          WriteLeInt(0);                      }                  }                    if (entry.Offset >= uint.MaxValue)                  {                      WriteLeInt(-1);                  }                  else                  {                      WriteLeInt((int) entry.Offset);                  }                    if (name.Length > 0)                  {                      baseOutputStream_.Write(name' 0' name.Length);                  }                    if (extra.Length > 0)                  {                      baseOutputStream_.Write(extra' 0' extra.Length);                  }                    if (entryComment.Length > 0)                  {                      baseOutputStream_.Write(entryComment' 0' entryComment.Length);                  }                    sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;              }
Magic Number,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.TxbFilePath = ((System.Windows.Controls.TextBox)(target));              return;              case 2:              this.BtnGenerate = ((System.Windows.Controls.Button)(target));                            #line 15 "..\..\..\WPF\MainWindow.xaml"              this.BtnGenerate.Click += new System.Windows.RoutedEventHandler(this.BtnGenerate_Click);                            #line default              #line hidden              return;              case 3:              this.CbxFrom = ((System.Windows.Controls.ComboBox)(target));              return;              case 4:              this.CbxTo = ((System.Windows.Controls.ComboBox)(target));              return;              }
Magic Number,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.TxbFilePath = ((System.Windows.Controls.TextBox)(target));              return;              case 2:              this.BtnGenerate = ((System.Windows.Controls.Button)(target));                            #line 15 "..\..\..\WPF\MainWindow.xaml"              this.BtnGenerate.Click += new System.Windows.RoutedEventHandler(this.BtnGenerate_Click);                            #line default              #line hidden              return;              case 3:              this.CbxFrom = ((System.Windows.Controls.ComboBox)(target));              return;              case 4:              this.CbxTo = ((System.Windows.Controls.ComboBox)(target));              return;              }
Magic Number,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.TxbFilePath = ((System.Windows.Controls.TextBox)(target));              return;              case 2:              this.BtnGenerate = ((System.Windows.Controls.Button)(target));                            #line 15 "..\..\..\WPF\MainWindow.xaml"              this.BtnGenerate.Click += new System.Windows.RoutedEventHandler(this.BtnGenerate_Click);                            #line default              #line hidden              return;              case 3:              this.CbxFrom = ((System.Windows.Controls.ComboBox)(target));              return;              case 4:              this.CbxTo = ((System.Windows.Controls.ComboBox)(target));              return;              }
Missing Default,Studyzy.IMEWLConverter.IME,Rime,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\IME\Rime.cs,GetLineSplit,The following switch statement is missing a default case: switch (os)              {                  case OperationSystem.Windows:                      return "\r\n";                    case OperationSystem.MacOS:                      return "\r";                    case OperationSystem.Linux:                      return "\n";              }
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction)                  {                      case DEFLATE_STORED:                          if (strstart > blockStart)                          {                              huffman.FlushStoredBlock(window' blockStart'                                  strstart - blockStart' false);                              blockStart = strstart;                          }                          UpdateHash();                          break;                        case DEFLATE_FAST:                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart'                                  false);                              blockStart = strstart;                          }                          break;                        case DEFLATE_SLOW:                          if (prevAvailable)                          {                              huffman.TallyLit(window[strstart - 1] & 0xff);                          }                          if (strstart > blockStart)                          {                              huffman.FlushBlock(window' blockStart' strstart - blockStart' false);                              blockStart = strstart;                          }                          prevAvailable = false;                          matchLen = MIN_MATCH - 1;                          break;                  }
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode)                  {                      case LNUM:                          lnum = input.PeekBits(5);                          if (lnum < 0)                          {                              return false;                          }                          lnum += 257;                          input.DropBits(5);                          //  	    System.err.println("LNUM: "+lnum);                          mode = DNUM;                          goto case DNUM; // fall through                      case DNUM:                          dnum = input.PeekBits(5);                          if (dnum < 0)                          {                              return false;                          }                          dnum++;                          input.DropBits(5);                          //  	    System.err.println("DNUM: "+dnum);                          num = lnum + dnum;                          litdistLens = new byte[num];                          mode = BLNUM;                          goto case BLNUM; // fall through                      case BLNUM:                          blnum = input.PeekBits(4);                          if (blnum < 0)                          {                              return false;                          }                          blnum += 4;                          input.DropBits(4);                          blLens = new byte[19];                          ptr = 0;                          //  	    System.err.println("BLNUM: "+blnum);                          mode = BLLENS;                          goto case BLLENS; // fall through                      case BLLENS:                          while (ptr < blnum)                          {                              int len = input.PeekBits(3);                              if (len < 0)                              {                                  return false;                              }                              input.DropBits(3);                              //  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);                              blLens[BL_ORDER[ptr]] = (byte) len;                              ptr++;                          }                          blTree = new InflaterHuffmanTree(blLens);                          blLens = null;                          ptr = 0;                          mode = LENS;                          goto case LENS; // fall through                      case LENS:                      {                          int symbol;                          while (((symbol = blTree.GetSymbol(input)) & ~15) == 0)                          {                              /* Normal case: symbol in [0..15] */                                //  		  System.err.println("litdistLens["+ptr+"]: "+symbol);                              litdistLens[ptr++] = lastLen = (byte) symbol;                                if (ptr == num)                              {                                  /* Finished */                                  return true;                              }                          }                            /* need more input ? */                          if (symbol < 0)                          {                              return false;                          }                            /* otherwise repeat code */                          if (symbol >= 17)                          {                              /* repeat zero */                              //  		  System.err.println("repeating zero");                              lastLen = 0;                          }                          else                          {                              if (ptr == 0)                              {                                  throw new SharpZipBaseException();                              }                          }                          repSymbol = symbol - 16;                      }                          mode = REPS;                          goto case REPS; // fall through                      case REPS:                      {                          int bits = repBits[repSymbol];                          int count = input.PeekBits(bits);                          if (count < 0)                          {                              return false;                          }                          input.DropBits(bits);                          count += repMin[repSymbol];                          //  	      System.err.println("litdistLens repeated: "+count);                            if (ptr + count > num)                          {                              throw new SharpZipBaseException();                          }                          while (count-- > 0)                          {                              litdistLens[ptr++] = lastLen;                          }                            if (ptr == num)                          {                              /* Finished */                              return true;                          }                      }                          mode = LENS;                          goto decode_loop;                  }
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_)                  {                      case UseZip64.Dynamic:                          if (entry.Size < 0)                          {                              entry.ForceZip64();                          }                          break;                        case UseZip64.On:                          entry.ForceZip64();                          break;                        case UseZip64.Off:                          // Do nothing.  The entry itself may be using Zip64 independantly.                          break;                  }
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command)                          {                              case UpdateCommand.Copy:                                  if (directUpdate)                                  {                                      CopyEntryDirect(workFile' update' ref destinationPosition);                                  }                                  else                                  {                                      CopyEntry(workFile' update);                                  }                                  break;                                case UpdateCommand.Modify:                                  // TODO: Direct modifying of an entry will take some legwork.                                  ModifyEntry(workFile' update);                                  break;                                case UpdateCommand.Add:                                  if (!IsNewArchive && directUpdate)                                  {                                      workFile.baseStream_.Position = destinationPosition;                                  }                                    AddEntry(workFile' update);                                    if (directUpdate)                                  {                                      destinationPosition = workFile.baseStream_.Position;                                  }                                  break;                          }
Missing Default,ICSharpCode.SharpZipLib.Zip,PartialInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipFile.cs,Seek,The following switch statement is missing a default case: switch (origin)                  {                      case SeekOrigin.Begin:                          newPos = start_ + offset;                          break;                        case SeekOrigin.Current:                          newPos = readPos_ + offset;                          break;                        case SeekOrigin.End:                          newPos = end_ + offset;                          break;                  }
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method)              {                  case (int) CompressionMethod.Deflated:                      count = base.Read(buffer' offset' count);                      if (count <= 0)                      {                          if (!inf.IsFinished)                          {                              throw new ZipException("Inflater not finished!");                          }                          inputBuffer.Available = inf.RemainingInput;                            // A csize of -1 is from an unpatched local header                          if ((flags & 8) == 0 &&                              (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size))                          {                              throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" +                                                     inf.TotalOut);                          }                          inf.Reset();                          finished = true;                      }                      break;                    case (int) CompressionMethod.Stored:                      if ((count > csize) && (csize >= 0))                      {                          count = (int) csize;                      }                        if (count > 0)                      {                          count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);                          if (count > 0)                          {                              csize -= count;                              size -= count;                          }                      }                        if (csize == 0)                      {                          finished = true;                      }                      else                      {                          if (count < 0)                          {                              throw new ZipException("EOF in stored block");                          }                      }                      break;              }
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\SharpZLib\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod)              {                  case CompressionMethod.Deflated:                      base.Write(buffer' offset' count);                      break;                    case CompressionMethod.Stored:                      if (Password != null)                      {                          CopyAndEncrypt(buffer' offset' count);                      }                      else                      {                          baseOutputStream_.Write(buffer' offset' count);                      }                      break;              }
Missing Default,Studyzy.IMEWLConverter.WPF,MainWindow,C:\repos\studyzy_imewlconverter\IME WL Converter\IME WL Converter\WPF\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.TxbFilePath = ((System.Windows.Controls.TextBox)(target));              return;              case 2:              this.BtnGenerate = ((System.Windows.Controls.Button)(target));                            #line 15 "..\..\..\WPF\MainWindow.xaml"              this.BtnGenerate.Click += new System.Windows.RoutedEventHandler(this.BtnGenerate_Click);                            #line default              #line hidden              return;              case 3:              this.CbxFrom = ((System.Windows.Controls.ComboBox)(target));              return;              case 4:              this.CbxTo = ((System.Windows.Controls.ComboBox)(target));              return;              }
