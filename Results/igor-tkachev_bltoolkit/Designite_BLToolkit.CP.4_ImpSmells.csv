Implementation smell,Namespace,Class,File,Method,Description
Long Method,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The method has 112 lines of code.
Long Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The method has 117 lines of code.
Long Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetSprocNameOrSqlQueryTest,The method has 101 lines of code.
Long Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,LoadParameterOrNull,The method has 109 lines of code.
Long Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The method has 115 lines of code.
Long Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,InitParameters,The method has 105 lines of code.
Long Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The method has 147 lines of code.
Long Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetDataProvider,The method has 102 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,The method has 367 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The method has 120 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The method has 241 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The method has 103 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The method has 105 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,The method has 130 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The method has 119 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToSql,The method has 106 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The method has 108 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The method has 114 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The method has 108 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The method has 102 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 131 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The method has 300 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The method has 119 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The method has 118 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The method has 150 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit1,The method has 243 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit2,The method has 264 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,The method has 140 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The method has 389 lines of code.
Long Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,The method has 129 lines of code.
Long Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSearchCondition,The method has 103 lines of code.
Long Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ConvertInListPredicate,The method has 113 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The method has 284 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 204 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The method has 121 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The method has 122 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The method has 122 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The method has 300 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The method has 263 lines of code.
Long Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The method has 151 lines of code.
Long Method,BLToolkit.ServiceModel,QuerySerializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Visit,The method has 382 lines of code.
Long Method,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The method has 364 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The method has 156 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,The method has 179 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,ImplementInterfaceBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\ImplementInterfaceBuilder.cs,BuildInterfaceMethod,The method has 150 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The method has 128 lines of code.
Complex Method,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,IsApplied,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Aspects.Builders,MixinAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,CheckOverrideAttribute,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Aspects.Builders,OverloadAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,BuildAbstractMethod,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Aspects.Builders,OverloadAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,GetOverloadedMethod,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects,CacheAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,AfterCall,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Cleanup,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByte,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToChar,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,Cyclomatic complexity of the method is 19
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTimeOffset,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDecimal,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDouble,Cyclomatic complexity of the method is 37
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToGuid,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt16,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt32,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt64,Cyclomatic complexity of the method is 37
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSByte,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSingle,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToString,Cyclomatic complexity of the method is 44
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt16,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt32,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt64,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableBoolean,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableByte,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableChar,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTime,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTimeOffset,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDecimal,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDouble,Cyclomatic complexity of the method is 36
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableGuid,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt16,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt32,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt64,Cyclomatic complexity of the method is 36
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSByte,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSingle,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableTimeSpan,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt16,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt32,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt64,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBinary,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBoolean,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlByte,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBytes,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDateTime,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDecimal,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDouble,Cyclomatic complexity of the method is 36
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlGuid,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt16,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt32,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt64,Cyclomatic complexity of the method is 36
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlMoney,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlSingle,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlString,Cyclomatic complexity of the method is 43
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlXml,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByteArray,Cyclomatic complexity of the method is 42
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToStream,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToType,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlChars,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToLinqBinary,Cyclomatic complexity of the method is 36
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToCharArray,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToXmlReader,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToXmlDocument,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToXElement,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ChangeTypeFromString,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Common,Convert<T;P>,C:\repos\igor-tkachev_bltoolkit\Source\Common\ConvertT.cs,GetConverter,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Common,Operator<T>,C:\repos\igor-tkachev_bltoolkit\Source\Common\Operator.cs,GetOperable,Cyclomatic complexity of the method is 47
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,LoadParameterOrNull,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Close,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,PrepareParameters,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,InitParameters,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetDataProvider,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,FindFirstSuitableProvider,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetSqlText,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,UnionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,GetTypeName,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,DefaultIfEmptyContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\DefaultIfEmptyBuilder.cs,BuildExpression,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,SelectManyBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,BuildMethodCall,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressionTree,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertMethodExpression,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertWhere,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectComparison,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,GroupByContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,ConvertEnumerable,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetSequence,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,SelectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,Convert,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetInheritanceDiscriminators,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,MapDataReaderToObject1,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,MapDataReaderToObject2,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetContext,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetField,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetParameters,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetQuery,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildJoinTable,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeUpdate,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetSequenceNameAttribute,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,GetDataType,Cyclomatic complexity of the method is 20
Complex Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSearchCondition,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,RemoveSubQuery,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ConvertInListPredicate,Cyclomatic complexity of the method is 23
Complex Method,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,InitFromBase,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetBindings,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,ConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,MapCrossReferences,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetPrimitiveMemberMapper,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetSimpleMemberMapper,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetNullableMemberMapper,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetSqlTypeMemberMapper,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,MapFrom,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MapSetData<T>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapSetDataT.cs,GetSetter,Cyclomatic complexity of the method is 63
Complex Method,BLToolkit.Mapping,TextDataWriter,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataWriter.cs,WriteRecord,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Mapping,MapGetData<T>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapGetDataT.cs,GetGetter,Cyclomatic complexity of the method is 63
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDefaultNullValue,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,Cyclomatic complexity of the method is 41
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDataSource,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapSourceListToDestinationList,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapValueToEnum,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapValueToEnum,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapResultSets,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Mapping,ObjectMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapper.cs,CreateMemberMapper,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Mapping,ObjectMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapper.cs,Init,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,GetEditor,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Reflection,ExprMemberAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\ExprMemberAccessor.cs,GetMemberAccessor,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Reflection,ExprTypeAccessor<T;TOriginal>,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ExprTypeAccessor,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetAttributesTreeInternal,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsSameOrParent,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetListItemType,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetListItemType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetElementType,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetGenericArguments,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetNullInternal,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,MapTypeName,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapValues,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullable,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.ServiceModel,ResultDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,DeserializeResult,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.ServiceModel,RemoteDataContextBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,GetSqlText,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.TypeBuilder,TypeFactory,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,CheckCompatibility,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineNonAbstractType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,Cyclomatic complexity of the method is 21
Complex Method,BLToolkit.TypeBuilder.Builders,ImplementInterfaceBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\ImplementInterfaceBuilder.cs,BuildInterfaceMethod,Cyclomatic complexity of the method is 24
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMember,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildCloneValueMethod,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,GetGetter,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,GetSetter,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Reflection.Emit,MethodBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\MethodBuilderHelper.cs,MethodBuilderHelper,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Validation,MaxValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Validation\MaxValueAttribute.cs,IsValid,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Validation,MinValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Validation\MinValueAttribute.cs,IsValid,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Validation,Validator,C:\repos\igor-tkachev_bltoolkit\Source\Validation\Validator.cs,IsValid,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Net,HttpReader,C:\repos\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,PrepareRequest,Cyclomatic complexity of the method is 10
Long Parameter List,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,InterceptorAspectBuilder,The method has 5 parameters. Parameters: interceptorType' interceptType' configString' priority' localInterceptor
Long Parameter List,BLToolkit.Aspects,InterceptorAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\InterceptorAttribute.cs,InterceptorAttribute,The method has 5 parameters. Parameters: interceptorType' interceptType' configString' priority' localInterceptor
Long Parameter List,BLToolkit.DataAccess,DataAccessor,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessor.cs,CreateParameters,The method has 6 parameters. Parameters: db' obj' outputParameters' inputOutputParameters' ignoreParameters' commandParameters
Long Parameter List,BLToolkit.DataAccess,DataAccessor,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessor.cs,CreateParameters,The method has 6 parameters. Parameters: db' dataRow' outputParameters' inputOutputParameters' ignoreParameters' commandParameters
Long Parameter List,BLToolkit.DataAccess,DataAccessor,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessor.cs,ExecuteDictionary,The method has 5 parameters. Parameters: db' dictionary' objectType' keyType' methodName
Long Parameter List,BLToolkit.DataAccess,DataAccessor,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessor.cs,ExecuteScalarDictionary,The method has 7 parameters. Parameters: db' dictionary' objectType' keyType' methodName' scalarField' elementType
Long Parameter List,BLToolkit.DataAccess,SqlQuery<T>,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryT.cs,ExecuteForEach,The method has 5 parameters. Parameters: db' collection' members' maxBatchSize' getParameters
Long Parameter List,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The method has 5 parameters. Parameters: dataRow' outputParameters' inputOutputParameters' ignoreParameters' commandParameters
Long Parameter List,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The method has 5 parameters. Parameters: obj' outputParameters' inputOutputParameters' ignoreParameters' commandParameters
Long Parameter List,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Parameter,The method has 5 parameters. Parameters: parameterDirection' parameterName' value' dbType' size
Long Parameter List,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Parameter,The method has 5 parameters. Parameters: parameterName' dbType' size' sourceColumn' dataRowVersion
Long Parameter List,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,The method has 5 parameters. Parameters: dic' keyField' keyFieldType' valueField' valueFieldType
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderInterpreterBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderInterpreterBase.cs,GetInsertBatchSqlList,The method has 5 parameters. Parameters: insertText' collection' members' maxBatchSize' withIdentity
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 5 parameters. Parameters: userName' password' server' sid' port
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The method has 5 parameters. Parameters: userName' password' server' sid' port
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 6 parameters. Parameters: userName' password' server' sid' timeOut' port
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The method has 6 parameters. Parameters: userName' password' server' sid' timeOut' port
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 6 parameters. Parameters: userName' password' server' sid' timeOutInSecond' port
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,InsertBatchWithIdentity,The method has 6 parameters. Parameters: db' insertText' collection' members' maxBatchSize' getParameters
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,InsertBatch,The method has 6 parameters. Parameters: db' insertText' collection' members' maxBatchSize' getParameters
Long Parameter List,BLToolkit.Data.DataProvider,DataReaderBase<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Data.DataProvider,DataReaderBase<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,InsertBatch,The method has 6 parameters. Parameters: db' insertText' collection' members' maxBatchSize' getParameters
Long Parameter List,BLToolkit.Data.DataProvider,BulkCopyReader,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Data.DataProvider,BulkCopyReader,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlList,The method has 5 parameters. Parameters: insertText' collection' members' maxBatchSize' withIdentity
Long Parameter List,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlListUnionAll,The method has 5 parameters. Parameters: insertText' collection' members' maxBatchSize' withIdentity
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildSetter,The method has 6 parameters. Parameters: builder' buildInfo' setter' into' items' sequence
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildSetter,The method has 6 parameters. Parameters: builder' into' items' ctx' expression' path
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The method has 7 parameters. Parameters: builder' buildInfo' extract' update' select' table' items
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The method has 7 parameters. Parameters: builder' buildInfo' extract' update' select' table' items
Long Parameter List,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectComparison,The method has 5 parameters. Parameters: nodeType' leftContext' left' rightContext' right
Long Parameter List,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The method has 5 parameters. Parameters: context' inheritanceMapping' inheritanceDiscriminators' toType' getSql
Long Parameter List,BLToolkit.Data.Linq.Builder,IGroupByHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,Set,The method has 5 parameters. Parameters: wrapInSubQuery' sourceExpression' keySelector' elementSelector' resultSelector
Long Parameter List,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,Set,The method has 5 parameters. Parameters: wrapInSubQuery' sourceExpression' keySelector' elementSelector' resultSelector
Long Parameter List,BLToolkit.Data.Linq.Builder,GroupByContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,GroupByContext,The method has 6 parameters. Parameters: parent' sequenceExpr' groupingType' sequence' key' element
Long Parameter List,BLToolkit.Data.Linq.Builder,GroupByHelper<TKey;TElement;TSource>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,GetGrouping,The method has 8 parameters. Parameters: context' dataContext' dataReader' parameterAccessor' expr' ps' keyReader' itemReader
Long Parameter List,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The method has 8 parameters. Parameters: builder' join' outerKeyContext' outerKeySelector' innerKeyContext' innerKeySelector' countKeyContext' countSql
Long Parameter List,BLToolkit.Data.Linq.Builder,GroupJoinContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,GroupJoinContext,The method has 7 parameters. Parameters: parent' lambda' outerContext' innerContext' innerExpression' outerKeyLambda' innerKeyLambda
Long Parameter List,BLToolkit.Data.Linq.Builder,MethodCallBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,The method has 5 parameters. Parameters: methodCall' sourceTypeNumber' info' param' expression
Long Parameter List,BLToolkit.Data.Linq,CompiledQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,Invoke,The method has 5 parameters. Parameters: dataContext' arg1' arg2' arg3' arg4
Long Parameter List,BLToolkit.Data.Linq,CompiledQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,Invoke,The method has 6 parameters. Parameters: dataContext' arg1' arg2' arg3' arg4' arg5
Long Parameter List,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' millisecond
Long Parameter List,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,MakeDateTime,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,RunQuery,The method has 5 parameters. Parameters: ctx' dataContextInfo' expr' parameters' mapper
Long Parameter List,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,Map,The method has 6 parameters. Parameters: data' queryContext' dataContextInfo' expr' ps' mapper
Long Parameter List,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,Map,The method has 6 parameters. Parameters: data' queryContext' dataContextInfo' expr' ps' mapper
Long Parameter List,BLToolkit.Data.Linq,DatePartAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.cs,DatePartAttribute,The method has 5 parameters. Parameters: sqlProvider' expression' isExpression' datePartIndex' argIndices
Long Parameter List,BLToolkit.Data.Linq,DatePartAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.cs,DatePartAttribute,The method has 6 parameters. Parameters: sqlProvider' expression' isExpression' partMapping' datePartIndex' argIndices
Long Parameter List,BLToolkit.Data.Linq,DatePartAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.cs,DatePartAttribute,The method has 7 parameters. Parameters: sqlProvider' expression' precedence' isExpression' partMapping' datePartIndex' argIndices
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSql,The method has 6 parameters. Parameters: commandNumber' sqlQuery' sb' indent' nesting' skipAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSqlBuilder,The method has 5 parameters. Parameters: sqlQuery' sb' indent' nesting' skipAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 6 parameters. Parameters: sb' expr' buildTableName' checkParentheses' alias' addAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 5 parameters. Parameters: sb' parentPrecedence' expr' alias' addAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildExpression,The method has 6 parameters. Parameters: sb' expr' buildTableName' checkParentheses' alias' addAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildSql,The method has 6 parameters. Parameters: commandNumber' sqlQuery' sb' indent' nesting' skipAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,BuildSql,The method has 6 parameters. Parameters: commandNumber' sqlQuery' sb' indent' nesting' skipAlias
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,ISqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\ISqlProvider.cs,BuildSql,The method has 6 parameters. Parameters: commandNumber' sqlQuery' sb' indent' nesting' skipAlias
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters. Parameters: dbType' type' length' precision' scale
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters. Parameters: dbType' type' length' precision' scale
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters. Parameters: dbType' type' length' precision' scale
Long Parameter List,BLToolkit.Data.Sql,TypeInfo,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,TypeInfo,The method has 5 parameters. Parameters: dbType' maxLength' maxPrecision' maxScale' maxDisplaySize
Long Parameter List,BLToolkit.Data.Sql,SqlBinaryExpression,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlBinaryExpression.cs,SqlBinaryExpression,The method has 5 parameters. Parameters: systemType' expr1' operation' expr2' precedence
Long Parameter List,BLToolkit.Data.Sql,SqlField,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlField.cs,SqlField,The method has 7 parameters. Parameters: systemType' name' physicalName' nullable' pkOrder' nonUpdatableAttribute' memberMapper
Long Parameter List,BLToolkit.Data.Sql,Join,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\Join.cs,Join,The method has 5 parameters. Parameters: joinType' table' alias' isWeak' joins
Long Parameter List,BLToolkit.Data.Sql,SqlParameter,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,SqlParameter,The method has 5 parameters. Parameters: systemType' name' value' mappingSchema' isQueryParameter
Long Parameter List,BLToolkit.Data.Sql,SqlParameter,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,SqlParameter,The method has 5 parameters. Parameters: systemType' name' value' isQueryParameter' valueConverter
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,Init,The method has 13 parameters. Parameters: insert' update' delete' select' from' where' groupBy' having' orderBy' unions' parentSql' parameterDependent' parameters
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSubQuery,The method has 6 parameters. Parameters: source' optimizeWhere' allColumns' isApplySupported' optimizeValues' optimizeColumns
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,CheckColumn,The method has 5 parameters. Parameters: column' expr' query' optimizeValues' optimizeColumns
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,RemoveSubQuery,The method has 5 parameters. Parameters: childSource' concatWhere' allColumns' optimizeValues' optimizeColumns
Long Parameter List,BLToolkit.Data.Sql,SelectClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,Expr,The method has 5 parameters. Parameters: systemType' alias' expr' priority' values
Long Parameter List,BLToolkit.Data.Sql,SelectClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,Expr,The method has 5 parameters. Parameters: alias' expr1' operation' expr2' priority
Long Parameter List,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The method has 11 parameters. Parameters: id' name' alias' database' owner' physicalName' objectType' sequenceAttributes' fields' sqlTableType' tableArguments
Long Parameter List,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters. Parameters: source' visited' path' property' func
Long Parameter List,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters. Parameters: source' visited' path' property' func
Long Parameter List,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters. Parameters: expr' visited' path' property' func
Long Parameter List,BLToolkit.Mapping,Association,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Association.cs,Association,The method has 5 parameters. Parameters: memberAccessor' thisKey' otherKey' storage' canBeNull
Long Parameter List,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The method has 7 parameters. Parameters: source' dtype' checkNull' nullValue' destMapValues' defaultValue' srcMapValues
Long Parameter List,BLToolkit.Mapping,IValueConvertHelper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,CheckNull,The method has 6 parameters. Parameters: mapper' source' nullValue' mapValues' defaultValue' srcMapValues
Long Parameter List,BLToolkit.Mapping,IValueConvertHelper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,SourceMapValues,The method has 5 parameters. Parameters: mapper' source' nullValue' defaultValue' srcMapValues
Long Parameter List,BLToolkit.Mapping,IValueConvertHelper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,DestMapValues,The method has 5 parameters. Parameters: mapper' source' nullValue' mapValues' defaultValue
Long Parameter List,BLToolkit.Mapping,ValueConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,CheckNull,The method has 6 parameters. Parameters: mapper' source' nullValue' mapValues' defaultValue' srcMapValues
Long Parameter List,BLToolkit.Mapping,ValueConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,SourceMapValues,The method has 5 parameters. Parameters: mapper' source' nullValue' defaultValue' srcMapValues
Long Parameter List,BLToolkit.Mapping,ValueConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,DestMapValues,The method has 5 parameters. Parameters: mapper' source' nullValue' mapValues' defaultValue
Long Parameter List,BLToolkit.Mapping,ConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,MapCrossReferences,The method has 5 parameters. Parameters: ctx' source' func' getCurrent' setCurrent
Long Parameter List,BLToolkit.Mapping,DefaultValueMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ValueMapping.cs,Map,The method has 6 parameters. Parameters: source' sourceObject' sourceIndex' dest' destObject' destIndex
Long Parameter List,BLToolkit.Mapping,ValueMapper<T>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ValueMapping.cs,Map,The method has 6 parameters. Parameters: source' sourceObject' sourceIndex' dest' destObject' destIndex
Long Parameter List,BLToolkit.Mapping,ValueMapper<S;D>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ValueMapping.cs,Map,The method has 6 parameters. Parameters: source' sourceObject' sourceIndex' dest' destObject' destIndex
Long Parameter List,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.Mapping,IValueMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\IValueMapper.cs,Map,The method has 6 parameters. Parameters: source' sourceObject' sourceIndex' dest' destObject' destIndex
Long Parameter List,BLToolkit.Mapping,NullDateTimeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\NullDateTimeAttribute.cs,NullDateTimeAttribute,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,BLToolkit.Mapping,NullDateTimeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\NullDateTimeAttribute.cs,NullDateTimeAttribute,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' millisecond
Long Parameter List,BLToolkit.Mapping,NullDecimalAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\NullDecimalAttribute.cs,NullDecimalAttribute,The method has 5 parameters. Parameters: lo' mid' hi' isNegative' scale
Long Parameter List,BLToolkit.Mapping,NullGuidAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\NullGuidAttribute.cs,NullGuidAttribute,The method has 11 parameters. Parameters: a' b' c' d' e' f' g' h' i' j' k
Long Parameter List,BLToolkit.Mapping,NullGuidAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\NullGuidAttribute.cs,NullGuidAttribute,The method has 11 parameters. Parameters: a' b' c' d' e' f' g' h' i' j' k
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,MapSourceToDestination,The method has 5 parameters. Parameters: source' sourceObject' dest' destObject' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,ListToDictionary,The method has 5 parameters. Parameters: sourceList' destDictionary' keyField' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,ListToDictionary,The method has 5 parameters. Parameters: sourceList' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToList,The method has 5 parameters. Parameters: sourceTable' version' list' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToDictionary,The method has 5 parameters. Parameters: sourceTable' destDictionary' keyField' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToDictionary,The method has 5 parameters. Parameters: sourceTable' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataReaderToDictionary,The method has 5 parameters. Parameters: dataReader' destDictionary' keyField' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataReaderToDictionary,The method has 5 parameters. Parameters: dataReader' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DictionaryToDictionary,The method has 5 parameters. Parameters: sourceDictionary' destDictionary' keyField' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,Map,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DictionaryToDictionary,The method has 5 parameters. Parameters: sourceDictionary' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MapNextResult,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapNextResult.cs,MapNextResult,The method has 5 parameters. Parameters: type' slaveIndex' masterIndex' containerName' nextResults
Long Parameter List,BLToolkit.Mapping,MapNextResult,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapNextResult.cs,MapNextResult,The method has 5 parameters. Parameters: type' slaveIndex' masterIndex' containerName' nextResults
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 5 parameters. Parameters: source' sourceObject' dest' destObject' index
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 6 parameters. Parameters: source' sourceObject' dest' destObject' index' mappers
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 6 parameters. Parameters: initContext' source' sourceObject' dest' destObject' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapSourceToDestination,The method has 5 parameters. Parameters: source' sourceObject' dest' destObject' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The method has 5 parameters. Parameters: sourceList' destDictionary' keyFieldNameOrIndex' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The method has 5 parameters. Parameters: sourceList' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The method has 5 parameters. Parameters: sourceTable' version' list' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The method has 5 parameters. Parameters: sourceTable' destDictionary' keyFieldNameOrIndex' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The method has 5 parameters. Parameters: sourceTable' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters. Parameters: reader' destDictionary' keyFieldNameOrIndex' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters. Parameters: reader' destDictionary' keyFieldNameOrIndex' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters. Parameters: reader' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters. Parameters: reader' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The method has 5 parameters. Parameters: sourceDictionary' destDictionary' keyFieldNameOrIndex' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The method has 5 parameters. Parameters: sourceDictionary' destDictionary' index' destObjectType' parameters
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 5 parameters. Parameters: origValue' value1' value2' value3' value4
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 6 parameters. Parameters: origValue' value1' value2' value3' value4' value5
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 5 parameters. Parameters: type' origValue' value1' value2' value3
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 6 parameters. Parameters: type' origValue' value1' value2' value3' value4
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 7 parameters. Parameters: type' origValue' value1' value2' value3' value4' value5
Long Parameter List,BLToolkit.Reflection,GenericBinder,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\GenericBinder.cs,BindToMethod,The method has 7 parameters. Parameters: bindingAttr' match' args' modifiers' culture' names' state
Long Parameter List,BLToolkit.Reflection,GenericBinder,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\GenericBinder.cs,SelectProperty,The method has 5 parameters. Parameters: bindingAttr' match' returnType' indexes' modifiers
Long Parameter List,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMethod,The method has 5 parameters. Parameters: type' methodName' bindingFlags' requiredParametersCount' parameterTypes
Long Parameter List,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetExtendedProperties,The method has 6 parameters. Parameters: pdc' itemType' propertyPrefix' parentTypes' parentAccessors' isNull
Long Parameter List,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The method has 5 parameters. Parameters: schema' typeExt' master' slave' isSet
Long Parameter List,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,The method has 5 parameters. Parameters: schema' typeExt' master' slave' isSet
Long Parameter List,BLToolkit.Reflection.MetadataProvider,MetadataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\MetadataProviderBase.cs,GetRelations,The method has 5 parameters. Parameters: schema' typeExt' master' slave' isSet
Long Parameter List,BLToolkit.Reflection.MetadataProvider,MetadataProviderList,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\MetadataProviderList.cs,GetRelations,The method has 5 parameters. Parameters: schema' typeExt' master' slave' isSet
Long Parameter List,BLToolkit.ServiceModel,ServiceModelDataReader,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.ServiceModel,ServiceModelDataReader,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 5 parameters. Parameters: propertyType' instanceType' parameter1' parameter2' parameter3
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 6 parameters. Parameters: propertyType' instanceType' parameter1' parameter2' parameter3' parameter4
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 7 parameters. Parameters: propertyType' instanceType' parameter1' parameter2' parameter3' parameter4' parameter5
Long Parameter List,BLToolkit.TypeBuilder,InstanceTypeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\InstanceTypeAttribute.cs,InstanceTypeAttribute,The method has 5 parameters. Parameters: instanceType' parameter1' parameter2' parameter3' parameter4
Long Parameter List,BLToolkit.TypeBuilder,InstanceTypeAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\InstanceTypeAttribute.cs,InstanceTypeAttribute,The method has 6 parameters. Parameters: instanceType' parameter1' parameter2' parameter3' parameter4' parameter5
Long Parameter List,BLToolkit.TypeBuilder,ParameterAttribute,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\ParameterAttribute.cs,ParameterAttribute,The method has 5 parameters. Parameters: parameter1' parameter2' parameter3' parameter4' parameter5
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,The method has 5 parameters. Parameters: field' fieldType' objectType' emit' parameters
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateAbstractInitContextInstance,The method has 5 parameters. Parameters: field' fieldType' objectType' emit' parameters
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextDefaultInstance,The method has 6 parameters. Parameters: initContextName' field' fieldType' objectType' emit' parameters
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextLazyInstance,The method has 5 parameters. Parameters: field' fieldType' objectType' emit' parameters
Long Parameter List,BLToolkit.TypeBuilder.Builders,FakeMethodInfo,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\FakeMethodInfo.cs,Invoke,The method has 5 parameters. Parameters: obj' invokeAttr' binder' parameters' culture
Long Parameter List,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,MarkSequencePoint,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,BLToolkit.Reflection.Emit,MethodBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\MethodBuilderHelper.cs,MethodBuilderHelper,The method has 5 parameters. Parameters: typeBuilder' methodBuilder' genericArguments' returnType' parameterTypes
Long Parameter List,BLToolkit.Reflection.Emit,TypeBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The method has 5 parameters. Parameters: name' attributes' callingConvention' returnType' parameterTypes
Long Parameter List,BLToolkit.Reflection.Emit,TypeBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineGenericMethod,The method has 6 parameters. Parameters: name' attributes' callingConvention' genericArguments' returnType' parameterTypes
Long Parameter List,BLToolkit.Validation,MaxDateValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Validation\MaxDateValueAttribute.cs,MaxDateValueAttribute,The method has 5 parameters. Parameters: year' month' day' isExclusive' errorMessage
Long Parameter List,BLToolkit.Validation,MinDateValueAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Validation\MinDateValueAttribute.cs,MinDateValueAttribute,The method has 5 parameters. Parameters: year' month' day' isExclusive' errorMessage
Long Identifier,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetSpParameters,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data.Linq,MapSchema,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\ReflectionHelper.cs,,The length of the parameter MapValueToEnumWithMemberAccessor is 32.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildAbstractMethod,The length of the statement  "					throw new TypeBuilderException(string.Format("Method '{0}.{1}' is not a 'Begin' nor an 'End' method."' mi.DeclaringType.FullName' mi.Name)); " is 140.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The length of the statement  "				const MethodAttributes     ma  = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual; " is 140.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The length of the statement  "					TypeAttributes.Class | TypeAttributes.NotPublic | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass' " is 126.
Long Statement,BLToolkit.Aspects.Builders,OverloadAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,GetOverloadedMethod,The length of the statement  "			const BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Instance| BindingFlags.Public | BindingFlags.NonPublic; " is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.LocalDateTime;                                                                                                  }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return DateTime.MinValue + TimeSpan.FromDays (p);                                                                        }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return DateTime.MinValue + TimeSpan.FromTicks(p);                                                                        }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p == null ? Configuration.NullableValues.DateTime : DateTime.Parse(p' null' DateTimeStyles.NoCurrentDateDefault); }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return DateTime.MinValue + p;                                                                                            }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.HasValue ? p.Value : Configuration.NullableValues.DateTime;                                                     }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.HasValue ?                     p.Value.LocalDateTime : Configuration.NullableValues.DateTime;                   }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.HasValue ? DateTime.MinValue + TimeSpan.FromDays (p.Value): Configuration.NullableValues.DateTime;              }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.HasValue ? DateTime.MinValue + TimeSpan.FromTicks(p.Value): Configuration.NullableValues.DateTime;              }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.HasValue ? DateTime.MinValue +                    p.Value : Configuration.NullableValues.DateTime;              }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p == null || p.Length == 0 ? Configuration.NullableValues.DateTime : DateTime.FromBinary(ToInt64(p.ToArray()));   }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p == null || p.Length == 0 ? Configuration.NullableValues.DateTime : DateTime.FromBinary(ToInt64(p));             }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.IsNull ? Configuration.NullableValues.DateTime : p.Value;                                                       }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.DateTime : DateTime.MinValue + TimeSpan.FromDays (p.Value);             }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.DateTime : DateTime.MinValue + TimeSpan.FromTicks(p.Value);             }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.DateTime :                             ToDateTime(p.Value);             }" is 124.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p - DateTime.MinValue;                                                                                        }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p - DateTimeOffset.MinValue;                                                                                  }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return TimeSpan.FromDays (p);                                                                                        }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return TimeSpan.FromTicks(p);                                                                                        }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p == null? Configuration.NullableValues.TimeSpan : TimeSpan.Parse(p);                                         }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.HasValue ? p.Value - DateTime.MinValue       : Configuration.NullableValues.TimeSpan;                       }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.HasValue ? p.Value - DateTimeOffset.MinValue : Configuration.NullableValues.TimeSpan;                       }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.HasValue ? TimeSpan.FromDays (p.Value)            : Configuration.NullableValues.TimeSpan;                  }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.HasValue ? TimeSpan.FromTicks(p.Value)            : Configuration.NullableValues.TimeSpan;                  }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.HasValue ? p.Value : Configuration.NullableValues.TimeSpan;                                                 }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p == null || p.Length == 0? Configuration.NullableValues.TimeSpan : TimeSpan.FromTicks(ToInt64(p.ToArray())); }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p == null || p.Length == 0? Configuration.NullableValues.TimeSpan : TimeSpan.FromTicks(ToInt64(p));           }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.TimeSpan : p.Value - DateTime.MinValue;                             }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.TimeSpan : TimeSpan.FromDays(p.Value);                              }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.TimeSpan : TimeSpan.FromTicks(p.Value);                             }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "{ return p.IsNull   ? Configuration.NullableValues.TimeSpan : TimeSpan.Parse(p.Value);                                 }" is 120.
Long Statement,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,CreateInvalidCastException,The length of the statement  "			return new InvalidCastException(string.Format(Resources.Convert_InvalidCast' originalType.FullName' conversionType.FullName)); " is 126.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDictionaryWithScalarKey,The length of the statement  "					.callvirt(typeof(DbManager)' "ExecuteDictionary"' typeof(IDictionary)' typeof(NameOrIndexParameter)' typeof(Type)' typeof(object[])) " is 132.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,The length of the statement  "					.callvirt(_baseType' "ConvertChangeType"' _bindingFlags' typeof(DbManager)' typeof(object)' typeof(Type)' typeof(object)) " is 121.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "						.callvirt(_baseType' "ConvertChangeType"' _bindingFlags' typeof(DbManager)' typeof(object)' typeof(Type)' typeof(object)) " is 121.
Long Statement,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "						throw new ArgumentException(string.Format("Parsing for {0} failed: {1}"' spName' GetMissedColumnNames(index' commandParameters))); " is 130.
Long Statement,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "				throw new ArgumentException(string.Format("Parsing for {0} failed: {1}"' spName' GetExceedParameters(nValues' parameterValues))); " is 129.
Long Statement,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "//						value == null || (mm.MapMemberInfo.Nullable && !TypeHelper.IsNullable(mm.MapMemberInfo.Type)  && _mappingSchema.IsNull(value))? " is 135.
Long Statement,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteArray,The length of the statement  "			return ExecuteOperation<int>(OperationType.ExecuteNonQuery' () => DataProvider.ExecuteArray(SelectCommand' iterations)); " is 120.
Long Statement,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteNonQuery,The length of the statement  "				WriteTraceLine(string.Format("Execution time: {0}. Records affected: {1}.\r\n"' DateTime.Now - now' n)' TraceSwitch.DisplayName); " is 129.
Long Statement,BLToolkit.Data.DataProvider,DataProviderVersionResolverBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderVersionResolverBase.cs,AddDataProvider,The length of the statement  "					string.Format(Resources.DataProviderVersionResolverBase_InvalidProviderType' providerType.FullName' _baseProviderType.FullName)); " is 129.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The length of the statement  "                    "Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};"' " is 154.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The length of the statement  "                    "Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Pooling=False;"' " is 168.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The length of the statement  "                    "Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Connection Timeout={5};"' " is 177.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The length of the statement  "                    "Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Connection Timeout={5};Pooling=False;"' " is 191.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,The length of the statement  "                    "Number of parameters in query is not equals to number of parameters set in the command object : " + poCommand.CommandText + "\r\n" + " is 133.
Long Statement,BLToolkit.Data.DataProvider,AccessDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The length of the statement  "					_paramsExp = new Regex(@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture); " is 173.
Long Statement,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,InsertBatch,The length of the statement  "			var bc  = new SqlBulkCopy((SqlConnection)db.Connection' SqlDataProvider.SqlBulkCopyOptions' (SqlTransaction)db.Transaction) " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,ConcatUnionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,BuildMethodCall,The length of the statement  "			var sequence2 = new SubQueryContext(builder.BuildSequence(new BuildInfo(buildInfo' methodCall.Arguments[1]' new SqlQuery()))); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,GetTypeNames,The length of the statement  "			return types.Select(GetTypeName).Aggregate(""' (t1't2) => t1 + separator + t2' p => p.TrimStart(separator.ToCharArray())); " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter) " is 135.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "				case 3 : // static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter) " is 144.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "			return new InsertContext(buildInfo.Parent' sequence' sequence.SqlQuery.Insert.WithIdentity || sequence.SqlQuery.Insert.WithOutput); " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,Into,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "				// static ISelectInsertable<TSource'TTarget> Into<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target) " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,AggregationContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,CheckNullValue,The length of the statement  "					throw new InvalidOperationException(string.Format("Function {0} returns non-nullable value' but result is NULL. Use nullable version of the function instead."' context)); " is 170.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ExposeExpression,The length of the statement  "								var ex   = body.Convert2(wpi => new ExpressionHelper.ConvertInfo(wpi.NodeType == ExpressionType.Parameter ? me.Expression : wpi)); " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The length of the statement  "			var elementSelector  = types.ContainsKey("TElement") ? (LambdaExpression)OptimizeExpression(method.Arguments[2].Unwrap()) : null; " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.AddChecked      : return Convert(context' new SqlBinaryExpression(t' l' "+"' r' Precedence.Additive)); " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.And             : return Convert(context' new SqlBinaryExpression(t' l' "&"' r' Precedence.Bitwise)); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.Divide          : return Convert(context' new SqlBinaryExpression(t' l' "/"' r' Precedence.Multiplicative)); " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.ExclusiveOr     : return Convert(context' new SqlBinaryExpression(t' l' "^"' r' Precedence.Bitwise)); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.Modulo          : return Convert(context' new SqlBinaryExpression(t' l' "%"' r' Precedence.Multiplicative)); " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.MultiplyChecked : return Convert(context' new SqlBinaryExpression(t' l' "*"' r' Precedence.Multiplicative)); " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.Or              : return Convert(context' new SqlBinaryExpression(t' l' "|"' r' Precedence.Bitwise)); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "							case ExpressionType.SubtractChecked : return Convert(context' new SqlBinaryExpression(t' l' "-"' r' Precedence.Subtraction)); " is 125.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "//			if (left.NodeType == ExpressionType.Convert && left.Type == typeof(int?) && right.NodeType == ExpressionType.Convert) " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "					if (!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull() || r is SqlParameter && r.CanBeNull())) " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetParameter,The length of the statement  "			var expr   = Expression.MakeMemberAccess(par.Type == typeof(object) ? Expression.Convert(par' member.DeclaringType) : par' member); " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetParameter,The length of the statement  "				SqlParameter = new SqlParameter(expr.Type' member.Name' null' MappingSchema' !DataContextInfo.DataContext.InlineParameters) " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The length of the statement  "					SqlParameter = new SqlParameter(ep.Expression.Type' p.Name' p.Value' !DataContextInfo.DataContext.InlineParameters' GetLikeEscaper(start' end)) " is 143.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "			var table       = new TableBuilder.TableContext(this' new BuildInfo((IBuildContext)null' Expression.Constant(null)' new SqlQuery())' typeOperand); " is 146.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "			var mapping = table.InheritanceMapping.Select((m'i) => new { m' i }).Where(m => m.m.Type == typeOperand && !m.m.IsDefault).ToList(); " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSearchCondition,The length of the statement  "					return Convert(context' new SqlFunction(sqlExpression.SystemType' "CASE"' sqlExpression' new SqlValue(1)' notExpr' new SqlValue(0)' new SqlValue(null))); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSearchCondition,The length of the statement  "				return Convert(context' new SqlFunction(sqlExpression.SystemType' "CASE"' sqlExpression' new SqlValue(1)' new SqlValue(0))); " is 124.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,The length of the statement  "						foreach (var binding in expr.Bindings.Cast<MemberAssignment>().OrderBy(b => dic.ContainsKey(b.Member.Name) ? dic[b.Member.Name] : 1000000)) " is 139.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsNoneSqlMember,The length of the statement  "						return om != null && om.Associations.All(a => !TypeHelper.Equals(a.MemberAccessor.MemberInfo' me.Member)) && om[me.Member.Name' true] == null; " is 142.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The length of the statement  "				throw new LinqException("Multiple queries are not allowed. Set the 'BLToolkit.Common.Configuration.Linq.AllowMultipleQuery' flag to 'true' to allow multiple queries."); " is 168.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,AddElementSelectorQ,The length of the statement  "				Expression<Func<IQueryable<TSource>'TKey'TElement'TResult'IQueryable<IGrouping<TKey'TSource>>>> func = (source'key'e'r) => source " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,AddElementSelectorE,The length of the statement  "				Expression<Func<IEnumerable<TSource>'TKey'TElement'TResult'IEnumerable<IGrouping<TKey'TSource>>>> func = (source'key'e'r) => source " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryQ,The length of the statement  "				Expression<Func<IQueryable<TSource>'TKey'TElement'TResult'IQueryable<IGrouping<TKey'TElement>>>> func = (source'key'e'r) => source " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryE,The length of the statement  "				Expression<Func<IEnumerable<TSource>'TKey'TElement'TResult'IEnumerable<IGrouping<TKey'TElement>>>> func = (source'key'e'r) => source " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,FirstSingleContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildQuery,The length of the statement  "					case "First"           : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).First();           break; " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,FirstSingleContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildQuery,The length of the statement  "					case "FirstOrDefault"  : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).FirstOrDefault();  break; " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,FirstSingleContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildQuery,The length of the statement  "					case "Single"          : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).Single();          break; " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,FirstSingleContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildQuery,The length of the statement  "					case "SingleOrDefault" : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).SingleOrDefault(); break; " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,CanBuildMethodCall,The length of the statement  "					throw new NotSupportedException(string.Format("Explicit construction of entity type '{0}' in group by is not allowed."' body.Type)); " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,ConvertToParentIndex,The length of the statement  "				if (!SqlQuery.GroupBy.Items.Exists(_ => _ == expr || (expr is SqlQuery.Column && _ == ((SqlQuery.Column)expr).Expression))) " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByHelper<TKey;TElement;TSource>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,GetGrouping,The length of the statement  "						ReflectionHelper.Expressor<object>.MethodExpressor(_ => Queryable.Select(null' (Expression<Func<TSource'TElement>>)null))' " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,CanBuildMethodCall,The length of the statement  "					throw new NotSupportedException(string.Format("Explicit construction of entity type '{0}' in join is not allowed."' body.Type)); " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The length of the statement  "						throw new LinqException(string.Format("List of member inits does not match for entity type '{0}'."' outerKeySelector.Type)); " is 124.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The length of the statement  "				BuildJoin(builder' join' outerKeyContext' outerKeySelector' innerKeyContext' innerKeySelector' countKeyContext' counterSql); " is 124.
Long Statement,BLToolkit.Data.Linq.Builder,OrderByBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\OrderByBuilder.cs,CanBuildMethodCall,The length of the statement  "					throw new NotSupportedException(string.Format("Explicit construction of entity type '{0}' in order by is not allowed."' body.Type)); " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,IsExpression,The length of the statement  "				case RequestFor.Root        : return new IsExpressionResult(Lambda.Parameters.Count > 0 && expression == Lambda.Parameters[0]); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,CheckExpression,The length of the statement  "				expression.Sql = Builder.Convert(this' new SqlFunction(typeof(bool)' "CASE"' expression.Sql' new SqlValue(true)' new SqlValue(false))); " is 135.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext2,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,BuildQuery,The length of the statement  "				Func<QueryContext'IDataContext'IDataReader'Expression'object[]'int'T> map = (ctx'db'rd'e'ps'n) => func(n' ctx' db' rd' e' ps); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The length of the statement  "					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType); " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,DefaultInheritanceMappingException,The length of the statement  "				throw new LinqException("Inheritance mapping is not defined for discriminator value '{0}' in the '{1}' hierarchy."' value' type); " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildQuery,The length of the statement  "					var exceptionMethod = ReflectionHelper.Expressor<object>.MethodExpressor(_ => DefaultInheritanceMappingException(null' null)); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetField,The length of the statement  "									var mi = SqlTable.ObjectType.GetMember(levelMember.Member.Name' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 134.
Long Statement,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetField,The length of the statement  "								if (TypeHelper.Equals(field.MemberMapper.MapMemberInfo.MemberAccessor.MemberInfo' memberExpression.Member' SqlTable.ObjectType)) " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,GetAssociation,The length of the statement  "							return new TableLevel { Table = tableAssociation' Field = field' Level = field == null ? level : level + 1' IsNew = isNew }; " is 124.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Like,The length of the statement  "			return matchExpression == null || pattern == null ? false : System.Data.Linq.SqlClient.SqlMethods.Like(matchExpression' pattern); " is 129.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The length of the statement  "			return year == null || month == null || day == null || hour == null || minute == null || second == null || millisecond == null ? " is 128.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The length of the statement  "				case DateParts.Week        : return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear(date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday); " is 143.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Round,The length of the statement  "			return value == null || precision == null? null : (Decimal?)Math.Round(value.Value' precision.Value' MidpointRounding.AwayFromZero); " is 132.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Round,The length of the statement  "			return value == null || precision == null? null : (Double?) Math.Round(value.Value' precision.Value' MidpointRounding.AwayFromZero); " is 132.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,RoundToEven,The length of the statement  "			return value == null || precision == null? null : (Decimal?)Math.Round(value.Value' precision.Value' MidpointRounding.ToEven); " is 126.
Long Statement,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,RoundToEven,The length of the statement  "			return value == null || precision == null? null : (Double?) Math.Round(value.Value' precision.Value' MidpointRounding.ToEven); " is 126.
Long Statement,BLToolkit.Data.Linq,ExpressionQuery<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\ExpressionQuery.cs,CreateQuery,The length of the statement  "				return (IQueryable)Activator.CreateInstance(typeof(ExpressionQueryImpl<>).MakeGenericType(elementType)' new object[] { DataContextInfo' expression }); " is 150.
Long Statement,BLToolkit.Data.Linq,Expressions,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,ConvertMember,The length of the statement  "				if (mi is MethodInfo && mi.Name == "CompareString" && mi.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.Operators") " is 134.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "					((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(new[] { typeof(TSource)' typeof(TTarget)' typeof(TValue) })' " is 122.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "					((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(new[] { typeof(TSource)' typeof(TTarget)' typeof(TValue) })' " is 122.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "					((MethodInfo)MethodBase.GetCurrentMethod()).MakeGenericMethod(new[] { typeof(TSource)' typeof(TTarget)' typeof(TValue) })' " is 122.
Long Statement,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetQuery,The length of the statement  "									"To generate test code to diagnose the problem set 'BLToolkit.Common.Configuration.Linq.GenerateExpressionTest = true'."' " is 121.
Long Statement,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The length of the statement  "				SqlParameter = new SqlParameter(field.SystemType' field.Name.Replace('.'' '_')' null' dataContext.MappingSchema' !dataContext.InlineParameters) " is 143.
Long Statement,BLToolkit.Data.Linq,SqlExpressionAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\SqlExpressionAttribute.cs,GetExpression,The length of the statement  "			return new SqlExpression(TypeHelper.GetMemberType(member)' Expression ?? member.Name' Precedence' ConvertArgs(member' args)); " is 125.
Long Statement,BLToolkit.Data.Linq,SqlFunctionAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\SqlFunctionAttribute.cs,ConvertArgs,The length of the statement  "					args = args.Concat(method.DeclaringType.GetGenericArguments().Select(t => (ISqlExpression)SqlDataType.GetDataType(t))).ToArray(); " is 129.
Long Statement,BLToolkit.Data.Linq,TableFunctionAttribute,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\TableFunctionAttribute.cs,ConvertArgs,The length of the statement  "					args = args.Concat(method.DeclaringType.GetGenericArguments().Select(t => (ISqlExpression)SqlDataType.GetDataType(t))).ToArray(); " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120)); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeConvertToBoolean,The length of the statement  "					new SqlQuery.Condition(false' new SqlQuery.Predicate.ExprExpr(par' SqlQuery.Predicate.Operator.Equal' new SqlValue(0)))); " is 121.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.SqlField     : ((SqlField)            e).Alias = SetAlias(((SqlField)            e).Alias' maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.SqlParameter : ((SqlParameter)        e).Name  = SetAlias(((SqlParameter)        e).Name'  maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.SqlTable     : ((SqlTable)            e).Alias = SetAlias(((SqlTable)            e).Alias' maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.Join         : ((Join)                e).Alias = SetAlias(((Join)                e).Alias' maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.Column       : ((SqlQuery.Column)     e).Alias = SetAlias(((SqlQuery.Column)     e).Alias' maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The length of the statement  "					case QueryElementType.TableSource  : ((SqlQuery.TableSource)e).Alias = SetAlias(((SqlQuery.TableSource)e).Alias' maxLen); break; " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The length of the statement  "						var database     = tbl.Database     == null ? null : Convert(tbl.Database'     ConvertType.NameToDatabase).  ToString(); " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The length of the statement  "						var owner        = tbl.Owner        == null ? null : Convert(tbl.Owner'        ConvertType.NameToOwner).     ToString(); " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The length of the statement  "						var physicalName = tbl.PhysicalName == null ? null : Convert(tbl.PhysicalName' ConvertType.NameToQueryTable).ToString(); " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType); " is 132.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType); " is 132.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildAnyAsCount,The length of the statement  "			_selectColumn = new SqlQuery.Column(SqlQuery' new SqlExpression(cond.Conditions[0].IsNot ? "Count(*) = 0" : "Count(*) > 0")' SqlQuery.Select.Columns[0].Alias); " is 159.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The length of the statement  "							return new SqlFunction(func.SystemType' func.Name' func.Parameters[0]' new SqlFunction(func.SystemType' func.Name' parms)); " is 123.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The length of the statement  "			return new SqlFunction(systemType' "Iif"' parameters[start]' parameters[start + 1]' ConvertCase(systemType' parameters' start + 2)); " is 132.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120)); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The length of the statement  "						if ((ftype == typeof(double) || ftype == typeof(float)) && TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(decimal)) " is 138.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]); " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,Convert,The length of the statement  "						str = (str.Length > 0 && (str[0] == ParameterSymbol || (TryConvertParameterSymbol && ConvertParameterSymbols.Contains(str[0])))) ? str.Substring(1) : str; " is 154.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]); " is 122.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "					return Inc(Div(Dec(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3)); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression(e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters); " is 130.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul(e.Parameters[0]' 3)' e.Parameters[1]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Day')"'   Precedence.Primary' Mul(e.Parameters[0]' 7)' e.Parameters[1]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]); " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]); " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]); " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12)); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3)); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]); " is 122.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000); " is 124.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale)); " is 143.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4)); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4)); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr; " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "										return new SqlExpression(func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters[1]); " is 130.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "								"((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"' " is 163.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "					case "Second"   : return new SqlExpression(func.SystemType' string.Format("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters); " is 151.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "							newElement = new SqlBinaryExpression(bexpr.SystemType' expr1 ?? bexpr.Expr1' bexpr.Operation' expr2 ?? bexpr.Expr2' bexpr.Precedence); " is 134.
Long Statement,BLToolkit.Data.Sql,SqlParameter,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,Clone,The length of the statement  "				var p = new SqlParameter(SystemType' Name' _value' IsQueryParameter' ValueConverter) { DbType = DbType' DbSize = DbSize }; " is 122.
Long Statement,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeUnions,The length of the statement  "				if (sql == null || sql.From.Tables.Count != 1 || !sql.IsSimple || sql._insert != null || sql._update != null || sql._delete != null) " is 132.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "						if (e1.Initializers.Count != e2.Initializers.Count || !Compare(e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic)) " is 130.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "						if (e1.Bindings.Count != e2.Bindings.Count || !Compare(e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic)) " is 122.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "				func(item' Expression.Call(prop' ReflectionHelper.IndexExpressor<T>.Item' new Expression[] { Expression.Constant(i++) })); " is 122.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "				Path(item' visited' Expression.Call(prop' ReflectionHelper.IndexExpressor<T>.Item' new Expression[] { Expression.Constant(i++) })' func); " is 137.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The length of the statement  "								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break; " is 120.
Long Statement,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The length of the statement  "								case MemberBindingType.ListBinding   : return Find(((MemberListBinding)b).  Initializers' p => Find(p.Arguments' func)); " is 120.
Long Statement,BLToolkit.Mapping,ValueConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,SourceMapValues,The length of the statement  "						Expression.Equal(param ?? source' mapper.GetValueMapper(Expression.Constant(value.OrigValue)' typeof(TS)' false' null' null' null' null))' " is 138.
Long Statement,BLToolkit.Mapping,ValueConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,DestMapValues,The length of the statement  "						var ex = Expression.Equal(param ?? source' mapper.GetValueMapper(Expression.Constant(mapValue)' typeof (TS)' false' null' null' null' null)); " is 141.
Long Statement,BLToolkit.Mapping,ConvertHelper<TS;TD>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,MapObjects,The length of the statement  "					return Expression.Call((MethodInfo)ReflectionHelper.MemeberInfo(func)' source' Expression.Lambda<Func<TS'TD>>(expr' param)); " is 124.
Long Statement,BLToolkit.Mapping,ClassItemHelper<TSourceItem;TDestItem>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetObjectListInfo,The length of the statement  "					var method = typeof(ClassItemHelper<TSourceItem'TDestItem>).GetMethod("MapObjectList"' BindingFlags.NonPublic | BindingFlags.Static); " is 133.
Long Statement,BLToolkit.Mapping,ItemHelper<TSourceItem;TDestItem>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,MapLists,The length of the statement  "						var method = typeof (ItemHelper<TSourceItem' TDestItem>).GetMethod("MapScalarList"' BindingFlags.NonPublic | BindingFlags.Static); " is 130.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetSByte,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultSByteNullValue:    _mapper.GetSByte   (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetInt16,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultInt16NullValue:    _mapper.GetInt16   (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetInt32,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultInt32NullValue:    _mapper.GetInt32   (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetInt64,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultInt64NullValue:    _mapper.GetInt64   (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetByte,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultByteNullValue:     _mapper.GetByte    (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetUInt16,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultUInt16NullValue:   _mapper.GetUInt16  (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetUInt32,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultUInt32NullValue:   _mapper.GetUInt32  (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetUInt64,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultUInt64NullValue:   _mapper.GetUInt64  (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetBoolean,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultBooleanNullValue:  _mapper.GetBoolean (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetChar,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultCharNullValue:     _mapper.GetChar    (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetSingle,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultSingleNullValue:   _mapper.GetSingle  (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetDouble,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultDoubleNullValue:   _mapper.GetDouble  (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetDecimal,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultDecimalNullValue:  _mapper.GetDecimal (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetGuid,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultGuidNullValue:     _mapper.GetGuid    (obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetDateTime,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultDateTimeNullValue: _mapper.GetDateTime(obj); }" is 127.
Long Statement,BLToolkit.Mapping,ComplexMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.cs,GetDateTimeOffset,The length of the statement  "{ var obj = MemberAccessor.GetValue(o); return obj == null? MappingSchema.DefaultDateTimeOffsetNullValue: _mapper.GetDateTimeOffset(obj); }" is 139.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetSortComparer,The length of the statement  "							sorts[i] = new ListSortDescription(((SortSubstitutionPair)_sortSubstitutions[sorts[i].PropertyDescriptor.Name]).Substitute'  " is 123.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,CreateSortSubstitution,The length of the statement  "			if (originalDescriptor == null)   throw new InvalidOperationException("Can not retrieve PropertyDescriptor for original property: " + originalProperty); " is 152.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,CreateSortSubstitution,The length of the statement  "			if (substituteDescriptor == null) throw new InvalidOperationException("Can not retrieve PropertyDescriptor for substitute property: " + substituteProperty); " is 156.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,OnMoveItem,The length of the statement  "			OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Move' item' newIndex' oldIndex)); " is 120.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,OnChangeItem,The length of the statement  "			OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' oldValue' newValue' index)); " is 124.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,C:\repos\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Reverse,The length of the statement  "				throw new InvalidOperationException("Reverse is not supported for already sorted arrays. Invoke IBindingList.RemoveSort() first or provide reverse sort direction."); " is 165.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,C:\repos\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Reverse,The length of the statement  "				throw new InvalidOperationException("Range Reverse is not supported for already sorted arrays. Invoke IBindingList.RemoveSort() first."); " is 137.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,C:\repos\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Sort,The length of the statement  "				throw new InvalidOperationException("Custom sorting is not supported on already sorted arrays. Invoke IBindingList.RemoveSort first."); " is 135.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,C:\repos\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Sort,The length of the statement  "				throw new InvalidOperationException("Custom sorting is not supported on already sorted arrays. Invoke IBindingList.RemoveSort first."); " is 135.
Long Statement,BLToolkit.Patterns,DuckTyping,C:\repos\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,GetDuckType,The length of the statement  "			if (!interfaceType.IsInterface) throw new ArgumentException(Resources.DuckTyping_InterfaceTypeMustBeAnInterface' "interfaceType"); " is 130.
Long Statement,BLToolkit.Patterns,DuckTyping,C:\repos\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,Implement,The length of the statement  "				throw new ArgumentException(string.Format(Resources.DuckTyping_NotASubtypeOf' objType.FullName' baseObjectType.FullName)' "obj"); " is 129.
Long Statement,BLToolkit.Patterns,DuckTyping,C:\repos\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,GetDuckType,The length of the statement  "			if (!interfaceType.IsInterface) throw new ArgumentException(Resources.DuckTyping_InterfaceTypeMustBeAnInterface' "interfaceType"); " is 130.
Long Statement,BLToolkit.Reflection,ExprTypeAccessor<T;TOriginal>,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ThrowException,The length of the statement  "			throw new TypeBuilderException(string.Format("The '{0}' type must have default or init constructor."' typeof(TOriginal).FullName)); " is 131.
Long Statement,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetPropertyByMethod,The length of the statement  "				var attr = BindingFlags.NonPublic | BindingFlags.Public | (method.IsStatic ? BindingFlags.Static : BindingFlags.Instance); " is 122.
Long Statement,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The length of the statement  "							if ((getter2 == null || (getter2.Name == map.InterfaceMethods[i].Name && getter2.DeclaringType == map.InterfaceMethods[i].DeclaringType)) " is 137.
Long Statement,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The length of the statement  "								(getter1 == null || (getter1.Name == map.InterfaceMethods[i].Name && getter1.DeclaringType == map.InterfaceMethods[i].DeclaringType)) " is 133.
Long Statement,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetAccessor,The length of the statement  "				var accessorType = TypeFactory.GetType(originalType' originalType' new TypeAccessorBuilder(instanceType' originalType)); " is 120.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapFieldAttributes,The length of the statement  "				return _mapFieldAttributes ?? (_mapFieldAttributes = TypeHelper.GetAttributes(typeAccessor.Type' typeof (MapFieldAttribute))); " is 126.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNonUpdatableAttributes,The length of the statement  "				return _nonUpdatableAttributes ?? (_nonUpdatableAttributes = TypeHelper.GetAttributes(typeAccessor.Type' typeof(NonUpdatableAttribute))); " is 137.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapIgnore,The length of the statement  "			var attr = member.GetAttribute<MapIgnoreAttribute>() ?? (MapIgnoreAttribute)TypeHelper.GetFirstAttribute(member.Type' typeof(MapIgnoreAttribute)); " is 146.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapField,The length of the statement  "			var attr = member.GetAttribute<MapFieldAttribute>() ?? (MapFieldAttribute)TypeHelper.GetFirstAttribute(member.Type' typeof(MapFieldAttribute)); " is 143.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetDbType,The length of the statement  "			var attr = member.GetAttribute<DbTypeAttribute>() ?? (DbTypeAttribute)TypeHelper.GetFirstAttribute(member.Type' typeof(DbTypeAttribute)); " is 137.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetPrimaryKey,The length of the statement  "			var attr = member.GetAttribute<PrimaryKeyAttribute>() ?? (PrimaryKeyAttribute)TypeHelper.GetFirstAttribute(member.Type' typeof(PrimaryKeyAttribute)); " is 149.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetLazyInstance,The length of the statement  "			attr1 = (LazyInstanceAttribute)TypeHelper.GetFirstAttribute(member.MemberInfo.DeclaringType' typeof(LazyInstanceAttribute)); " is 124.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The length of the statement  "					throw new InvalidOperationException("Destination type should be set for enumerable relations: " + ma.Type.FullName + "." + ma.Name); " is 132.
Long Statement,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,The length of the statement  "						throw new InvalidOperationException("Destination type should be set for enumerable relations: " + ma.Type.FullName + "." + ma.Name); " is 132.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "											"Query cannot be deserialized. The possible reason is that the deserializer could not resolve the following types: {0}. Use LinqService.TypeResolver to resolve types."' " is 168.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "					case QueryElementType.SetExpression : obj = new SqlQuery.SetExpression(Read<ISqlExpression>()' Read<ISqlExpression>()); break; " is 126.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "					case QueryElementType.FromClause    : obj = new SqlQuery.FromClause(ReadArray<SqlQuery.TableSource>());                 break; " is 126.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "					case QueryElementType.WhereClause   : obj = new SqlQuery.WhereClause(Read<SqlQuery.SearchCondition>());                 break; " is 126.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "					case QueryElementType.GroupByClause : obj = new SqlQuery.GroupByClause(ReadArray<ISqlExpression>());                    break; " is 126.
Long Statement,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The length of the statement  "					case QueryElementType.OrderByClause : obj = new SqlQuery.OrderByClause(ReadArray<SqlQuery.OrderByItem>());              break; " is 126.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,ExecuteNonQuery,The length of the statement  "			var data = LinqServiceSerializer.Serialize(q' q.IsParameterDependent ? q.Parameters.ToArray() : ctx.Query.GetParameters()); " is 123.
Long Statement,BLToolkit.TypeBuilder,TypeFactory,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,GetAssemblyBuilder,The length of the statement  "				if (!(type.Module is _ModuleBuilder) && type.Module.FullyQualifiedName != null && type.Module.FullyQualifiedName.IndexOf('<') < 0) " is 130.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,The length of the statement  "			var interfaceMethods = _originalType.Type.IsClass && !_originalType.Type.IsArray ? _originalType.Type.GetInterfaces().SelectMany(ti => _originalType.GetInterfaceMap(ti).TargetMethods).ToList() : new List<MethodInfo>(); " is 218.
Complex Conditional,BLToolkit.Aspects,LoggingAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,LogOperationInternal,The conditional expression  "info.Exception != null && parameters.LogExceptions ||  				info.Exception == null && time >= parameters.MinCallTime"  is complex.
Complex Conditional,BLToolkit.Common,Convert<T;P>,C:\repos\igor-tkachev_bltoolkit\Source\Common\ConvertT.cs,FindTypeCastOperator,The conditional expression  "mi.IsSpecialName && mi.ReturnType == typeof(T) && (mi.Name == "op_Implicit" || mi.Name == "op_Explicit")"  is complex.
Complex Conditional,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,The conditional expression  "!returnType.IsArray &&  				(IsInterfaceOf(returnType' typeof(IList)) ||  					returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(IList<>))"  is complex.
Complex Conditional,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The conditional expression  "parameterValues == null || parameterValues.Length == 0 ||  				parameterValues[0] is IDbDataParameter || parameterValues[0] is IDbDataParameter[]"  is complex.
Complex Conditional,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The conditional expression  "(value == null || value == DBNull.Value) && (dbType == DbType.Binary || type == typeof(byte[])) ||  							type == typeof(System.Data.Linq.Binary)"  is complex.
Complex Conditional,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,PrepareCommand,The conditional expression  "val == null || !val.GetType().IsArray || val is byte[] || val is char[]"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,UnionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,ConvertToSql,The conditional expression  "expression != null && (level == 0 || level == 1) && expression.NodeType == ExpressionType.MemberAccess"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The conditional expression  "type.Namespace != null && type.Namespace.StartsWith("System") ||  				IsAnonymous(type)                                             ||  				type.Assembly == GetType().Assembly                           ||  				type.IsGenericType && type.GetGenericTypeDefinition() != type"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,AddType,The conditional expression  "type == null || type == typeof(object) || type.IsGenericParameter || _usedTypes.Contains(type)"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,AggregationBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct        ||  			    sequence.SqlQuery.Select.TakeValue != null ||  			    sequence.SqlQuery.Select.SkipValue != null ||  			   !sequence.SqlQuery.GroupBy.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,CountBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct        ||  			    sequence.SqlQuery.Select.TakeValue != null ||  			    sequence.SqlQuery.Select.SkipValue != null ||  			   !sequence.SqlQuery.GroupBy.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressionTree,The conditional expression  "call.IsQueryable() && call.Object == null && call.Arguments.Count > 0 && call.Type.IsGenericType"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The conditional expression  "subQuery.Select.Columns.Count == 1 &&  					    subQuery.Select.Columns[0].Expression.ElementType == QueryElementType.SqlFunction &&  					    subQuery.GroupBy.IsEmpty && !subQuery.Select.HasModifier && !subQuery.HasUnion &&  					    subQuery.Where.SearchCondition.Conditions.Count == 1"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The conditional expression  "cond.Predicate.ElementType == QueryElementType.ExprExprPredicate && query.GroupBy.Items.Count == 1 ||  						    cond.Predicate.ElementType == QueryElementType.SearchCondition &&  						    query.GroupBy.Items.Count == ((SqlQuery.SearchCondition)cond.Predicate).Conditions.Count"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The conditional expression  "e.Type == t ||  							t.IsEnum && Enum.GetUnderlyingType(t) == e.Type ||  							e.Type.IsEnum && Enum.GetUnderlyingType(e.Type) == t"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The conditional expression  "left.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.Convert  				|| left.NodeType == ExpressionType.MemberAccess || right.NodeType == ExpressionType.MemberAccess"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The conditional expression  "!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull() || r is SqlParameter && r.CanBeNull())"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectNullComparison,The conditional expression  "ctx != null && ctx.IsExpression(left' 0' RequestFor.Object).Result ||  						left.NodeType == ExpressionType.Parameter && ctx.IsExpression(left' 0' RequestFor.Field).Result"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,GroupByBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct       ||  			    sequence.SqlQuery.GroupBy.Items.Count > 0 ||  			    groupSql.Any(_ => !(_.Sql is SqlField || _.Sql is SqlQuery.Column))"  is complex.
Complex Conditional,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetParameters,The conditional expression  "etype == null || etype == typeof (object) ||  					    etype.IsEnum ||  					    (TypeHelper.IsNullableType(etype) && etype.GetGenericArguments()[0].IsEnum)"  is complex.
Complex Conditional,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The conditional expression  "!mm.Type.IsClass && !mm.Type.IsInterface && mm.MapMemberInfo.Nullable && !TypeHelper.IsNullableType(mm.Type)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The conditional expression  "p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildAlternativeOrderBy,The conditional expression  "ascending &&  SqlQuery.OrderBy.Items[i].IsDescending ||  					!ascending && !SqlQuery.OrderBy.Items[i].IsDescending"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeDelete,The conditional expression  "sqlQuery.IsDelete &&   				(sqlQuery.From.Tables.Count > 1 || sqlQuery.From.Tables[0].Joins.Count > 0) &&   				sqlQuery.From.Tables[0].Source is SqlTable"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The conditional expression  "(i % 2 == 1 || i == count - 1) && expr.SystemType == typeof(bool) || expr.SystemType == typeof(bool?)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,SetAlias,The conditional expression  "c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '_'"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The conditional expression  "v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == """  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The conditional expression  "name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#')"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildWhereSearchCondition,The conditional expression  "NeedTake && !NeedSkip && SqlQuery.OrderBy.IsEmpty && SqlQuery.Having.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "expr1 != null && !ReferenceEquals(expr1' bexpr.Expr1) ||  							expr2 != null && !ReferenceEquals(expr2' bexpr.Expr2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "source != null && !ReferenceEquals(source' table.Source) ||  							joins  != null && !ReferenceEquals(table.Joins' joins)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "table != null && !ReferenceEquals(table' join.Table) ||  							cond  != null && !ReferenceEquals(cond'  join.Condition)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals(p.Expr1' e1) || e2 != null && !ReferenceEquals(p.Expr2' e2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals(p.Expr1' e1) ||  							e2 != null && !ReferenceEquals(p.Expr2' e2) ||  							es != null && !ReferenceEquals(p.Escape' es)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals(p.Expr1' e1) ||  							e2 != null && !ReferenceEquals(p.Expr2' e2) ||  							e3 != null && !ReferenceEquals(p.Expr3' e3)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e != null && !ReferenceEquals(p.Expr1' e) || q != null && !ReferenceEquals(p.SubQuery' q)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e != null && !ReferenceEquals(p.Expr1' e) || v != null && !ReferenceEquals(p.Values' v)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "c != null && !ReferenceEquals(s.Column' c) || e != null && !ReferenceEquals(s.Expression' e)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "t != null && !ReferenceEquals(s.Into' t) || i != null && !ReferenceEquals(s.Items' i)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "t != null && !ReferenceEquals(s.Table' t) ||  							i != null && !ReferenceEquals(s.Items' i) ||  							k != null && !ReferenceEquals(s.Keys'  k)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "parent != null ||  							cols != null && !ReferenceEquals(sc.Columns'   cols) ||  							take != null && !ReferenceEquals(sc.TakeValue' take) ||  							skip != null && !ReferenceEquals(sc.SkipValue' skip)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,CanBeNull,The conditional expression  "type.IsValueType == false ||  				type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) ||  				TypeHelper.IsSameOrParent(typeof(INullable)' type)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlExpression,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,Equals,The conditional expression  "expr == null || SystemType != expr.SystemType || Expr != expr.Expr || Parameters.Length != expr.Parameters.Length"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlFunction,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,Equals,The conditional expression  "func == null || Name != func.Name || Parameters.Length != func.Parameters.Length && SystemType != func.SystemType"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeUnions,The conditional expression  "sql == null || sql.From.Tables.Count != 1 || !sql.IsSimple || sql._insert != null || sql._update != null || sql._delete != null"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeApply,The conditional expression  "isApplySupported && (isAgg || sql.Select.TakeValue != null || sql.Select.SkipValue != null)"  is complex.
Complex Conditional,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The conditional expression  "expr1 == null || expr2 == null || expr1.NodeType != expr2.NodeType || expr1.Type != expr2.Type"  is complex.
Complex Conditional,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The conditional expression  "b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member"  is complex.
Complex Conditional,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The conditional expression  "dtype == typeof(object) || dtype == stype && (!DeepCopy || isSourceScalar)"  is complex.
Complex Conditional,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The conditional expression  "checkNull && isSourceNullable && !TypeHelper.IsNullableType(dtype) && (isDestScalar || isSourceScalar)"  is complex.
Complex Conditional,BLToolkit.ComponentModel,BindingListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetItemSortedPosition,The conditional expression  "(index > 0 && comparer.Compare(_list[index - 1]' sender) > 0) ||  				(index < _list.Count - 1 && comparer.Compare(_list[index + 1]' sender) < 0)"  is complex.
Complex Conditional,BLToolkit.Reflection,ExprTypeAccessor<T;TOriginal>,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ExprTypeAccessor,The conditional expression  "(getMethod == null || interfaceMethods.Contains(getMethod)) &&  							(setMethod == null || interfaceMethods.Contains(setMethod))"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsSameOrParent,The conditional expression  "parent == child ||  				child.IsEnum && Enum.GetUnderlyingType(child) == parent ||  				child.IsSubclassOf(parent)"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The conditional expression  "getter2.Name == map.InterfaceMethods[i].Name && getter2.DeclaringType == map.InterfaceMethods[i].DeclaringType &&  								getter1.Name == map.TargetMethods   [i].Name && getter1.DeclaringType == map.TargetMethods   [i].DeclaringType"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The conditional expression  "(getter2 == null || (getter2.Name == map.InterfaceMethods[i].Name && getter2.DeclaringType == map.InterfaceMethods[i].DeclaringType))  								&&  								(getter1 == null || (getter1.Name == map.InterfaceMethods[i].Name && getter1.DeclaringType == map.InterfaceMethods[i].DeclaringType))"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,MapTypeName,The conditional expression  "type.IsPrimitive ||  				type == typeof(string) ||  				type == typeof(object) ||  				type == typeof(decimal)"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetExtendedProperties,The conditional expression  "!isList                   &&  					!propertyType.IsValueType &&  					!propertyType.IsArray     &&  					(!propertyType.FullName.StartsWith("System.") || explicitlyBound  					|| propertyType.IsGenericType) &&  					 propertyType != typeof(Type)   &&  					 propertyType != typeof(string) &&  					 propertyType != typeof(object) &&  					Array.IndexOf(parentTypes' propertyType) == -1"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapValues,The conditional expression  "a.Type == null && a.OrigValue != null && a.OrigValue.GetType() == memberType ||  						a.Type is Type && (Type)a.Type == memberType"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetDefaultValue,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType() == member.Type ||  					a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullable,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType() == member.Type ||  					a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullValue,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType() == member.Type ||  					a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The conditional expression  "attr == null || (slave != null && attr.Destination != slave && ma.Type != slave)"  is complex.
Complex Conditional,BLToolkit.ServiceModel,QuerySerializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Visit,The conditional expression  "p.Value == null || t.IsArray || t == typeof(string) || !(p.Value is IEnumerable)"  is complex.
Complex Conditional,BLToolkit.ServiceModel,QuerySerializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Visit,The conditional expression  "elem.Value == null || type.IsArray || type == typeof(string) || !(elem.Value is IEnumerable)"  is complex.
Complex Conditional,BLToolkit.TypeBuilder,TypeFactory,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,The conditional expression  "!(  #if FW4  							a.IsDynamic ||  #endif  							a is _AssemblyBuilder) &&  							(a.CodeBase.IndexOf("Microsoft.NET/Framework") > 0 || a.FullName.StartsWith("System."))"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineAbstractProperties,The conditional expression  "getter != null && getter.IsAbstract ||  					setter != null && setter.IsAbstract"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualProperties,The conditional expression  "getter != null && getter.IsVirtual && !getter.IsAbstract && !getter.IsFinal"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualProperties,The conditional expression  "setter != null && setter.IsVirtual && !setter.IsAbstract && !setter.IsFinal"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualMethods,The conditional expression  "method.IsVirtual &&  					method.IsAbstract == false &&  					method.IsFinal    == false &&  					(method.Attributes & MethodAttributes.SpecialName) == 0 &&  					method.DeclaringType != typeof(object)"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,The conditional expression  "getter != null && (getter.IsAbstract || interfaceMethods.Contains(getter))  						|| setter != null && (setter.IsAbstract || interfaceMethods.Contains(setter))"  is complex.
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "CreateConnectionObject".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "GetConnectionString".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "Configure".
Virtual Method Call from Constructor,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,TableContext,The constructor "TableContext" calls a virtual method "SetTable".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetDatabaseName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetOwnerName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetTableName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetNonUpdatableAttribute".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetPrimaryKeyOrder".
Virtual Method Call from Constructor,BLToolkit.Mapping,ScalarListMapper<T>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ScalarListMapperT.cs,ScalarListMapper,The constructor "ScalarListMapper" calls a virtual method "GetNullValue".
Virtual Method Call from Constructor,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MappingSchema,The constructor "MappingSchema" calls a virtual method "InitNullValues".
Virtual Method Call from Constructor,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,CustomTypeDescriptorImpl,The constructor "CustomTypeDescriptorImpl" calls a virtual method "CreateTypeDescriptionProvider".
Virtual Method Call from Constructor,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,CustomTypeDescriptorImpl,The constructor "CustomTypeDescriptorImpl" calls a virtual method "CreateTypeDescriptionProvider".
Empty Catch Block,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,MapTo,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.ComponentModel,TypedListImpl,C:\repos\igor-tkachev_bltoolkit\Source\ComponentModel\TypedListImpl.cs,GetItemProperties,The method has an empty catch block.
Empty Catch Block,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetListItemType,The method has an empty catch block.
Empty Catch Block,BLToolkit.TypeBuilder,TypeFactory,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,TypeFactory,The method has an empty catch block.
Magic Number,BLToolkit.Aspects.Builders,AsyncAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,IsCompatible,The following statement contains a magic number: var list = new AbstractTypeBuilderList(2) { this' typeBuilder };
Magic Number,BLToolkit.Aspects.Builders,AsyncAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The following statement contains a magic number: if (delegateType == null)  			{  				var pi         = method.GetParameters();  				var parameters = new Type[pi.Length];    				for (var i = 0; i < pi.Length; i++)  					parameters[i] = pi[i].ParameterType;    				const MethodImplAttributes mia = MethodImplAttributes.Runtime | MethodImplAttributes.Managed;  				const MethodAttributes     ma  = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual;    				var delegateBuilder = context.AssemblyBuilder.DefineType(delegateName'  					TypeAttributes.Class | TypeAttributes.NotPublic | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass'  					typeof(MulticastDelegate));    				// Create constructor  				//  				var ctorBuilder = delegateBuilder.DefineConstructor(  					MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName' CallingConventions.Standard'  					typeof(object)' typeof(IntPtr));  				ctorBuilder.ConstructorBuilder.SetImplementationFlags(mia);    				// Define the BeginInvoke method for the delegate  				//  				var beginParameters = new Type[parameters.Length + 2];    				Array.Copy(parameters' 0' beginParameters' 0' parameters.Length);  				beginParameters[parameters.Length]   = typeof(AsyncCallback);  				beginParameters[parameters.Length+1] = typeof(object);    				var methodBuilder = delegateBuilder.DefineMethod("BeginInvoke"' ma' typeof(IAsyncResult)' beginParameters);    				methodBuilder.MethodBuilder.SetImplementationFlags(mia);    				// Define the EndInvoke method for the delegate  				//  				methodBuilder = delegateBuilder.DefineMethod("EndInvoke"' ma' method.ReturnType' typeof(IAsyncResult));  				methodBuilder.MethodBuilder.SetImplementationFlags(mia);    				// Define the Invoke method for the delegate  				//  				methodBuilder = delegateBuilder.DefineMethod("Invoke"' ma' method.ReturnType' parameters);  				methodBuilder.MethodBuilder.SetImplementationFlags(mia);    				context.Items.Add(delegateName' delegateType = delegateBuilder.Create());  			}
Magic Number,BLToolkit.Aspects.Builders,OverloadAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,IsCompatible,The following statement contains a magic number: AbstractTypeBuilderList list = new AbstractTypeBuilderList(2);
Magic Number,BLToolkit.Aspects,CacheAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,The following statement contains a magic number: foreach (var p in ps)  			{  				var vs = p.Split('=');    				if (vs.Length == 2)  				{  					switch (vs[0].ToLower().Trim())  					{  						case "maxcachetime": _instanceMaxCacheTime = int. Parse(vs[1].Trim()); break;  						case "isweak":       _instanceIsWeak       = bool.Parse(vs[1].Trim()); break;  					}  				}  			}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Start,The following statement contains a magic number: if (_timer == null)  					lock (_syncTimer)  						if (_timer == null)  						{  							var interval = TimeSpan.FromSeconds(10);  							_timer = new Timer(Cleanup' null' new TimeSpan(0)' interval);  						}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Cleanup,The following statement contains a magic number: if (!Monitor.TryEnter(RegisteredAspects.SyncRoot' 10))  				{  					// The Cache is busy' skip this turn.  					//  					return;  				}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Cleanup,The following statement contains a magic number: try  				{  					_workTimes++;    					var list = new List<DictionaryEntry>();    					foreach (CacheAspect aspect in RegisteredAspects)  					{  						if (!aspect.HasCache)  							continue;    						var cache = aspect.Cache;    						// cache can be in process now  						if(!Monitor.TryEnter(aspect.CacheSyncRoot' 10))  							continue;  						try  						{    							foreach (DictionaryEntry de in cache)  							{  								var wr = de.Value as WeakReference;    								bool isExpired;    								if (wr != null)  								{  									var ca = wr.Target as CacheAspectItem;    									isExpired = ca == null || ca.IsExpired;  								}  								else  								{  									isExpired = ((CacheAspectItem) de.Value).IsExpired;  								}    								if (isExpired)  									list.Add(de);  							}    							foreach (var de in list)  							{  								cache.Remove(de.Key);  								_objectsExpired++;  							}    							list.Clear();    							objectsInCache += cache.Count;  						}  						finally  						{  							Monitor.Exit(aspect.CacheSyncRoot);  						}  					}    					_objectsInCache = objectsInCache;  				}  				finally  				{  					_workTime += DateTime.Now - start;    					Monitor.Exit(RegisteredAspects.SyncRoot);  				}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,ClearCache,The following statement contains a magic number: lock (RegisteredAspects.SyncRoot)   				{  					if (!aspect.HasCache)  						return;    					if (!Monitor.TryEnter(aspect.CacheSyncRoot' 10))  						return;  					try  					{  						_objectsExpired += aspect.Cache.Count;  						aspect.Cache.Clear();  					}  					finally  					{  						Monitor.Exit(aspect.CacheSyncRoot);  					}  				}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,ClearCache,The following statement contains a magic number: lock (RegisteredAspects.SyncRoot)  				{  					if (!aspect.HasCache)  						return;    					if (!Monitor.TryEnter(aspect.CacheSyncRoot' 10))  						return;  					try  					{  						_objectsExpired += 1;  						aspect.Cache.Remove(key);  					}  					finally  					{  						Monitor.Exit(aspect.CacheSyncRoot);  					}  				}
Magic Number,BLToolkit.Aspects,CleanupThread,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,ClearCache,The following statement contains a magic number: lock (RegisteredAspects.SyncRoot)  				{  					foreach (CacheAspect aspect in RegisteredAspects)  					{  						if (!aspect.HasCache)  							continue;    						_objectsExpired += aspect.Cache.Count;    						if (!Monitor.TryEnter(aspect.CacheSyncRoot' 10))  							continue;  						try  						{  							aspect.Cache.Clear();  						}  						finally  						{  							Monitor.Exit(aspect.CacheSyncRoot);  						}  					}  				}
Magic Number,BLToolkit.Aspects,LoggingAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,The following statement contains a magic number: foreach (string p in ps)  			{  				string[] vs = p.Split('=');    				if (vs.Length == 2)  				{  					switch (vs[0].ToLower().Trim())  					{  						case "filename":      _instanceFileName      =            vs[1].Trim();  break;  						case "mincalltime":   _instanceMinCallTime   = int. Parse(vs[1].Trim()); break;  						case "logexceptions": _instanceLogExceptions = bool.Parse(vs[1].Trim()); break;  						case "logparameters": _instanceLogParameters = bool.Parse(vs[1].Trim()); break;  					}  				}  			}
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,Tuple,C:\repos\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;
Magic Number,BLToolkit.Common,CompoundValue,C:\repos\igor-tkachev_bltoolkit\Source\Common\CompoundValue.cs,CalcHashCode,The following statement contains a magic number: for (int i = 1; i < values.Length; i++)  			{  				o = values[i];  				hash = ((hash << 5) + hash) ^ (o == null ? 0 : o.GetHashCode());  			}
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: switch (rt)  			{  				case ReturnType.DataReader : ExecuteReader();            break;  				case ReturnType.DataSet    : ExecuteDataSet(returnType); break;  				case ReturnType.DataTable  : ExecuteDataTable();         break;  				case ReturnType.Void       : ExecuteNonQuery();          break;  				case ReturnType.Scalar     : ExecuteScalar();            break;  				case ReturnType.Enumerable : ExecuteEnumerable();        break;    				case ReturnType.List:    					if (!_explicitObjectType)  					{  						Type elementType = TypeHelper.GetListItemType(returnType);    						if (elementType == typeof(object) && _destination != null)  							elementType = TypeHelper.GetListItemType(Context.CurrentMethod.ReturnType);    						if (elementType != typeof(object))  							_objectType = elementType;    						if (ActualTypes.ContainsKey(_objectType))  							_objectType = ActualTypes[_objectType];  					}    					if (_objectType == null || _objectType == typeof(object))  						ThrowTypeBuilderException(Resources.DataAccessorBuilder_BadListItemType);    					if (TypeHelper.IsScalar(_objectType))  						ExecuteScalarList();  					else  						ExecuteList();    					break;    				case ReturnType.Dictionary:  					{  						Type elementType = null;  						Type keyType = typeof(object);  						Type[] gTypes = TypeHelper.GetGenericArguments(returnType' typeof(IDictionary));    						if ((gTypes == null || gTypes.Length != 2) && _destination != null)  							gTypes = TypeHelper.GetGenericArguments(_destination.ParameterType' typeof(IDictionary));    						if (gTypes != null && gTypes.Length == 2)  						{  							keyType = gTypes[0];  							elementType = gTypes[1];  						}    						if (elementType == null || _explicitObjectType)  							elementType = _objectType;    						if (elementType == null || elementType == typeof(object))  							ThrowTypeBuilderException(Resources.DataAccessorBuilder_BadListItemType);    						bool isIndex = TypeHelper.IsSameOrParent(typeof(CompoundValue)' keyType);    						if (keyType != typeof(object) && !isIndex && !TypeHelper.IsScalar(keyType))  							ThrowTypeBuilderException(  								Resources.DataAccessorBuilder_BadKeyType);    						MethodInfo mi = Context.CurrentMethod;    						object[] attrs = mi.GetCustomAttributes(typeof(IndexAttribute)' true);  						NameOrIndexParameter[] fields = new NameOrIndexParameter[0];    						if (attrs.Length != 0)  							fields = ((IndexAttribute)attrs[0]).Fields;    						if (fields.Length > 1 && keyType != typeof(object) && !isIndex)  							ThrowTypeBuilderException(  								Resources.DataAccessor_InvalidKeyType);    						if (TypeHelper.IsScalar(elementType))  						{  							attrs = mi.GetCustomAttributes(typeof(ScalarFieldNameAttribute)' true);    							if (attrs.Length == 0)  								ThrowTypeBuilderException(Resources.DataAccessorBuilder_ScalarFieldNameMissing);    							NameOrIndexParameter scalarField = ((ScalarFieldNameAttribute)attrs[0]).NameOrIndex;    							if (fields.Length == 0)  								ExecuteScalarDictionaryWithPK(keyType' scalarField' elementType);  							else if (isIndex || fields.Length > 1)  								ExecuteScalarDictionaryWithMapIndex(fields' scalarField' elementType);  							else  								ExecuteScalarDictionaryWithScalarKey(fields[0]' keyType' scalarField' elementType);  						}  						else  						{  							if (!_explicitObjectType && ActualTypes.ContainsKey(elementType))  								elementType = ActualTypes[elementType];    							if (fields.Length == 0)  								ExecuteDictionaryWithPK(keyType' elementType);  							else if (isIndex || fields.Length > 1)  								ExecuteDictionaryWithMapIndex(fields' elementType);  							else  								ExecuteDictionaryWithScalarKey(fields[0]' elementType);  						}  					}    					break;    				default:    					if (_objectType == null || !TypeHelper.IsSameOrParent(returnType' _objectType))  						_objectType = returnType;    					if (!_explicitObjectType && ActualTypes.ContainsKey(_objectType))  						_objectType = ActualTypes[_objectType];    					ExecuteObject();    					break;  			}
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: switch (rt)  			{  				case ReturnType.DataReader : ExecuteReader();            break;  				case ReturnType.DataSet    : ExecuteDataSet(returnType); break;  				case ReturnType.DataTable  : ExecuteDataTable();         break;  				case ReturnType.Void       : ExecuteNonQuery();          break;  				case ReturnType.Scalar     : ExecuteScalar();            break;  				case ReturnType.Enumerable : ExecuteEnumerable();        break;    				case ReturnType.List:    					if (!_explicitObjectType)  					{  						Type elementType = TypeHelper.GetListItemType(returnType);    						if (elementType == typeof(object) && _destination != null)  							elementType = TypeHelper.GetListItemType(Context.CurrentMethod.ReturnType);    						if (elementType != typeof(object))  							_objectType = elementType;    						if (ActualTypes.ContainsKey(_objectType))  							_objectType = ActualTypes[_objectType];  					}    					if (_objectType == null || _objectType == typeof(object))  						ThrowTypeBuilderException(Resources.DataAccessorBuilder_BadListItemType);    					if (TypeHelper.IsScalar(_objectType))  						ExecuteScalarList();  					else  						ExecuteList();    					break;    				case ReturnType.Dictionary:  					{  						Type elementType = null;  						Type keyType = typeof(object);  						Type[] gTypes = TypeHelper.GetGenericArguments(returnType' typeof(IDictionary));    						if ((gTypes == null || gTypes.Length != 2) && _destination != null)  							gTypes = TypeHelper.GetGenericArguments(_destination.ParameterType' typeof(IDictionary));    						if (gTypes != null && gTypes.Length == 2)  						{  							keyType = gTypes[0];  							elementType = gTypes[1];  						}    						if (elementType == null || _explicitObjectType)  							elementType = _objectType;    						if (elementType == null || elementType == typeof(object))  							ThrowTypeBuilderException(Resources.DataAccessorBuilder_BadListItemType);    						bool isIndex = TypeHelper.IsSameOrParent(typeof(CompoundValue)' keyType);    						if (keyType != typeof(object) && !isIndex && !TypeHelper.IsScalar(keyType))  							ThrowTypeBuilderException(  								Resources.DataAccessorBuilder_BadKeyType);    						MethodInfo mi = Context.CurrentMethod;    						object[] attrs = mi.GetCustomAttributes(typeof(IndexAttribute)' true);  						NameOrIndexParameter[] fields = new NameOrIndexParameter[0];    						if (attrs.Length != 0)  							fields = ((IndexAttribute)attrs[0]).Fields;    						if (fields.Length > 1 && keyType != typeof(object) && !isIndex)  							ThrowTypeBuilderException(  								Resources.DataAccessor_InvalidKeyType);    						if (TypeHelper.IsScalar(elementType))  						{  							attrs = mi.GetCustomAttributes(typeof(ScalarFieldNameAttribute)' true);    							if (attrs.Length == 0)  								ThrowTypeBuilderException(Resources.DataAccessorBuilder_ScalarFieldNameMissing);    							NameOrIndexParameter scalarField = ((ScalarFieldNameAttribute)attrs[0]).NameOrIndex;    							if (fields.Length == 0)  								ExecuteScalarDictionaryWithPK(keyType' scalarField' elementType);  							else if (isIndex || fields.Length > 1)  								ExecuteScalarDictionaryWithMapIndex(fields' scalarField' elementType);  							else  								ExecuteScalarDictionaryWithScalarKey(fields[0]' keyType' scalarField' elementType);  						}  						else  						{  							if (!_explicitObjectType && ActualTypes.ContainsKey(elementType))  								elementType = ActualTypes[elementType];    							if (fields.Length == 0)  								ExecuteDictionaryWithPK(keyType' elementType);  							else if (isIndex || fields.Length > 1)  								ExecuteDictionaryWithMapIndex(fields' elementType);  							else  								ExecuteDictionaryWithScalarKey(fields[0]' elementType);  						}  					}    					break;    				default:    					if (_objectType == null || !TypeHelper.IsSameOrParent(returnType' _objectType))  						_objectType = returnType;    					if (!_explicitObjectType && ActualTypes.ContainsKey(_objectType))  						_objectType = ActualTypes[_objectType];    					ExecuteObject();    					break;  			}
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The following statement contains a magic number: sb.Remove(sb.Length - 5' 5);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The following statement contains a magic number: sb.Remove(sb.Length - 5' 5);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateSelectByKeySqlText,The following statement contains a magic number: sb.Remove(sb.Length - 2' 1);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateSelectAllSqlText,The following statement contains a magic number: sb.Remove(sb.Length - 2' 1);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateInsertSqlText,The following statement contains a magic number: sb.Remove(sb.Length - 2' 1);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateInsertSqlText,The following statement contains a magic number: sb.Remove(sb.Length - 2' 1);
Magic Number,BLToolkit.DataAccess,SqlQueryBase,C:\repos\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateUpdateSqlText,The following statement contains a magic number: sb.Remove(sb.Length - 2' 1);
Magic Number,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: var maxRows =  				Math.Max(  					Math.Min(  						Math.Max(  							members.Length == 0? 1000 : _dataProvider.MaxParameters / members.Length'  							members.Length)'  						maxBatchSize)'  					1);
Magic Number,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: foreach (var obj in collection)  			{  				if (initParameters)  				{  					initParameters = false;  					baseParameters = getParameters(obj);    					if (maxRows != 1)  					{  						var n = 0;    						foreach (var p in baseParameters)  							n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;    						maxRows = Math.Max(1' Math.Min(maxRows' _dataProvider.MaxBatchSize / (baseSql.Length + n)));  					}    					if (maxRows != 1)  						baseSql += _dataProvider.EndOfSql;  				}    				if (rowSql.Count < maxRows)  				{  // ReSharper disable AccessToModifiedClosure  					Converter<IDbDataParameter'string> c1 = p => p.ParameterName + nRows;  // ReSharper restore AccessToModifiedClosure  					Converter<IDbDataParameter'string> c2 = p => p.ParameterName;    					sb  						.Append("\n")  						.AppendFormat(  							baseSql'  							Array.ConvertAll(  								baseParameters'  								baseParameters.Length > 0 && baseParameters[0].ParameterName != paramName? c1 : c2));    					rowSql.Add(sb.Length);    					for (var i = 0; i < members.Length; i++)  					{  						var value  = members[i].GetValue(obj);  						var type   = members[i].MemberAccessor.Type;  						var dbType = members[i].GetDbType();    						IDbDataParameter p;    						if ((value == null || value == DBNull.Value) && (dbType == DbType.Binary || type == typeof(byte[])) ||  							type == typeof(System.Data.Linq.Binary))  						{  							p = Parameter(baseParameters[i].ParameterName + nRows' DBNull.Value' DbType.Binary);  						}  						else  						{  							if (value != null && value.GetType().IsEnum)  								value = MappingSchema.MapEnumToValue(value' true);    							p = value != null  								? Parameter(baseParameters[i].ParameterName + nRows' value)  								: Parameter(baseParameters[i].ParameterName + nRows' DBNull.Value' members[i].GetDbType());  						}    						parameters.Add(p);  						hasValue.Add(value != null);  					}  				}  				else  				{  					var n = nRows * members.Length;    					for (var i = 0; i < members.Length; i++)  					{  						var value = members[i].GetValue(obj);    						if (!hasValue[n + i] && value != null)  						{  							isPrepared = false;    							var type   = members[i].MemberAccessor.Type;  							var dbType = members[i].GetDbType();    							if (value.GetType().IsEnum)  								value = MappingSchema.MapEnumToValue(value' true);    							IDbDataParameter p;  							if (dbType != DbType.Object)  								p = Parameter(baseParameters[i].ParameterName + nRows' value ?? DBNull.Value' dbType);  							else  								p = Parameter(baseParameters[i].ParameterName + nRows' value ?? DBNull.Value/*' dbType*/);    							parameters[n + i] = p;  							hasValue  [n + i] = true;  						}  						else  						{  							if (value != null && value.GetType().IsEnum)  								value = MappingSchema.MapEnumToValue(value' true);    							_dataProvider.SetParameterValue(  								parameters[n + i]'  								value ?? DBNull.Value);  								//value == null || members[i].MapMemberInfo.Nullable && _mappingSchema.IsNull(value)  								//	? DBNull.Value  								//	: value);  						}    					}  				}    				nRows++;    				if (nRows >= maxRows)  				{  					if (!isPrepared)  					{  						SetCommand(sb.ToString()' parameters.ToArray());  						Prepare();  						isPrepared = true;  					}  					else  					{  						InitParameters(CommandAction.Select);  					}    					var n = ExecuteNonQueryInternal();  					if (n > 0)  						rowsTotal += n;    					nRows = 0;  				}  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderVersionResolver,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderVersionResolver.cs,GetVersionFromConnection,The following statement contains a magic number: if (serverVersionDetails.Length > 0 && int.TryParse(serverVersionDetails[0]' out versionNumber))  				return versionNumber * 10;
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (dt.Rows.Count == 0)  			{  				// Jet does convert parameretless procedures to views.  				//  				dt = conn.GetOleDbSchemaTable(OleDbSchemaGuid.Views' new object[]{null' null' command.CommandText});    				if (dt.Rows.Count == 0)  					throw new DataException(string.Format("Stored procedure '{0}' not found"' command.CommandText));    				// Do nothing. There is no parameters.  				//  			}  			else  			{  				var col = dt.Columns["PROCEDURE_DEFINITION"];    				if (col == null)  				{  					// Not really possible  					//  					return false;  				}    				if (_paramsExp == null)  					_paramsExp = new Regex(@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture);    				var match = _paramsExp.Match((string)dt.Rows[0][col.Ordinal]);  				var names = match.Groups["name"].Captures;  				var types = match.Groups["type"].Captures;    				if (names.Count != types.Count)  				{  					// Not really possible  					//  					return false;  				}    				var separators = new[] {' '' '('' '''' ')'};    				for (var i = 0; i < names.Count; ++i)  				{  					var paramName = names[i].Value;  					var rawType   = types[i].Value.Split(separators' StringSplitOptions.RemoveEmptyEntries);  					var p         = new OleDbParameter(paramName' GetOleDbType(rawType[0]));    					if (rawType.Length > 2)  					{  						p.Precision = Common.Convert.ToByte(rawType[1]);  						p.Scale     = Common.Convert.ToByte(rawType[2]);  					}  					else if (rawType.Length > 1)  					{  						p.Size      = Common.Convert.ToInt32(rawType[1]);  					}    					command.Parameters.Add(p);  				}  			}
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (dt.Rows.Count == 0)  			{  				// Jet does convert parameretless procedures to views.  				//  				dt = conn.GetOleDbSchemaTable(OleDbSchemaGuid.Views' new object[]{null' null' command.CommandText});    				if (dt.Rows.Count == 0)  					throw new DataException(string.Format("Stored procedure '{0}' not found"' command.CommandText));    				// Do nothing. There is no parameters.  				//  			}  			else  			{  				var col = dt.Columns["PROCEDURE_DEFINITION"];    				if (col == null)  				{  					// Not really possible  					//  					return false;  				}    				if (_paramsExp == null)  					_paramsExp = new Regex(@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture);    				var match = _paramsExp.Match((string)dt.Rows[0][col.Ordinal]);  				var names = match.Groups["name"].Captures;  				var types = match.Groups["type"].Captures;    				if (names.Count != types.Count)  				{  					// Not really possible  					//  					return false;  				}    				var separators = new[] {' '' '('' '''' ')'};    				for (var i = 0; i < names.Count; ++i)  				{  					var paramName = names[i].Value;  					var rawType   = types[i].Value.Split(separators' StringSplitOptions.RemoveEmptyEntries);  					var p         = new OleDbParameter(paramName' GetOleDbType(rawType[0]));    					if (rawType.Length > 2)  					{  						p.Precision = Common.Convert.ToByte(rawType[1]);  						p.Scale     = Common.Convert.ToByte(rawType[2]);  					}  					else if (rawType.Length > 1)  					{  						p.Size      = Common.Convert.ToInt32(rawType[1]);  					}    					command.Parameters.Add(p);  				}  			}
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetValue,The following statement contains a magic number: if (value is DateTime)  				{  					var dt = (DateTime)value;    					if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  						return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);  				}
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetValue,The following statement contains a magic number: if (value is DateTime)  				{  					var dt = (DateTime)value;    					if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  						return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);  				}
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetValue,The following statement contains a magic number: if (value is DateTime)  				{  					var dt = (DateTime)value;    					if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  						return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);  				}
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetDateTime,The following statement contains a magic number: if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  					return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetDateTime,The following statement contains a magic number: if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  					return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);
Magic Number,BLToolkit.Data.DataProvider,DataReaderEx,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetDateTime,The following statement contains a magic number: if (dt.Year == 1899 && dt.Month == 12 && dt.Day == 30)  					return new DateTime(1' 1' 1' dt.Hour' dt.Minute' dt.Second' dt.Millisecond);
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,IsMarsEnabled,The following statement contains a magic number: if (conn.ConnectionString != null)  			{  				return conn.ConnectionString.Split(';')  					.Select(s => s.Split('='))  					.Where (s => s.Length == 2 && s[0].Trim().ToLower() == "multipleactiveresultsets")  					.Select(s => s[1].Trim().ToLower())  					.Any   (s => s == "true" || s == "1" || s == "yes");  			}
Magic Number,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlListUnionAll,The following statement contains a magic number: var valuesQuery = insertText.Substring(indexValuesWord + 9);
Magic Number,BLToolkit.Data.Linq.Builder,ConcatUnionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.Arguments.Count == 2 && methodCall.IsQueryable("Concat"' "Union");
Magic Number,BLToolkit.Data.Linq.Builder,UnionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,ConvertToIndex,The following statement contains a magic number: if (_isObject)  				{  					return ConvertToSql(expression' level' flags)  						.Select(idx =>  						{  							if (idx.Index < 0)  							{  								if (idx.Index == -2)  								{  									SqlQuery.Select.Columns.Add(new SqlQuery.Column(SqlQuery' idx.Sql));  									idx.Index = SqlQuery.Select.Columns.Count - 1;  								}  								else  								{  									idx.Index = SqlQuery.Select.Add(idx.Sql);  								}  							}    							return idx;  						})  						.ToArray();  				}
Magic Number,BLToolkit.Data.Linq.Builder,UnionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,ConvertToSql,The following statement contains a magic number: if (_isObject)  				{  					switch (flags)  					{  						case ConvertFlags.All   :  						case ConvertFlags.Key   :    							if (expression == null)  							{  								return _members.Values  									.Select(m => ConvertToSql(m.MemberExpression' 0' ConvertFlags.Field)[0])  									.ToArray();  							}    							break;    						case ConvertFlags.Field :    							if (expression != null && (level == 0 || level == 1) && expression.NodeType == ExpressionType.MemberAccess)  							{  								var levelExpression = expression.GetLevelExpression(1);    								if (expression == levelExpression)  								{  									var ma     = (MemberExpression)expression;  									var member = _members[ma.Member];    									if (member.SqlQueryInfo == null)  									{  										member.SqlQueryInfo = new SqlInfo(member.MemberExpression.Member)  										{  											Index = -2'  											Sql   = SubQuery.SqlQuery.Select.Columns[member.SequenceInfo.Index]'  											Query = SqlQuery'  										};  									}    									return new[] { member.SqlQueryInfo };  								}  							}    							break;  					}    					throw new InvalidOperationException();  				}
Magic Number,BLToolkit.Data.Linq.Builder,ContainsBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ContainsBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.IsQueryable("Contains") && methodCall.Arguments.Count == 2;
Magic Number,BLToolkit.Data.Linq.Builder,AllAnyBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AllAnyBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 2)  			{  				var condition = (LambdaExpression)ExpressionBuilder.GetPredicate(methodCall.Arguments[1]);    				if (methodCall.Method.Name == "All")  #if FW4 || SILVERLIGHT  					condition = Expression.Lambda(Expression.Not(condition.Body)' condition.Name' condition.Parameters);  #else  					condition = Expression.Lambda(Expression.Not(condition.Body)' condition.Parameters.ToArray());  #endif    				sequence = builder.BuildWhere(buildInfo.Parent' sequence' condition' true);  				sequence.SetAlias(condition.Parameters[0].Name);  			}
Magic Number,BLToolkit.Data.Linq.Builder,AllAnyBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AllAnyBuilder.cs,Convert,The following statement contains a magic number: if (methodCall.Arguments.Count == 2)  			{  				var predicate = (LambdaExpression)ExpressionBuilder.GetPredicate(methodCall.Arguments[1]);  				var info      = builder.ConvertSequence(new BuildInfo(buildInfo' methodCall.Arguments[0])' predicate.Parameters[0]);    				if (info != null)  				{  					info.Expression = methodCall.Convert(ex => ConvertMethod(methodCall' 0' info' predicate.Parameters[0]' ex));  					info.Parameter  = param;    					return info;  				}  			}  			else  			{  				var info = builder.ConvertSequence(new BuildInfo(buildInfo' methodCall.Arguments[0])' null);    				if (info != null)  				{  					info.Expression = methodCall.Convert(ex => ConvertMethod(methodCall' 0' info' null' ex));  					info.Parameter  = param;    					return info;  				}  			}
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: UpdateBuilder.BuildSetter(  				builder'  				buildInfo'  				(LambdaExpression)methodCall.Arguments[2].Unwrap()'  				sequence'  				sequence.SqlQuery.Update.Items'  				sequence);
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 3)  			{  				var table = sequence.SqlQuery.Insert.Into;  				var keys  = table.GetKeys(false);    				if (keys.Count == 0)  					throw new LinqException("InsertOrUpdate method requires the '{0}' table to have a primary key."' table.Name);    				var q =  				(  					from k in keys  					join i in sequence.SqlQuery.Insert.Items on k equals i.Column  					select new { k' i }  				).ToList();    				var missedKey = keys.Except(q.Select(i => i.k)).FirstOrDefault();    				if (missedKey != null)  					throw new LinqException("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."'  						table.Name'  						((SqlField)missedKey).Name);    				sequence.SqlQuery.Update.Keys.AddRange(q.Select(i => i.i));  			}  			else  			{  				UpdateBuilder.BuildSetter(  					builder'  					buildInfo'  					(LambdaExpression)methodCall.Arguments[3].Unwrap()'  					sequence'  					sequence.SqlQuery.Update.Keys'  					sequence);  			}
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 3)  			{  				var table = sequence.SqlQuery.Insert.Into;  				var keys  = table.GetKeys(false);    				if (keys.Count == 0)  					throw new LinqException("InsertOrUpdate method requires the '{0}' table to have a primary key."' table.Name);    				var q =  				(  					from k in keys  					join i in sequence.SqlQuery.Insert.Items on k equals i.Column  					select new { k' i }  				).ToList();    				var missedKey = keys.Except(q.Select(i => i.k)).FirstOrDefault();    				if (missedKey != null)  					throw new LinqException("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."'  						table.Name'  						((SqlField)missedKey).Name);    				sequence.SqlQuery.Update.Keys.AddRange(q.Select(i => i.i));  			}  			else  			{  				UpdateBuilder.BuildSetter(  					builder'  					buildInfo'  					(LambdaExpression)methodCall.Arguments[3].Unwrap()'  					sequence'  					sequence.SqlQuery.Update.Keys'  					sequence);  			}
Magic Number,BLToolkit.Data.Linq.Builder,IntersectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\IntersectBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.Arguments.Count == 2 && methodCall.IsQueryable("Except"' "Intersect");
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 : // int Update<T>(this IUpdateable<T> source)  					CheckAssociation(sequence);  					break;    				case 2 : // int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)  					{  						CheckAssociation(sequence);    						BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Update.Items'  							sequence);  						break;  					}    				case 3 :  					{  						var expr = methodCall.Arguments[1].Unwrap();    						if (expr is LambdaExpression)  						{  							// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  							//  							sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);    							CheckAssociation(sequence);    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								sequence'  								sequence.SqlQuery.Update.Items'  								sequence);  						}  						else  						{  							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  							//  							var into = builder.BuildSequence(new BuildInfo(buildInfo' expr' new SqlQuery()));    							sequence.ConvertToIndex(null' 0' ConvertFlags.All);  							sequence.SqlQuery.ResolveWeakJoins(new List<ISqlTableSource>());  							sequence.SqlQuery.Select.Columns.Clear();    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								into'  								sequence.SqlQuery.Update.Items'  								sequence);    							var sql = sequence.SqlQuery;    							sql.Select.Columns.Clear();    							foreach (var item in sql.Update.Items)  								sql.Select.Columns.Add(new SqlQuery.Column(sql' item.Expression));    							sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 : // int Update<T>(this IUpdateable<T> source)  					CheckAssociation(sequence);  					break;    				case 2 : // int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)  					{  						CheckAssociation(sequence);    						BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Update.Items'  							sequence);  						break;  					}    				case 3 :  					{  						var expr = methodCall.Arguments[1].Unwrap();    						if (expr is LambdaExpression)  						{  							// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  							//  							sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);    							CheckAssociation(sequence);    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								sequence'  								sequence.SqlQuery.Update.Items'  								sequence);  						}  						else  						{  							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  							//  							var into = builder.BuildSequence(new BuildInfo(buildInfo' expr' new SqlQuery()));    							sequence.ConvertToIndex(null' 0' ConvertFlags.All);  							sequence.SqlQuery.ResolveWeakJoins(new List<ISqlTableSource>());  							sequence.SqlQuery.Select.Columns.Clear();    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								into'  								sequence.SqlQuery.Update.Items'  								sequence);    							var sql = sequence.SqlQuery;    							sql.Select.Columns.Clear();    							foreach (var item in sql.Update.Items)  								sql.Select.Columns.Add(new SqlQuery.Column(sql' item.Expression));    							sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 : // int Update<T>(this IUpdateable<T> source)  					CheckAssociation(sequence);  					break;    				case 2 : // int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)  					{  						CheckAssociation(sequence);    						BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Update.Items'  							sequence);  						break;  					}    				case 3 :  					{  						var expr = methodCall.Arguments[1].Unwrap();    						if (expr is LambdaExpression)  						{  							// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  							//  							sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);    							CheckAssociation(sequence);    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								sequence'  								sequence.SqlQuery.Update.Items'  								sequence);  						}  						else  						{  							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  							//  							var into = builder.BuildSequence(new BuildInfo(buildInfo' expr' new SqlQuery()));    							sequence.ConvertToIndex(null' 0' ConvertFlags.All);  							sequence.SqlQuery.ResolveWeakJoins(new List<ISqlTableSource>());  							sequence.SqlQuery.Select.Columns.Clear();    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								into'  								sequence.SqlQuery.Update.Items'  								sequence);    							var sql = sequence.SqlQuery;    							sql.Select.Columns.Clear();    							foreach (var item in sql.Update.Items)  								sql.Select.Columns.Add(new SqlQuery.Column(sql' item.Expression));    							sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 : // int Update<T>(this IUpdateable<T> source)  					CheckAssociation(sequence);  					break;    				case 2 : // int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)  					{  						CheckAssociation(sequence);    						BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Update.Items'  							sequence);  						break;  					}    				case 3 :  					{  						var expr = methodCall.Arguments[1].Unwrap();    						if (expr is LambdaExpression)  						{  							// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  							//  							sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);    							CheckAssociation(sequence);    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								sequence'  								sequence.SqlQuery.Update.Items'  								sequence);  						}  						else  						{  							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  							//  							var into = builder.BuildSequence(new BuildInfo(buildInfo' expr' new SqlQuery()));    							sequence.ConvertToIndex(null' 0' ConvertFlags.All);  							sequence.SqlQuery.ResolveWeakJoins(new List<ISqlTableSource>());  							sequence.SqlQuery.Select.Columns.Clear();    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								into'  								sequence.SqlQuery.Update.Items'  								sequence);    							var sql = sequence.SqlQuery;    							sql.Select.Columns.Clear();    							foreach (var item in sql.Update.Items)  								sql.Select.Columns.Add(new SqlQuery.Column(sql' item.Expression));    							sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,Set,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: var update   =                   methodCall.Arguments[2].Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,DeleteBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\DeleteBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 2)  				sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 :   					// static int Insert<T>              (this IValueInsertable<T> source)  					// static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)  					{  						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Expr(item.Expression);  						break;  					}    				case 2 : // static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)  					{  						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Insert.Into  = ((TableBuilder.TableContext)sequence).SqlTable;  						sequence.SqlQuery.From.Tables.Clear();    						break;  					}    				case 3 : // static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  					{  						var into = builder.BuildSequence(new BuildInfo(buildInfo' methodCall.Arguments[1]' new SqlQuery()));    						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[2].Unwrap()'  							into'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Select.Columns.Clear();    						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Columns.Add(new SqlQuery.Column(sequence.SqlQuery' item.Expression));    						sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 :   					// static int Insert<T>              (this IValueInsertable<T> source)  					// static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)  					{  						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Expr(item.Expression);  						break;  					}    				case 2 : // static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)  					{  						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Insert.Into  = ((TableBuilder.TableContext)sequence).SqlTable;  						sequence.SqlQuery.From.Tables.Clear();    						break;  					}    				case 3 : // static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  					{  						var into = builder.BuildSequence(new BuildInfo(buildInfo' methodCall.Arguments[1]' new SqlQuery()));    						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[2].Unwrap()'  							into'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Select.Columns.Clear();    						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Columns.Add(new SqlQuery.Column(sequence.SqlQuery' item.Expression));    						sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count)  			{  				case 1 :   					// static int Insert<T>              (this IValueInsertable<T> source)  					// static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)  					{  						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Expr(item.Expression);  						break;  					}    				case 2 : // static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)  					{  						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Insert.Into  = ((TableBuilder.TableContext)sequence).SqlTable;  						sequence.SqlQuery.From.Tables.Clear();    						break;  					}    				case 3 : // static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  					{  						var into = builder.BuildSequence(new BuildInfo(buildInfo' methodCall.Arguments[1]' new SqlQuery()));    						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[2].Unwrap()'  							into'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Select.Columns.Clear();    						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Columns.Add(new SqlQuery.Column(sequence.SqlQuery' item.Expression));    						sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: foreach (var field in q)  			{  				var expr = builder.SqlProvider.GetIdentityExpression(insert.Into' field' false);    				if (expr != null)  				{  					insert.Items.Insert(0' new SqlQuery.SetExpression(field' expr));    					if (methodCall.Arguments.Count == 3)  					{  						sequence.SqlQuery.Select.Columns.Insert(0' new SqlQuery.Column(sequence.SqlQuery' insert.Items[0].Expression));  					}  				}  			}
Magic Number,BLToolkit.Data.Linq.Builder,Value,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: var update   =                   methodCall.Arguments[2].Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,SelectManyBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return  				methodCall.IsQueryable("SelectMany") &&  				methodCall.Arguments.Count == 3      &&  				((LambdaExpression)methodCall.Arguments[1].Unwrap()).Parameters.Count == 1;
Magic Number,BLToolkit.Data.Linq.Builder,SelectManyBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,BuildMethodCall,The following statement contains a magic number: var resultSelector     = (LambdaExpression)methodCall.Arguments[2].Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The following statement contains a magic number: var select = call.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The following statement contains a magic number: var select = call.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The following statement contains a magic number: var select = call.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The following statement contains a magic number: var select = call.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == "Select" && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The following statement contains a magic number: var elementSelector  = types.ContainsKey("TElement") ? (LambdaExpression)OptimizeExpression(method.Arguments[2].Unwrap()) : null;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The following statement contains a magic number: var resultSelector   = types.ContainsKey("TResult")  ?  				(LambdaExpression)OptimizeExpression(method.Arguments[types.ContainsKey("TElement") ? 3 : 2].Unwrap()) : null;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The following statement contains a magic number: var resultSelector   = types.ContainsKey("TResult")  ?  				(LambdaExpression)OptimizeExpression(method.Arguments[types.ContainsKey("TElement") ? 3 : 2].Unwrap()) : null;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelectMany,The following statement contains a magic number: if (method.Arguments.Count != 2 || ((LambdaExpression)method.Arguments[1].Unwrap()).Parameters.Count != 1)  				return method;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (method.Arguments.Count != 2)  				return method;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelector,The following statement contains a magic number: if (method.Arguments.Count != 2)  				return method;
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ?  				EnumerableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments().Length == 2) :  				QueryableMethods  					.Where(m => m.Name == name && m.GetParameters().Length == 2)  					.First(m => m.GetParameters()[1].ParameterType.GetGenericArguments()[0].GetGenericArguments().Length == 2);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.AndAlso            :  				case ExpressionType.OrElse             :  				case ExpressionType.Not                :  				case ExpressionType.Equal              :  				case ExpressionType.NotEqual           :  				case ExpressionType.GreaterThan        :  				case ExpressionType.GreaterThanOrEqual :  				case ExpressionType.LessThan           :  				case ExpressionType.LessThanOrEqual    :  					{  						var condition = new SqlQuery.SearchCondition();  						BuildSearchCondition(context' expression' condition.Conditions);  						return condition;  					}    				case ExpressionType.And                :  				case ExpressionType.Or                 :  					{  						if (expression.Type == typeof(bool))  							goto case ExpressionType.AndAlso;  						goto case ExpressionType.Add;  					}    				case ExpressionType.Add                :  				case ExpressionType.AddChecked         :  				case ExpressionType.Divide             :  				case ExpressionType.ExclusiveOr        :  				case ExpressionType.Modulo             :  				case ExpressionType.Multiply           :  				case ExpressionType.MultiplyChecked    :  				case ExpressionType.Power              :  				case ExpressionType.Subtract           :  				case ExpressionType.SubtractChecked    :  				case ExpressionType.Coalesce           :  					{  						var e = (BinaryExpression)expression;  						var l = ConvertToSql(context' e.Left'  false);  						var r = ConvertToSql(context' e.Right' false);  						var t = e.Type;    						switch (expression.NodeType)  						{  							case ExpressionType.Add             :  							case ExpressionType.AddChecked      : return Convert(context' new SqlBinaryExpression(t' l' "+"' r' Precedence.Additive));  							case ExpressionType.And             : return Convert(context' new SqlBinaryExpression(t' l' "&"' r' Precedence.Bitwise));  							case ExpressionType.Divide          : return Convert(context' new SqlBinaryExpression(t' l' "/"' r' Precedence.Multiplicative));  							case ExpressionType.ExclusiveOr     : return Convert(context' new SqlBinaryExpression(t' l' "^"' r' Precedence.Bitwise));  							case ExpressionType.Modulo          : return Convert(context' new SqlBinaryExpression(t' l' "%"' r' Precedence.Multiplicative));  							case ExpressionType.Multiply:  							case ExpressionType.MultiplyChecked : return Convert(context' new SqlBinaryExpression(t' l' "*"' r' Precedence.Multiplicative));  							case ExpressionType.Or              : return Convert(context' new SqlBinaryExpression(t' l' "|"' r' Precedence.Bitwise));  							case ExpressionType.Power           : return Convert(context' new SqlFunction(t' "Power"' l' r));  							case ExpressionType.Subtract        :  							case ExpressionType.SubtractChecked : return Convert(context' new SqlBinaryExpression(t' l' "-"' r' Precedence.Subtraction));  							case ExpressionType.Coalesce        :  								{  									if (r is SqlFunction)  									{  										var c = (SqlFunction)r;    										if (c.Name == "Coalesce")  										{  											var parms = new ISqlExpression[c.Parameters.Length + 1];    											parms[0] = l;  											c.Parameters.CopyTo(parms' 1);    											return Convert(context' new SqlFunction(t' "Coalesce"' parms));  										}  									}    									return Convert(context' new SqlFunction(t' "Coalesce"' l' r));  								}  						}    						break;  					}    				case ExpressionType.UnaryPlus      :  				case ExpressionType.Negate         :  				case ExpressionType.NegateChecked  :  					{  						var e = (UnaryExpression)expression;  						var o = ConvertToSql(context' e.Operand' false);  						var t = e.Type;    						switch (expression.NodeType)  						{  							case ExpressionType.UnaryPlus     : return o;  							case ExpressionType.Negate        :  							case ExpressionType.NegateChecked :  								return Convert(context' new SqlBinaryExpression(t' new SqlValue(-1)' "*"' o' Precedence.Multiplicative));  						}    						break;  					}    				case ExpressionType.Convert        :  				case ExpressionType.ConvertChecked :  					{  						var e = (UnaryExpression)expression;  						var o = ConvertToSql(context' e.Operand' false);    						if (e.Method == null && e.IsLifted)  							return o;    						var t = e.Operand.Type;  						var s = SqlDataType.GetDataType(t);    						if (o.SystemType != null && s.Type == typeof(object))  						{  							t = o.SystemType;  							s = SqlDataType.GetDataType(t);  						}    						if (e.Type == t ||  							t.IsEnum && Enum.GetUnderlyingType(t) == e.Type ||  							e.Type.IsEnum && Enum.GetUnderlyingType(e.Type) == t)  							return o;    						return Convert(  							context'  							new SqlFunction(e.Type' "$Convert$"' SqlDataType.GetDataType(e.Type)' s' o));  					}    				case ExpressionType.Conditional    :  					{  						var e = (ConditionalExpression)expression;  						var s = ConvertToSql(context' e.Test'    false);  						var t = ConvertToSql(context' e.IfTrue'  false);  						var f = ConvertToSql(context' e.IfFalse' false);    						if (f is SqlFunction)  						{  							var c = (SqlFunction)f;    							if (c.Name == "CASE")  							{  								var parms = new ISqlExpression[c.Parameters.Length + 2];    								parms[0] = s;  								parms[1] = t;  								c.Parameters.CopyTo(parms' 2);    								return Convert(context' new SqlFunction(e.Type' "CASE"' parms));  							}  						}    						return Convert(context' new SqlFunction(e.Type' "CASE"' s' t' f));  					}    				case ExpressionType.MemberAccess :  					{  						var ma   = (MemberExpression)expression;  						var attr = GetFunctionAttribute(ma.Member);    						if (attr != null)  							return Convert(context' attr.GetExpression(ma.Member));    						var ctx = GetContext(context' expression);    						if (ctx != null)  						{  							var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    							switch (sql.Length)  							{  								case 0  : break;  								case 1  : return sql[0].Sql;  								default : throw new InvalidOperationException();  							}  						}    						break;  					}    				case ExpressionType.Parameter   :  					{  						var ctx = GetContext(context' expression);    						if (ctx != null)  						{  							var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    							switch (sql.Length)  							{  								case 0  : break;  								case 1  : return sql[0].Sql;  								default : throw new InvalidOperationException();  							}  						}    						break;  					}    				case ExpressionType.Call        :  					{  						var e = (MethodCallExpression)expression;    						if (e.IsQueryable())  						{  							if (IsSubQuery(context' e))  								return SubQueryToSql(context' e);    							if (CountBuilder.MethodNames.Concat(AggregationBuilder.MethodNames).Contains(e.Method.Name))  							{  								var ctx = GetContext(context' expression);    								if (ctx != null)  								{  									var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    									if (sql.Length != 1)  										throw new InvalidOperationException();    									return sql[0].Sql;  								}    								break;  							}    							return SubQueryToSql(context' e);  						}    						var attr = GetFunctionAttribute(e.Method);    						if (attr != null)  						{  							var parms = new List<ISqlExpression>();    							if (e.Object != null)  								parms.Add(ConvertToSql(context' e.Object' false));    							parms.AddRange(e.Arguments.Select(t => ConvertToSql(context' t' false)));    							return Convert(context' attr.GetExpression(e.Method' parms.ToArray()));  						}    						break;  					}    				case ExpressionType.Invoke :  					{  						var pi = (InvocationExpression)expression;  						var ex = pi.Expression;    						if (ex.NodeType == ExpressionType.Quote)  							ex = ((UnaryExpression)ex).Operand;    						if (ex.NodeType == ExpressionType.Lambda)  						{  							var l   = (LambdaExpression)ex;  							var dic = new Dictionary<Expression'Expression>();    							for (var i = 0; i < l.Parameters.Count; i++)  								dic.Add(l.Parameters[i]' pi.Arguments[i]);    							var pie = l.Body.Convert(wpi =>  							{  								Expression ppi;  								return dic.TryGetValue(wpi' out ppi) ? ppi : wpi;  							});    							return ConvertToSql(context' pie' false);  						}    						break;  					}    				case ExpressionType.TypeIs :  					{  						var condition = new SqlQuery.SearchCondition();  						BuildSearchCondition(context' expression' condition.Conditions);  						return condition;  					}    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					return ConvertToSql(context' ((ChangeTypeExpression)expression).Expression' false);  			}
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.AndAlso            :  				case ExpressionType.OrElse             :  				case ExpressionType.Not                :  				case ExpressionType.Equal              :  				case ExpressionType.NotEqual           :  				case ExpressionType.GreaterThan        :  				case ExpressionType.GreaterThanOrEqual :  				case ExpressionType.LessThan           :  				case ExpressionType.LessThanOrEqual    :  					{  						var condition = new SqlQuery.SearchCondition();  						BuildSearchCondition(context' expression' condition.Conditions);  						return condition;  					}    				case ExpressionType.And                :  				case ExpressionType.Or                 :  					{  						if (expression.Type == typeof(bool))  							goto case ExpressionType.AndAlso;  						goto case ExpressionType.Add;  					}    				case ExpressionType.Add                :  				case ExpressionType.AddChecked         :  				case ExpressionType.Divide             :  				case ExpressionType.ExclusiveOr        :  				case ExpressionType.Modulo             :  				case ExpressionType.Multiply           :  				case ExpressionType.MultiplyChecked    :  				case ExpressionType.Power              :  				case ExpressionType.Subtract           :  				case ExpressionType.SubtractChecked    :  				case ExpressionType.Coalesce           :  					{  						var e = (BinaryExpression)expression;  						var l = ConvertToSql(context' e.Left'  false);  						var r = ConvertToSql(context' e.Right' false);  						var t = e.Type;    						switch (expression.NodeType)  						{  							case ExpressionType.Add             :  							case ExpressionType.AddChecked      : return Convert(context' new SqlBinaryExpression(t' l' "+"' r' Precedence.Additive));  							case ExpressionType.And             : return Convert(context' new SqlBinaryExpression(t' l' "&"' r' Precedence.Bitwise));  							case ExpressionType.Divide          : return Convert(context' new SqlBinaryExpression(t' l' "/"' r' Precedence.Multiplicative));  							case ExpressionType.ExclusiveOr     : return Convert(context' new SqlBinaryExpression(t' l' "^"' r' Precedence.Bitwise));  							case ExpressionType.Modulo          : return Convert(context' new SqlBinaryExpression(t' l' "%"' r' Precedence.Multiplicative));  							case ExpressionType.Multiply:  							case ExpressionType.MultiplyChecked : return Convert(context' new SqlBinaryExpression(t' l' "*"' r' Precedence.Multiplicative));  							case ExpressionType.Or              : return Convert(context' new SqlBinaryExpression(t' l' "|"' r' Precedence.Bitwise));  							case ExpressionType.Power           : return Convert(context' new SqlFunction(t' "Power"' l' r));  							case ExpressionType.Subtract        :  							case ExpressionType.SubtractChecked : return Convert(context' new SqlBinaryExpression(t' l' "-"' r' Precedence.Subtraction));  							case ExpressionType.Coalesce        :  								{  									if (r is SqlFunction)  									{  										var c = (SqlFunction)r;    										if (c.Name == "Coalesce")  										{  											var parms = new ISqlExpression[c.Parameters.Length + 1];    											parms[0] = l;  											c.Parameters.CopyTo(parms' 1);    											return Convert(context' new SqlFunction(t' "Coalesce"' parms));  										}  									}    									return Convert(context' new SqlFunction(t' "Coalesce"' l' r));  								}  						}    						break;  					}    				case ExpressionType.UnaryPlus      :  				case ExpressionType.Negate         :  				case ExpressionType.NegateChecked  :  					{  						var e = (UnaryExpression)expression;  						var o = ConvertToSql(context' e.Operand' false);  						var t = e.Type;    						switch (expression.NodeType)  						{  							case ExpressionType.UnaryPlus     : return o;  							case ExpressionType.Negate        :  							case ExpressionType.NegateChecked :  								return Convert(context' new SqlBinaryExpression(t' new SqlValue(-1)' "*"' o' Precedence.Multiplicative));  						}    						break;  					}    				case ExpressionType.Convert        :  				case ExpressionType.ConvertChecked :  					{  						var e = (UnaryExpression)expression;  						var o = ConvertToSql(context' e.Operand' false);    						if (e.Method == null && e.IsLifted)  							return o;    						var t = e.Operand.Type;  						var s = SqlDataType.GetDataType(t);    						if (o.SystemType != null && s.Type == typeof(object))  						{  							t = o.SystemType;  							s = SqlDataType.GetDataType(t);  						}    						if (e.Type == t ||  							t.IsEnum && Enum.GetUnderlyingType(t) == e.Type ||  							e.Type.IsEnum && Enum.GetUnderlyingType(e.Type) == t)  							return o;    						return Convert(  							context'  							new SqlFunction(e.Type' "$Convert$"' SqlDataType.GetDataType(e.Type)' s' o));  					}    				case ExpressionType.Conditional    :  					{  						var e = (ConditionalExpression)expression;  						var s = ConvertToSql(context' e.Test'    false);  						var t = ConvertToSql(context' e.IfTrue'  false);  						var f = ConvertToSql(context' e.IfFalse' false);    						if (f is SqlFunction)  						{  							var c = (SqlFunction)f;    							if (c.Name == "CASE")  							{  								var parms = new ISqlExpression[c.Parameters.Length + 2];    								parms[0] = s;  								parms[1] = t;  								c.Parameters.CopyTo(parms' 2);    								return Convert(context' new SqlFunction(e.Type' "CASE"' parms));  							}  						}    						return Convert(context' new SqlFunction(e.Type' "CASE"' s' t' f));  					}    				case ExpressionType.MemberAccess :  					{  						var ma   = (MemberExpression)expression;  						var attr = GetFunctionAttribute(ma.Member);    						if (attr != null)  							return Convert(context' attr.GetExpression(ma.Member));    						var ctx = GetContext(context' expression);    						if (ctx != null)  						{  							var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    							switch (sql.Length)  							{  								case 0  : break;  								case 1  : return sql[0].Sql;  								default : throw new InvalidOperationException();  							}  						}    						break;  					}    				case ExpressionType.Parameter   :  					{  						var ctx = GetContext(context' expression);    						if (ctx != null)  						{  							var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    							switch (sql.Length)  							{  								case 0  : break;  								case 1  : return sql[0].Sql;  								default : throw new InvalidOperationException();  							}  						}    						break;  					}    				case ExpressionType.Call        :  					{  						var e = (MethodCallExpression)expression;    						if (e.IsQueryable())  						{  							if (IsSubQuery(context' e))  								return SubQueryToSql(context' e);    							if (CountBuilder.MethodNames.Concat(AggregationBuilder.MethodNames).Contains(e.Method.Name))  							{  								var ctx = GetContext(context' expression);    								if (ctx != null)  								{  									var sql = ctx.ConvertToSql(expression' 0' ConvertFlags.Field);    									if (sql.Length != 1)  										throw new InvalidOperationException();    									return sql[0].Sql;  								}    								break;  							}    							return SubQueryToSql(context' e);  						}    						var attr = GetFunctionAttribute(e.Method);    						if (attr != null)  						{  							var parms = new List<ISqlExpression>();    							if (e.Object != null)  								parms.Add(ConvertToSql(context' e.Object' false));    							parms.AddRange(e.Arguments.Select(t => ConvertToSql(context' t' false)));    							return Convert(context' attr.GetExpression(e.Method' parms.ToArray()));  						}    						break;  					}    				case ExpressionType.Invoke :  					{  						var pi = (InvocationExpression)expression;  						var ex = pi.Expression;    						if (ex.NodeType == ExpressionType.Quote)  							ex = ((UnaryExpression)ex).Operand;    						if (ex.NodeType == ExpressionType.Lambda)  						{  							var l   = (LambdaExpression)ex;  							var dic = new Dictionary<Expression'Expression>();    							for (var i = 0; i < l.Parameters.Count; i++)  								dic.Add(l.Parameters[i]' pi.Arguments[i]);    							var pie = l.Body.Convert(wpi =>  							{  								Expression ppi;  								return dic.TryGetValue(wpi' out ppi) ? ppi : wpi;  							});    							return ConvertToSql(context' pie' false);  						}    						break;  					}    				case ExpressionType.TypeIs :  					{  						var condition = new SqlQuery.SearchCondition();  						BuildSearchCondition(context' expression' condition.Conditions);  						return condition;  					}    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					return ConvertToSql(context' ((ChangeTypeExpression)expression).Expression' false);  			}
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Equal              :  				case ExpressionType.NotEqual           :  				case ExpressionType.GreaterThan        :  				case ExpressionType.GreaterThanOrEqual :  				case ExpressionType.LessThan           :  				case ExpressionType.LessThanOrEqual    :  					{  						var e = (BinaryExpression)expression;  						return ConvertCompare(context' expression.NodeType' e.Left' e.Right);  					}    				case ExpressionType.Call               :  					{  						var e = (MethodCallExpression)expression;    						ISqlPredicate predicate = null;    						if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  							return ConvertCompare(context' ExpressionType.Equal' e.Object' e.Arguments[0]);    						if (e.Method.DeclaringType == typeof(string))  						{  							switch (e.Method.Name)  							{  								case "Contains"   : predicate = ConvertLikePredicate(context' e' "%"' "%"); break;  								case "StartsWith" : predicate = ConvertLikePredicate(context' e' ""'  "%"); break;  								case "EndsWith"   : predicate = ConvertLikePredicate(context' e' "%"' "");  break;  							}  						}  						else if (e.Method.Name == "Contains")  						{  							if (e.Method.DeclaringType == typeof(Enumerable) ||  							    TypeHelper.IsSameOrParent(typeof(IList)' e.Method.DeclaringType) ||  							    TypeHelper.IsSameOrParent(typeof(ICollection<>)' e.Method.DeclaringType))  							{  								predicate = ConvertInPredicate(context' e);  							}  						}  						else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent(typeof(Dictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(Dictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[1]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Values")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  						else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent(typeof(IDictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(IDictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[0]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Keys")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  #if !SILVERLIGHT  						else if (e.Method == ReflectionHelper.Functions.String.Like11) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like12) predicate = ConvertLikePredicate(context' e);  #endif  						else if (e.Method == ReflectionHelper.Functions.String.Like21) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like22) predicate = ConvertLikePredicate(context' e);    						if (predicate != null)  							return Convert(context' predicate);    						break;  					}    				case ExpressionType.Conditional  :  					return Convert(context'  						new SqlQuery.Predicate.ExprExpr(  							ConvertToSql(context' expression' false)'  							SqlQuery.Predicate.Operator.Equal'  							new SqlValue(true)));    				case ExpressionType.MemberAccess :  					{  						var e = (MemberExpression)expression;    						if (e.Member.Name == "HasValue" &&   							e.Member.DeclaringType.IsGenericType &&   							e.Member.DeclaringType.GetGenericTypeDefinition() == typeof(Nullable<>))  						{  							var expr = ConvertToSql(context' e.Expression' false);  							return Convert(context' new SqlQuery.Predicate.IsNull(expr' true));  						}    						break;  					}    				case ExpressionType.TypeIs:  					{  						var e   = (TypeBinaryExpression)expression;  						var ctx = GetContext(context' e.Expression);    						if (ctx != null && ctx.IsExpression(e.Expression' 0' RequestFor.Table).Result)  							return MakeIsPredicate(ctx' e);    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Equal              :  				case ExpressionType.NotEqual           :  				case ExpressionType.GreaterThan        :  				case ExpressionType.GreaterThanOrEqual :  				case ExpressionType.LessThan           :  				case ExpressionType.LessThanOrEqual    :  					{  						var e = (BinaryExpression)expression;  						return ConvertCompare(context' expression.NodeType' e.Left' e.Right);  					}    				case ExpressionType.Call               :  					{  						var e = (MethodCallExpression)expression;    						ISqlPredicate predicate = null;    						if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  							return ConvertCompare(context' ExpressionType.Equal' e.Object' e.Arguments[0]);    						if (e.Method.DeclaringType == typeof(string))  						{  							switch (e.Method.Name)  							{  								case "Contains"   : predicate = ConvertLikePredicate(context' e' "%"' "%"); break;  								case "StartsWith" : predicate = ConvertLikePredicate(context' e' ""'  "%"); break;  								case "EndsWith"   : predicate = ConvertLikePredicate(context' e' "%"' "");  break;  							}  						}  						else if (e.Method.Name == "Contains")  						{  							if (e.Method.DeclaringType == typeof(Enumerable) ||  							    TypeHelper.IsSameOrParent(typeof(IList)' e.Method.DeclaringType) ||  							    TypeHelper.IsSameOrParent(typeof(ICollection<>)' e.Method.DeclaringType))  							{  								predicate = ConvertInPredicate(context' e);  							}  						}  						else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent(typeof(Dictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(Dictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[1]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Values")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  						else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent(typeof(IDictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(IDictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[0]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Keys")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  #if !SILVERLIGHT  						else if (e.Method == ReflectionHelper.Functions.String.Like11) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like12) predicate = ConvertLikePredicate(context' e);  #endif  						else if (e.Method == ReflectionHelper.Functions.String.Like21) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like22) predicate = ConvertLikePredicate(context' e);    						if (predicate != null)  							return Convert(context' predicate);    						break;  					}    				case ExpressionType.Conditional  :  					return Convert(context'  						new SqlQuery.Predicate.ExprExpr(  							ConvertToSql(context' expression' false)'  							SqlQuery.Predicate.Operator.Equal'  							new SqlValue(true)));    				case ExpressionType.MemberAccess :  					{  						var e = (MemberExpression)expression;    						if (e.Member.Name == "HasValue" &&   							e.Member.DeclaringType.IsGenericType &&   							e.Member.DeclaringType.GetGenericTypeDefinition() == typeof(Nullable<>))  						{  							var expr = ConvertToSql(context' e.Expression' false);  							return Convert(context' new SqlQuery.Predicate.IsNull(expr' true));  						}    						break;  					}    				case ExpressionType.TypeIs:  					{  						var e   = (TypeBinaryExpression)expression;  						var ctx = GetContext(context' e.Expression);    						if (ctx != null && ctx.IsExpression(e.Expression' 0' RequestFor.Table).Result)  							return MakeIsPredicate(ctx' e);    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The following statement contains a magic number: if (e.Arguments.Count == 3)  				a3 = ConvertToSql(context' e.Arguments[2]' false);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The following statement contains a magic number: if (e.Arguments.Count == 3)  				a3 = ConvertToSql(context' e.Arguments[2]' false);
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,The following statement contains a magic number: switch (expression.NodeType)  			{  				// new { ... }  				//  				case ExpressionType.New        :  					{  						var expr = (NewExpression)expression;    // ReSharper disable ConditionIsAlwaysTrueOrFalse  // ReSharper disable HeuristicUnreachableCode  						if (expr.Members == null)  							return false;  // ReSharper restore HeuristicUnreachableCode  // ReSharper restore ConditionIsAlwaysTrueOrFalse    						for (var i = 0; i < expr.Members.Count; i++)  						{  							var member = expr.Members[i];    							members.Add(member' expr.Arguments[i]);    							if (member is MethodInfo)  								members.Add(TypeHelper.GetPropertyByMethod((MethodInfo)member)' expr.Arguments[i]);  						}    						return true;  					}    				// new MyObject { ... }  				//  				case ExpressionType.MemberInit :  					{  						var expr = (MemberInitExpression)expression;  						var dic  = TypeAccessor.GetAccessor(expr.Type)  							.Select((m'i) => new { m' i })  							.ToDictionary(_ => _.m.MemberInfo.Name' _ => _.i);    						foreach (var binding in expr.Bindings.Cast<MemberAssignment>().OrderBy(b => dic.ContainsKey(b.Member.Name) ? dic[b.Member.Name] : 1000000))  						{  							members.Add(binding.Member' binding.Expression);    							if (binding.Member is MethodInfo)  								members.Add(TypeHelper.GetPropertyByMethod((MethodInfo)binding.Member)' binding.Expression);  						}    						return true;  					}    				// .Select(p => everything else)  				//  				default                        :  					return false;  			}
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,AddResultQ,The following statement contains a magic number: var elemArg = GetLambda(body' 0' 2).Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,AddResultE,The following statement contains a magic number: var elemArg = GetLambda(body' 0' 2).Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryQ,The following statement contains a magic number: var elemArg = GetLambda(body' 2).   Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryE,The following statement contains a magic number: var elemArg = GetLambda(body' 2).   Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryResultQ,The following statement contains a magic number: var elemArg = GetLambda(body' 0' 2).   Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,WrapInSubQueryResultE,The following statement contains a magic number: var elemArg = GetLambda(body' 0' 2).   Parameters[0];
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,Convert,The following statement contains a magic number: var expr = body.Convert(ex =>  				{  					if (ex == func.Parameters[0])  						return _sourceExpression;    					if (ex == func.Parameters[1])  						return _keySelector.Body.Convert(e => e == _keySelector.Parameters[0] ? keyArg : e);    					if (ex == func.Parameters[2])  					{  						Expression obj = elemArg;    						if (_wrapInSubQuery)  							obj = Expression.PropertyOrField(elemArg' "Element");    						if (_elementSelector == null)  							return obj;    						return _elementSelector.Body.Convert(e => e == _elementSelector.Parameters[0] ? obj : e);  					}    					if (ex == func.Parameters[3])  						return _resultSelector.Body.Convert(e =>  						{  							if (e == _resultSelector.Parameters[0])  								return Expression.PropertyOrField(resArg' "Key");    							if (e == _resultSelector.Parameters[1])  								return resArg;    							return e;  						});    					return ex;  				});
Magic Number,BLToolkit.Data.Linq.Builder,GroupByHelper<TSource;TKey;TElement;TResult>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,Convert,The following statement contains a magic number: var expr = body.Convert(ex =>  				{  					if (ex == func.Parameters[0])  						return _sourceExpression;    					if (ex == func.Parameters[1])  						return _keySelector.Body.Convert(e => e == _keySelector.Parameters[0] ? keyArg : e);    					if (ex == func.Parameters[2])  					{  						Expression obj = elemArg;    						if (_wrapInSubQuery)  							obj = Expression.PropertyOrField(elemArg' "Element");    						if (_elementSelector == null)  							return obj;    						return _elementSelector.Body.Convert(e => e == _elementSelector.Parameters[0] ? obj : e);  					}    					if (ex == func.Parameters[3])  						return _resultSelector.Body.Convert(e =>  						{  							if (e == _resultSelector.Parameters[0])  								return Expression.PropertyOrField(resArg' "Key");    							if (e == _resultSelector.Parameters[1])  								return resArg;    							return e;  						});    					return ex;  				});
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (!buildInfo.IsSubQuery || builder.SqlProvider.IsSubQueryTakeSupported)  				switch (methodCall.Method.Name)  				{  					case "First"           :  					case "FirstOrDefault"  :  						take = 1;  						break;    					case "Single"          :  					case "SingleOrDefault" :  						if (!buildInfo.IsSubQuery)  							take = 2;  						break;  				}
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,Convert,The following statement contains a magic number: if (methodCall.Arguments.Count == 2)  			{  				var predicate = (LambdaExpression)ExpressionBuilder.GetPredicate(methodCall.Arguments[1]);  				var info      = builder.ConvertSequence(new BuildInfo(buildInfo' methodCall.Arguments[0])' predicate.Parameters[0]);    				if (info != null)  				{  					info.Expression = methodCall.Convert(ex => ConvertMethod(methodCall' 0' info' predicate.Parameters[0]' ex));  					info.Parameter  = param;    					return info;  				}  			}  			else  			{  				var info = builder.ConvertSequence(new BuildInfo(buildInfo' methodCall.Arguments[0])' null);    				if (info != null)  				{  					info.Expression = methodCall.Convert(ex => ConvertMethod(methodCall' 0' info' null' ex));  					info.Parameter  = param;    					return info;  				}  			}
Magic Number,BLToolkit.Data.Linq.Builder,GroupByBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,BuildMethodCall,The following statement contains a magic number: var elementSelector = (LambdaExpression)methodCall.Arguments[2].Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,GroupByContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,ConvertEnumerable,The following statement contains a magic number: if (AggregationBuilder.MethodNames.Contains(call.Method.Name))  				{  					if (call.Arguments[0].NodeType == ExpressionType.Call)  					{  						var arg = (MethodCallExpression)call.Arguments[0];    						if (arg.Method.Name == "Select")  						{  							if (arg.Arguments[0].NodeType != ExpressionType.Call)  							{  								var l     = (LambdaExpression)arg.Arguments[1].Unwrap();  								var largs = l.Type.GetGenericArguments();    								if (largs.Length == 2)  								{  									var p   = _element.Parent;  									var ctx = new ExpressionContext(Parent' _element' l);  									var sql = Builder.ConvertToSql(ctx' l.Body' true);    									Builder.ReplaceParent(ctx' p);    									return new SqlFunction(call.Type' call.Method.Name' sql);  								}  							}  						}  					}  				}
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: if (!methodCall.IsQueryable("Join"' "GroupJoin") || methodCall.Arguments.Count != 5)  				return false;
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: var body = ((LambdaExpression)methodCall.Arguments[2].Unwrap()).Body.Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The following statement contains a magic number: var selector = (LambdaExpression)methodCall.Arguments[4].Unwrap();
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The following statement contains a magic number: var outerKeyLambda = ((LambdaExpression)methodCall.Arguments[2].Unwrap());
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The following statement contains a magic number: var innerKeyLambda = ((LambdaExpression)methodCall.Arguments[3].Unwrap());
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: switch (memberExpression.NodeType)  			{  				case ExpressionType.MemberAccess :  				case ExpressionType.Parameter    :  					if (sequence != null)  						return action(2' sequence' newExpression' nextLevel' memberExpression);  					break;  					//throw new InvalidOperationException();    				case ExpressionType.New          :  				case ExpressionType.MemberInit   :  					{  						var mmExpresion = GetMemberExpression(memberExpression' expression' level + 1);  						return action(3' this' mmExpresion' 0' memberExpression);  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: switch (memberExpression.NodeType)  			{  				case ExpressionType.MemberAccess :  				case ExpressionType.Parameter    :  					if (sequence != null)  						return action(2' sequence' newExpression' nextLevel' memberExpression);  					break;  					//throw new InvalidOperationException();    				case ExpressionType.New          :  				case ExpressionType.MemberInit   :  					{  						var mmExpresion = GetMemberExpression(memberExpression' expression' level + 1);  						return action(3' this' mmExpresion' 0' memberExpression);  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,SelectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: if (methodCall.IsQueryable("Select"))  			{  				switch (((LambdaExpression)methodCall.Arguments[1].Unwrap()).Parameters.Count)  				{  					case 1 :  					case 2 : return true;  					default: break;  				}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find(builder' buildInfo' (n'ctx) =>  			{  				switch (n)  				{  					case 0 : return null;  					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  					case 2 :  					case 3 : return new TableContext(builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments()[0]);  					case 4 : return ctx.GetContext(buildInfo.Expression' 0' buildInfo);  					case 5 : return new TableContext(builder' buildInfo);  				}    				throw new InvalidOperationException();  			});
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find(builder' buildInfo' (n'ctx) =>  			{  				switch (n)  				{  					case 0 : return null;  					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  					case 2 :  					case 3 : return new TableContext(builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments()[0]);  					case 4 : return ctx.GetContext(buildInfo.Expression' 0' buildInfo);  					case 5 : return new TableContext(builder' buildInfo);  				}    				throw new InvalidOperationException();  			});
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find(builder' buildInfo' (n'ctx) =>  			{  				switch (n)  				{  					case 0 : return null;  					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  					case 2 :  					case 3 : return new TableContext(builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments()[0]);  					case 4 : return ctx.GetContext(buildInfo.Expression' 0' buildInfo);  					case 5 : return new TableContext(builder' buildInfo);  				}    				throw new InvalidOperationException();  			});
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find(builder' buildInfo' (n'ctx) =>  			{  				switch (n)  				{  					case 0 : return null;  					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  					case 2 :  					case 3 : return new TableContext(builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments()[0]);  					case 4 : return ctx.GetContext(buildInfo.Expression' 0' buildInfo);  					case 5 : return new TableContext(builder' buildInfo);  				}    				throw new InvalidOperationException();  			});
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: switch (part)  			{  				case DateParts.Year        : return date.Value.AddYears       ((int)number);  				case DateParts.Quarter     : return date.Value.AddMonths      ((int)number * 3);  				case DateParts.Month       : return date.Value.AddMonths      ((int)number);  				case DateParts.DayOfYear   : return date.Value.AddDays        (number.Value);  				case DateParts.Day         : return date.Value.AddDays        (number.Value);  				case DateParts.Week        : return date.Value.AddDays        (number.Value * 7);  				case DateParts.WeekDay     : return date.Value.AddDays        (number.Value);  				case DateParts.Hour        : return date.Value.AddHours       (number.Value);  				case DateParts.Minute      : return date.Value.AddMinutes     (number.Value);  				case DateParts.Second      : return date.Value.AddSeconds     (number.Value);  				case DateParts.Millisecond : return date.Value.AddMilliseconds(number.Value);  			}
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: switch (part)  			{  				case DateParts.Year        : return date.Value.AddYears       ((int)number);  				case DateParts.Quarter     : return date.Value.AddMonths      ((int)number * 3);  				case DateParts.Month       : return date.Value.AddMonths      ((int)number);  				case DateParts.DayOfYear   : return date.Value.AddDays        (number.Value);  				case DateParts.Day         : return date.Value.AddDays        (number.Value);  				case DateParts.Week        : return date.Value.AddDays        (number.Value * 7);  				case DateParts.WeekDay     : return date.Value.AddDays        (number.Value);  				case DateParts.Hour        : return date.Value.AddHours       (number.Value);  				case DateParts.Minute      : return date.Value.AddMinutes     (number.Value);  				case DateParts.Second      : return date.Value.AddSeconds     (number.Value);  				case DateParts.Millisecond : return date.Value.AddMilliseconds(number.Value);  			}
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part)  			{  				case DateParts.Year        : return date.Value.Year;  				case DateParts.Quarter     : return (date.Value.Month - 1) / 3 + 1;  				case DateParts.Month       : return date.Value.Month;  				case DateParts.DayOfYear   : return date.Value.DayOfYear;  				case DateParts.Day         : return date.Value.Day;  				case DateParts.Week        : return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear(date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  				case DateParts.WeekDay     : return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  				case DateParts.Hour        : return date.Value.Hour;  				case DateParts.Minute      : return date.Value.Minute;  				case DateParts.Second      : return date.Value.Second;  				case DateParts.Millisecond : return date.Value.Millisecond;  			}
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part)  			{  				case DateParts.Year        : return date.Value.Year;  				case DateParts.Quarter     : return (date.Value.Month - 1) / 3 + 1;  				case DateParts.Month       : return date.Value.Month;  				case DateParts.DayOfYear   : return date.Value.DayOfYear;  				case DateParts.Day         : return date.Value.Day;  				case DateParts.Week        : return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear(date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  				case DateParts.WeekDay     : return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  				case DateParts.Hour        : return date.Value.Hour;  				case DateParts.Minute      : return date.Value.Minute;  				case DateParts.Second      : return date.Value.Second;  				case DateParts.Millisecond : return date.Value.Millisecond;  			}
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part)  			{  				case DateParts.Year        : return date.Value.Year;  				case DateParts.Quarter     : return (date.Value.Month - 1) / 3 + 1;  				case DateParts.Month       : return date.Value.Month;  				case DateParts.DayOfYear   : return date.Value.DayOfYear;  				case DateParts.Day         : return date.Value.Day;  				case DateParts.Week        : return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear(date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  				case DateParts.WeekDay     : return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  				case DateParts.Hour        : return date.Value.Hour;  				case DateParts.Minute      : return date.Value.Minute;  				case DateParts.Second      : return date.Value.Second;  				case DateParts.Millisecond : return date.Value.Millisecond;  			}
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Double?) (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int16?)  (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int32?)  (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int64?)  (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (SByte?)  (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Single?) (value * 180 / Math.PI);
Magic Number,BLToolkit.Data.Linq,Expressions,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,DateAdd,The following statement contains a magic number: return days == null ? null : Sql.DateAdd(part' number' new DateTime(1900' 1' days.Value + 1));
Magic Number,BLToolkit.Data.Linq,Query<T>,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetNonQueryQuery2,The following statement contains a magic number: if (Queries.Count != 2)  				throw new InvalidOperationException();
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction)expr;    				switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction)expr;    				switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The following statement contains a magic number: switch (func.Name)  			{  				case "CASE"     : func = ConvertCase(func.SystemType' func.Parameters' 0); break;  				case "Coalesce" :    					if (func.Parameters.Length > 2)  					{  						var parms = new ISqlExpression[func.Parameters.Length - 1];    						Array.Copy(func.Parameters' 1' parms' 0' parms.Length);  						BuildFunction(sb' new SqlFunction(func.SystemType' func.Name' func.Parameters[0]'  						                  new SqlFunction(func.SystemType' func.Name' parms)));  						return;  					}    					var sc = new SqlQuery.SearchCondition();    					sc.Conditions.Add(new SqlQuery.Condition(false' new SqlQuery.Predicate.IsNull(func.Parameters[0]' false)));    					func = new SqlFunction(func.SystemType' "IIF"' sc' func.Parameters[1]' func.Parameters[0]);    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  				return new SqlFunction(systemType' name' cond' parameters[start + 1]' parameters[start + 2]);
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  				return new SqlFunction(systemType' name' cond' parameters[start + 1]' parameters[start + 2]);
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction(systemType' name'  				cond'  				parameters[start + 1]'  				ConvertCase(systemType' parameters' start + 2));
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: foreach (var cond in condition.Conditions)  			{  				if (isOr != null)  				{  					sb.Append(isOr.Value ? " OR" : " AND");    					if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition)  					{  						sb.Append(' ');  					}  					else  					{  						sb.AppendLine();  						AppendIndent(sb);  						len = sb.Length;  					}  				}    				if (cond.IsNot)  					sb.Append("NOT ");    				var precedence = GetPrecedence(cond.Predicate);    				BuildPredicate(sb' cond.IsNot ? Precedence.LogicalNegation : parentPrecedence' precedence' cond.Predicate);    				isOr = cond.IsOr;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: foreach (var cond in condition.Conditions)  			{  				if (isOr != null)  				{  					sb.Append(isOr.Value ? " OR" : " AND");    					if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition)  					{  						sb.Append(' ');  					}  					else  					{  						sb.AppendLine();  						AppendIndent(sb);  						len = sb.Length;  					}  				}    				if (cond.IsNot)  					sb.Append("NOT ");    				var precedence = GetPrecedence(cond.Predicate);    				BuildPredicate(sb' cond.IsNot ? Precedence.LogicalNegation : parentPrecedence' precedence' cond.Predicate);    				isOr = cond.IsOr;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0)  			{  				BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  			}  			else  			{  				ICollection values = p.Values;    				if (p.Values.Count == 1 && p.Values[0] is SqlParameter &&  					!(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values[0]).Value is string))  				{  					var pr = (SqlParameter)p.Values[0];    					if (pr.Value == null)  					{  						BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(false)));  						return;  					}    					if (pr.Value is IEnumerable)  					{  						var items = (IEnumerable)pr.Value;    						if (p.Expr1 is ISqlTableSource)  						{  							var firstValue = true;  							var table      = (ISqlTableSource)p.Expr1;  							var keys       = table.GetKeys(true);    							if (keys == null || keys.Count == 0)  								throw new SqlException("Cannot create IN expression.");    							if (keys.Count == 1)  							{  								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										BuildExpression(sb' GetPrecedence(p)' keys[0]);  										sb.Append(p.IsNot ? " NOT IN (" : " IN (");  									}    									var field = GetUnderlayingField(keys[0]);  									var value = field.MemberMapper.GetValue(item);    									if (value is ISqlExpression)  										BuildExpression(sb' (ISqlExpression)value);  									else  										BuildValue(sb' value);    									sb.Append("' ");  								}  							}  							else  							{  								var len = sb.Length;  								var rem = 1;    								foreach (var item in items)  								{  									if (firstValue)  									{  										firstValue = false;  										sb.Append('(');  									}    									foreach (var key in keys)  									{  										var field = GetUnderlayingField(key);  										var value = field.MemberMapper.GetValue(item);    										BuildExpression(sb' GetPrecedence(p)' key);    										if (value == null)  										{  											sb.Append(" IS NULL");  										}  										else  										{  											sb.Append(" = ");  											BuildValue(sb' value);  										}    										sb.Append(" AND ");  									}    									sb.Remove(sb.Length - 4' 4).Append("OR ");    									if (sb.Length - len >= 50)  									{  										sb.AppendLine();  										AppendIndent(sb);  										sb.Append(' ');  										len = sb.Length;  										rem = 5 + Indent;  									}  								}    								if (!firstValue)  									sb.Remove(sb.Length - rem' rem);  							}    							if (firstValue)  								BuildPredicate(sb' new SqlQuery.Predicate.Expr(new SqlValue(p.IsNot)));  							else  								sb.Remove(sb.Length - 2' 2).Append(')');  						}  						else  						{  							BuildInListValues(sb' p' items);  						}    						return;  					}  				}    				BuildInListValues(sb' p' values);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: foreach (var value in values)  			{  				if (count++ >= MaxInListValuesCount)  				{  					count = 1;  					longList = true;    					// start building next bucked  					firstValue = true;  					sb.Remove(sb.Length - 2' 2).Append(')');  					sb.Append(" OR ");  				}    				var val = value;    				if (val is IValueContainer)  					val = ((IValueContainer)value).Value;    				if (val == null)  				{  					hasNull = true;  					continue;  				}    				if (firstValue)  				{  					firstValue = false;  					BuildExpression(sb' GetPrecedence(predicate)' predicate.Expr1);  					sb.Append(predicate.IsNot ? " NOT IN (" : " IN (");  				}    				if (value is ISqlExpression)  					BuildExpression(sb' (ISqlExpression)value);  				else  					BuildValue(sb' value);    				sb.Append("' ");  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: foreach (var value in values)  			{  				if (count++ >= MaxInListValuesCount)  				{  					count = 1;  					longList = true;    					// start building next bucked  					firstValue = true;  					sb.Remove(sb.Length - 2' 2).Append(')');  					sb.Append(" OR ");  				}    				var val = value;    				if (val is IValueContainer)  					val = ((IValueContainer)value).Value;    				if (val == null)  				{  					hasNull = true;  					continue;  				}    				if (firstValue)  				{  					firstValue = false;  					BuildExpression(sb' GetPrecedence(predicate)' predicate.Expr1);  					sb.Append(predicate.IsNot ? " NOT IN (" : " IN (");  				}    				if (value is ISqlExpression)  					BuildExpression(sb' (ISqlExpression)value);  				else  					BuildValue(sb' value);    				sb.Append("' ");  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (firstValue)  			{  				BuildPredicate(sb'  					hasNull ?  						new SqlQuery.Predicate.IsNull(predicate.Expr1' predicate.IsNot) :  						new SqlQuery.Predicate.Expr(new SqlValue(predicate.IsNot)));  			}  			else  			{  				sb.Remove(sb.Length - 2' 2).Append(')');    				if (hasNull)  				{  					sb.Insert(len' "(");  					sb.Append(" OR ");  					BuildPredicate(sb' new SqlQuery.Predicate.IsNull(predicate.Expr1' predicate.IsNot));  					sb.Append(")");  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (firstValue)  			{  				BuildPredicate(sb'  					hasNull ?  						new SqlQuery.Predicate.IsNull(predicate.Expr1' predicate.IsNot) :  						new SqlQuery.Predicate.Expr(new SqlValue(predicate.IsNot)));  			}  			else  			{  				sb.Remove(sb.Length - 2' 2).Append(')');    				if (hasNull)  				{  					sb.Insert(len' "(");  					sb.Append(" OR ");  					BuildPredicate(sb' new SqlQuery.Predicate.IsNull(predicate.Expr1' predicate.IsNot));  					sb.Append(")");  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: if (func.Name == "CASE")  			{  				sb.Append(func.Name).AppendLine();    				Indent++;    				var i = 0;    				for (; i < func.Parameters.Length - 1; i += 2)  				{  					AppendIndent(sb).Append("WHEN ");    					var len = sb.Length;    					BuildExpression(sb' func.Parameters[i]);    					if (SqlExpression.NeedsEqual(func.Parameters[i]))  					{  						sb.Append(" = ");  						BuildValue(sb' true);  					}    					if (sb.Length - len > 20)  					{  						sb.AppendLine();  						AppendIndent(sb).Append("\tTHEN ");  					}  					else  						sb.Append(" THEN ");    					BuildExpression(sb' func.Parameters[i+1]);  					sb.AppendLine();  				}    				if (i < func.Parameters.Length)  				{  					AppendIndent(sb).Append("ELSE ");  					BuildExpression(sb' func.Parameters[i]);  					sb.AppendLine();  				}    				Indent--;    				AppendIndent(sb).Append("END");  			}  			else  				BuildFunction(sb' func.Name' func.Parameters);
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: if (func.Name == "CASE")  			{  				sb.Append(func.Name).AppendLine();    				Indent++;    				var i = 0;    				for (; i < func.Parameters.Length - 1; i += 2)  				{  					AppendIndent(sb).Append("WHEN ");    					var len = sb.Length;    					BuildExpression(sb' func.Parameters[i]);    					if (SqlExpression.NeedsEqual(func.Parameters[i]))  					{  						sb.Append(" = ");  						BuildValue(sb' true);  					}    					if (sb.Length - len > 20)  					{  						sb.AppendLine();  						AppendIndent(sb).Append("\tTHEN ");  					}  					else  						sb.Append(" THEN ");    					BuildExpression(sb' func.Parameters[i+1]);  					sb.AppendLine();  				}    				if (i < func.Parameters.Length)  				{  					AppendIndent(sb).Append("ELSE ");  					BuildExpression(sb' func.Parameters[i]);  					sb.AppendLine();  				}    				Indent--;    				AppendIndent(sb).Append("END");  			}  			else  				BuildFunction(sb' func.Name' func.Parameters);
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql,The following statement contains a magic number: if (NeedSkip)  			{  				var aliases  = GetTempAliases(2' "t");  				var rnaliase = GetTempAliases(1' "rn")[0];    				AppendIndent(sb).Append("SELECT *").AppendLine();  				AppendIndent(sb).Append("FROM").    AppendLine();  				AppendIndent(sb).Append("(").       AppendLine();  				Indent++;    				AppendIndent(sb).Append("SELECT").AppendLine();    				Indent++;  				AppendIndent(sb).AppendFormat("{0}.*'"' aliases[0]).AppendLine();  				AppendIndent(sb).Append("ROW_NUMBER() OVER");    				if (!SqlQuery.OrderBy.IsEmpty && !implementOrderBy)  					sb.Append("()");  				else  				{  					sb.AppendLine();  					AppendIndent(sb).Append("(").AppendLine();    					Indent++;    					if (SqlQuery.OrderBy.IsEmpty)  					{  						AppendIndent(sb).Append("ORDER BY").AppendLine();  						BuildAliases(sb' aliases[0]' SqlQuery.Select.Columns.Take(1).ToList()' null);  					}  					else  						BuildAlternativeOrderBy(sb' true);    					Indent--;  					AppendIndent(sb).Append(")");  				}    				sb.Append(" as ").Append(rnaliase).AppendLine();  				Indent--;    				AppendIndent(sb).Append("FROM").AppendLine();  				AppendIndent(sb).Append("(").AppendLine();    				Indent++;  				buildSql(sb);  				Indent--;    				AppendIndent(sb).AppendFormat(") {0}"' aliases[0]).AppendLine();    				Indent--;    				AppendIndent(sb).AppendFormat(") {0}"' aliases[1]).AppendLine();  				AppendIndent(sb).Append("WHERE").AppendLine();    				Indent++;    				if (NeedTake)  				{  					var expr1 = Add(SqlQuery.Select.SkipValue' 1);  					var expr2 = Add<int>(SqlQuery.Select.SkipValue' SqlQuery.Select.TakeValue);    					if (expr1 is SqlValue && expr2 is SqlValue && Equals(((SqlValue)expr1).Value' ((SqlValue)expr2).Value))  					{  						AppendIndent(sb).AppendFormat("{0}.{1} = "' aliases[1]' rnaliase);  						BuildExpression(sb' expr1);  					}  					else  					{  						AppendIndent(sb).AppendFormat("{0}.{1} BETWEEN "' aliases[1]' rnaliase);  						BuildExpression(sb' expr1);  						sb.Append(" AND ");  						BuildExpression(sb' expr2);  					}  				}  				else  				{  					AppendIndent(sb).AppendFormat("{0}.{1} > "' aliases[1]' rnaliase);  					BuildExpression(sb' SqlQuery.Select.SkipValue);  				}    				sb.AppendLine();  				Indent--;  			}  			else  				buildSql(sb);
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: var aliases = GetTempAliases(3' "t");
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: if (SqlQuery.OrderBy.IsEmpty)  			{  				Indent--;  				AppendIndent(sb).AppendFormat(") {0}"' aliases[2]).AppendLine();  				AppendIndent(sb).Append("ORDER BY").AppendLine();  				BuildAliases(sb' aliases[2]' SqlQuery.Select.Columns' null);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: if (SqlQuery.OrderBy.IsEmpty)  			{  				Indent--;  				AppendIndent(sb).AppendFormat(") {0}"' aliases[2]).AppendLine();  				AppendIndent(sb).Append("ORDER BY").AppendLine();  				BuildAliases(sb' aliases[2]' SqlQuery.Select.Columns' null);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The following statement contains a magic number: if ((i % 2 == 1 || i == count - 1) && expr.SystemType == typeof(bool) || expr.SystemType == typeof(bool?))  			{  				switch (expr.ElementType)  				{  					case QueryElementType.SearchCondition : return true;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType)  			{  				case QueryElementType.SqlTable :  					{  						var tbl = (SqlTable)table;    						var database     = tbl.Database     == null ? null : Convert(tbl.Database'     ConvertType.NameToDatabase).  ToString();  						var owner        = tbl.Owner        == null ? null : Convert(tbl.Owner'        ConvertType.NameToOwner).     ToString();  						var physicalName = tbl.PhysicalName == null ? null : Convert(tbl.PhysicalName' ConvertType.NameToQueryTable).ToString();    						var sb = new StringBuilder();    						if (tbl.SqlTableType == SqlTableType.Expression)  						{  							if (tbl.TableArguments == null)  								physicalName = tbl.PhysicalName;  							else  							{  								var values = new object[tbl.TableArguments.Length + 2];    								values[0] = physicalName;  								values[1] = Convert(alias' ConvertType.NameToQueryTableAlias);    								for (var i = 2; i < values.Length; i++)  								{  									var value = tbl.TableArguments[i - 2];    									sb.Length = 0;  									BuildExpression(sb' Precedence.Primary' value);  									values[i] = sb.ToString();  								}    								physicalName = string.Format(tbl.Name' values);    								sb.Length = 0;  							}  						}    						BuildTableName(sb' database' owner' physicalName);    						if (tbl.SqlTableType == SqlTableType.Function)  						{  							sb.Append('(');    							if (tbl.TableArguments != null && tbl.TableArguments.Length > 0)  							{  								var first = true;    								foreach (var arg in tbl.TableArguments)  								{  									if (!first)  										sb.Append("' ");    									BuildExpression(sb' arg' true' !first);    									first = false;  								}  							}    							sb.Append(')');  						}    						return sb.ToString();  					}    				case QueryElementType.TableSource :  					return GetTablePhysicalName(((SqlQuery.TableSource)table).Source' alias);    				default :  					throw new InvalidOperationException();  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType)  			{  				case QueryElementType.SqlTable :  					{  						var tbl = (SqlTable)table;    						var database     = tbl.Database     == null ? null : Convert(tbl.Database'     ConvertType.NameToDatabase).  ToString();  						var owner        = tbl.Owner        == null ? null : Convert(tbl.Owner'        ConvertType.NameToOwner).     ToString();  						var physicalName = tbl.PhysicalName == null ? null : Convert(tbl.PhysicalName' ConvertType.NameToQueryTable).ToString();    						var sb = new StringBuilder();    						if (tbl.SqlTableType == SqlTableType.Expression)  						{  							if (tbl.TableArguments == null)  								physicalName = tbl.PhysicalName;  							else  							{  								var values = new object[tbl.TableArguments.Length + 2];    								values[0] = physicalName;  								values[1] = Convert(alias' ConvertType.NameToQueryTableAlias);    								for (var i = 2; i < values.Length; i++)  								{  									var value = tbl.TableArguments[i - 2];    									sb.Length = 0;  									BuildExpression(sb' Precedence.Primary' value);  									values[i] = sb.ToString();  								}    								physicalName = string.Format(tbl.Name' values);    								sb.Length = 0;  							}  						}    						BuildTableName(sb' database' owner' physicalName);    						if (tbl.SqlTableType == SqlTableType.Function)  						{  							sb.Append('(');    							if (tbl.TableArguments != null && tbl.TableArguments.Length > 0)  							{  								var first = true;    								foreach (var arg in tbl.TableArguments)  								{  									if (!first)  										sb.Append("' ");    									BuildExpression(sb' arg' true' !first);    									first = false;  								}  							}    							sb.Append(')');  						}    						return sb.ToString();  					}    				case QueryElementType.TableSource :  					return GetTablePhysicalName(((SqlQuery.TableSource)table).Source' alias);    				default :  					throw new InvalidOperationException();  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType)  			{  				case QueryElementType.SqlTable :  					{  						var tbl = (SqlTable)table;    						var database     = tbl.Database     == null ? null : Convert(tbl.Database'     ConvertType.NameToDatabase).  ToString();  						var owner        = tbl.Owner        == null ? null : Convert(tbl.Owner'        ConvertType.NameToOwner).     ToString();  						var physicalName = tbl.PhysicalName == null ? null : Convert(tbl.PhysicalName' ConvertType.NameToQueryTable).ToString();    						var sb = new StringBuilder();    						if (tbl.SqlTableType == SqlTableType.Expression)  						{  							if (tbl.TableArguments == null)  								physicalName = tbl.PhysicalName;  							else  							{  								var values = new object[tbl.TableArguments.Length + 2];    								values[0] = physicalName;  								values[1] = Convert(alias' ConvertType.NameToQueryTableAlias);    								for (var i = 2; i < values.Length; i++)  								{  									var value = tbl.TableArguments[i - 2];    									sb.Length = 0;  									BuildExpression(sb' Precedence.Primary' value);  									values[i] = sb.ToString();  								}    								physicalName = string.Format(tbl.Name' values);    								sb.Length = 0;  							}  						}    						BuildTableName(sb' database' owner' physicalName);    						if (tbl.SqlTableType == SqlTableType.Function)  						{  							sb.Append('(');    							if (tbl.TableArguments != null && tbl.TableArguments.Length > 0)  							{  								var first = true;    								foreach (var arg in tbl.TableArguments)  								{  									if (!first)  										sb.Append("' ");    									BuildExpression(sb' arg' true' !first);    									first = false;  								}  							}    							sb.Append(')');  						}    						return sb.ToString();  					}    				case QueryElementType.TableSource :  					return GetTablePhysicalName(((SqlQuery.TableSource)table).Source' alias);    				default :  					throw new InvalidOperationException();  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (to.Type == typeof(object))  				return func.Parameters[2];
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (to.Precision > 0)  			{  				var maxPrecision = GetMaxPrecision(from);  				var maxScale     = GetMaxScale    (from);  				var newPrecision = maxPrecision >= 0 ? Math.Min(to.Precision' maxPrecision) : to.Precision;  				var newScale     = maxScale     >= 0 ? Math.Min(to.Scale'     maxScale)     : to.Scale;    				if (to.Precision != newPrecision || to.Scale != newScale)  					to = new SqlDataType(to.SqlDbType' to.Type' newPrecision' newScale);  			}  			else if (to.Length > 0)  			{  				var maxLength = to.Type == typeof(string) ? GetMaxDisplaySize(from) : GetMaxLength(from);  				var newLength = maxLength >= 0 ? Math.Min(to.Length' maxLength) : to.Length;    				if (to.Length != newLength)  					to = new SqlDataType(to.SqlDbType' to.Type' newLength);  			}  			else if (from.Type == typeof(short) && to.Type == typeof(int))  				return func.Parameters[2];
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: return ConvertExpression(new SqlFunction(func.SystemType' "Convert"' to' func.Parameters[2]));
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:    					#region SqlBinaryExpression    					{  						var be = (SqlBinaryExpression)expression;    						switch (be.Operation)  						{  							case "+":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									if (v1.Value is int    && (int)   v1.Value == 0 ||  										v1.Value is string && (string)v1.Value == "") return be.Expr2;  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression) be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  									else if (v2.Value is string)  									{  										if ((string)v2.Value == "") return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var value = ((SqlValue)be1.Expr2).Value;    												if (value is string)  													return new SqlBinaryExpression(  														be1.SystemType'  														be1.Expr1'  														be1.Operation'  														new SqlValue(string.Concat(value' v2.Value)));  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int    && v2.Value is int)    return new SqlValue((int)v1.Value + (int)v2.Value);  									if (v1.Value is string || v2.Value is string) return new SqlValue(v1.Value.ToString() + v2.Value);  								}    								if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string))  								{  									var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr2.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										be.Expr1'  										be.Operation'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr2))'  										be.Precedence);  								}    								if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string))  								{  									var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize(SqlDataType.GetDataType(be.Expr1.SystemType).SqlDbType);    									if (len <= 0)  										len = 100;    									return new SqlBinaryExpression(  										be.SystemType'  										ConvertExpression(new SqlFunction(typeof(string)' "Convert"' new SqlDataType(SqlDbType.VarChar' len)' be.Expr1))'  										be.Operation'  										be.Expr2'  										be.Precedence);  								}    								break;    							case "-":  								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue) be.Expr2;    									if (v2.Value is int)  									{  										if ((int)v2.Value == 0) return be.Expr1;    										if (be.Expr1 is SqlBinaryExpression)  										{  											var be1 = (SqlBinaryExpression)be.Expr1;    											if (be1.Expr2 is SqlValue)  											{  												var be1v2 = (SqlValue)be1.Expr2;    												if (be1v2.Value is int)  												{  													switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}  												}  											}  										}  									}  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;  									if (v1.Value is int && v2.Value is int) return new SqlValue((int)v1.Value - (int)v2.Value);  								}    								break;    							case "*":  								if (be.Expr1 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;    									if (v1.Value is int)  									{  										var v1v = (int)v1.Value;    										switch (v1v)  										{  											case  0 : return new SqlValue(0);  											case  1 : return be.Expr2;  											default :  												{  													var be2 = be.Expr2 as SqlBinaryExpression;    													if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue)  													{  														var be2v1 = be2.Expr1 as SqlValue;    														if (be2v1.Value is int)  															return ConvertExpression(  																new SqlBinaryExpression(be2.SystemType' new SqlValue(v1v * (int)be2v1.Value)' "*"' be2.Expr2));  													}    													break;  												}    										}  									}  								}    								if (be.Expr2 is SqlValue)  								{  									var v2 = (SqlValue)be.Expr2;  									if (v2.Value is int && (int)v2.Value == 1) return be.Expr1;  									if (v2.Value is int && (int)v2.Value == 0) return new SqlValue(0);  								}    								if (be.Expr1 is SqlValue && be.Expr2 is SqlValue)  								{  									var v1 = (SqlValue)be.Expr1;  									var v2 = (SqlValue)be.Expr2;    									if (v1.Value is int)  									{  										if (v2.Value is int)    return new SqlValue((int)   v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((int)   v1.Value * (double)v2.Value);  									}  									else if (v1.Value is double)  									{  										if (v2.Value is int)    return new SqlValue((double)v1.Value * (int)   v2.Value);  										if (v2.Value is double) return new SqlValue((double)v1.Value * (double)v2.Value);  									}  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SqlFunction:    					#region SqlFunction    					{  						var func = (SqlFunction)expression;    						switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}  					}    					#endregion    					break;    				case QueryElementType.SearchCondition :  					SqlQuery.OptimizeSearchCondition((SqlQuery.SearchCondition)expression);  					break;    				case QueryElementType.SqlExpression   :  					{  						var se = (SqlExpression)expression;    						if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters[0] != null)  							return se.Parameters[0];  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE")  			{  				if (value.Value is int && func.Parameters.Length == 5)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var c2 = func.Parameters[2] as SqlQuery.SearchCondition;  					var v2 = func.Parameters[3] as SqlValue;  					var v3 = func.Parameters[4] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int &&  					    c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int)  					{  						var ee1 = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;  						var ee2 = c2.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    						if (ee1 != null && ee2 != null && ee1.Expr1.Equals(ee2.Expr1) && ee1.Expr2.Equals(ee2.Expr2))  						{  							int e = 0' g = 0' l = 0;    							if (ee1.Operator == SqlQuery.Predicate.Operator.Equal   || ee2.Operator == SqlQuery.Predicate.Operator.Equal)   e = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater) g = 1;  							if (ee1.Operator == SqlQuery.Predicate.Operator.Less    || ee2.Operator == SqlQuery.Predicate.Operator.Less)    l = 1;    							if (e + g + l == 2)  							{  								var n  = (int)value.Value;  								var i1 = (int)v1.Value;  								var i2 = (int)v2.Value;  								var i3 = (int)v3.Value;    								var n1 = Compare(valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  								var n2 = Compare(valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  								var n3 = Compare(valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;    								if (n1 + n2 + n3 == 1)  								{  									if (n1 == 1) return ee1;  									if (n2 == 1) return ee2;    									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										e == 0 ? SqlQuery.Predicate.Operator.Equal :  										g == 0 ? SqlQuery.Predicate.Operator.Greater :  												 SqlQuery.Predicate.Operator.Less'  										ee1.Expr2));  								}    								//	CASE  								//		WHEN [p].[FirstName] > 'John'  								//			THEN 1  								//		WHEN [p].[FirstName] = 'John'  								//			THEN 0  								//		ELSE -1  								//	END <= 0  								if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 &&  									ee2.Operator == SqlQuery.Predicate.Operator.Equal   && i2 == 0 &&  									i3 == -1 && n == 0)  								{  									return ConvertPredicate(new SqlQuery.Predicate.ExprExpr(  										ee1.Expr1'  										valueFirst ? InvertOperator(expr.Operator' true) : expr.Operator'  										ee1.Expr2));  								}  							}  						}  					}  				}  				else if (value.Value is bool && func.Parameters.Length == 3)  				{  					var c1 = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool)  					{  						var bv  = (bool)value.Value;  						var bv1 = (bool)v1.Value;  						var bv2 = (bool)v2.Value;    						if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual)  						{  							return c1;  						}    						if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual ||  						    bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal)  						{  							var ee = c1.Conditions[0].Predicate as SqlQuery.Predicate.ExprExpr;    							if (ee != null)  							{  								var op = InvertOperator(ee.Operator' false);  								return new SqlQuery.Predicate.ExprExpr(ee.Expr1' op' ee.Expr2);  							}    							var sc = new SqlQuery.SearchCondition();    							sc.Conditions.Add(new SqlQuery.Condition(true' c1));    							return sc;  						}  					}  				}  				else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3)  				{  					var sc = func.Parameters[0] as SqlQuery.SearchCondition;  					var v1 = func.Parameters[1] as SqlValue;  					var v2 = func.Parameters[2] as SqlValue;    					if (sc != null && v1 != null && v2 != null)  					{  						if (Equals(value.Value' v1.Value))  							return sc;    						if (Equals(value.Value' v2.Value) && !sc.CanBeNull())  							return ConvertPredicate(new SqlQuery.Predicate.NotExpr(sc' true' Precedence.LogicalNegation));  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildSql,The following statement contains a magic number: if (SqlQuery.From.Tables.Count == 0 && SqlQuery.Select.Columns.Count == 1)  			{  				if (SqlQuery.Select.Columns[0].Expression is SqlFunction)  				{  					var func = (SqlFunction)SqlQuery.Select.Columns[0].Expression;    					if (func.Name == "Iif" && func.Parameters.Length == 3 && func.Parameters[0] is SqlQuery.SearchCondition)  					{  						var sc = (SqlQuery.SearchCondition)func.Parameters[0];    						if (sc.Conditions.Count == 1 && sc.Conditions[0].Predicate is SqlQuery.Predicate.FuncLike)  						{  							var p = (SqlQuery.Predicate.FuncLike)sc.Conditions[0].Predicate;    							if (p.Function.Name == "EXISTS")  							{  								BuildAnyAsCount(sb);  								return;  							}  						}  					}  				}  				else if (SqlQuery.Select.Columns[0].Expression is SqlQuery.SearchCondition)  				{  					var sc = (SqlQuery.SearchCondition)SqlQuery.Select.Columns[0].Expression;    					if (sc.Conditions.Count == 1 && sc.Conditions[0].Predicate is SqlQuery.Predicate.FuncLike)  					{  						var p = (SqlQuery.Predicate.FuncLike)sc.Conditions[0].Predicate;    						if (p.Function.Name == "EXISTS")  						{  							BuildAnyAsCount(sb);  							return;  						}  					}  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation[0])  				{  					case '%': return new SqlBinaryExpression(be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  					case '&':  					case '|':  					case '^': throw new SqlException("Operator '{0}' is not supported by the {1}."' be.Operation' GetType().Name);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce":    						if (func.Parameters.Length > 2)  						{  							var parms = new ISqlExpression[func.Parameters.Length - 1];    							Array.Copy(func.Parameters' 1' parms' 0' parms.Length);  							return new SqlFunction(func.SystemType' func.Name' func.Parameters[0]' new SqlFunction(func.SystemType' func.Name' parms));  						}    						var sc = new SqlQuery.SearchCondition();    						sc.Conditions.Add(new SqlQuery.Condition(false' new SqlQuery.Predicate.IsNull(func.Parameters[0]' false)));    						return new SqlFunction(func.SystemType' "Iif"' sc' func.Parameters[1]' func.Parameters[0]);    					case "CASE"      : return ConvertCase(func.SystemType' func.Parameters' 0);  					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' new SqlValue(1)'    func.Parameters[1]' func.Parameters[0]' new SqlValue(1)):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[2]' func.Parameters[1]' func.Parameters[0]' new SqlValue(1));    					case "Convert"   :   						{  							switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  							{  								case TypeCode.String   : return new SqlFunction(func.SystemType' "CStr"'  func.Parameters[1]);  								case TypeCode.DateTime :  									if (IsDateDataType(func.Parameters[0]' "Date"))  										return new SqlFunction(func.SystemType' "DateValue"' func.Parameters[1]);    									if (IsTimeDataType(func.Parameters[0]))  										return new SqlFunction(func.SystemType' "TimeValue"' func.Parameters[1]);    									return new SqlFunction(func.SystemType' "CDate"' func.Parameters[1]);    								default:  									if (func.SystemType == typeof(DateTime))  										goto case TypeCode.DateTime;  									break;  							}    							return func.Parameters[1];  						}    						/*  					case "Convert"   :  						{  							string name = null;    							switch (((SqlDataType)func.Parameters[0]).DbType)  							{  								case SqlDbType.BigInt           : name = "CLng"; break;  								case SqlDbType.TinyInt          : name = "CByte"; break;  								case SqlDbType.Int              :  								case SqlDbType.SmallInt         : name = "CInt"; break;  								case SqlDbType.Bit              : name = "CBool"; break;  								case SqlDbType.Char             :  								case SqlDbType.Text             :  								case SqlDbType.VarChar          :  								case SqlDbType.NChar            :  								case SqlDbType.NText            :  								case SqlDbType.NVarChar         : name = "CStr"; break;  								case SqlDbType.DateTime         :  								case SqlDbType.Date             :  								case SqlDbType.Time             :  								case SqlDbType.DateTime2        :  								case SqlDbType.SmallDateTime    :  								case SqlDbType.DateTimeOffset   : name = "CDate"; break;  								case SqlDbType.Decimal          : name = "CDec"; break;  								case SqlDbType.Float            : name = "CDbl"; break;  								case SqlDbType.Money            :  								case SqlDbType.SmallMoney       : name = "CCur"; break;  								case SqlDbType.Real             : name = "CSng"; break;  								case SqlDbType.Image            :  								case SqlDbType.Binary           :  								case SqlDbType.UniqueIdentifier :  								case SqlDbType.Timestamp        :  								case SqlDbType.VarBinary        :  								case SqlDbType.Variant          :  								case SqlDbType.Xml              :  								case SqlDbType.Udt              :  								case SqlDbType.Structured       : name = "CVar"; break;  							}    							return new SqlFunction(name' func.Parameters[1]);  						}  						*/  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation[0])  				{  					case '%': return new SqlBinaryExpression(be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  					case '&':  					case '|':  					case '^': throw new SqlException("Operator '{0}' is not supported by the {1}."' be.Operation' GetType().Name);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce":    						if (func.Parameters.Length > 2)  						{  							var parms = new ISqlExpression[func.Parameters.Length - 1];    							Array.Copy(func.Parameters' 1' parms' 0' parms.Length);  							return new SqlFunction(func.SystemType' func.Name' func.Parameters[0]' new SqlFunction(func.SystemType' func.Name' parms));  						}    						var sc = new SqlQuery.SearchCondition();    						sc.Conditions.Add(new SqlQuery.Condition(false' new SqlQuery.Predicate.IsNull(func.Parameters[0]' false)));    						return new SqlFunction(func.SystemType' "Iif"' sc' func.Parameters[1]' func.Parameters[0]);    					case "CASE"      : return ConvertCase(func.SystemType' func.Parameters' 0);  					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' new SqlValue(1)'    func.Parameters[1]' func.Parameters[0]' new SqlValue(1)):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[2]' func.Parameters[1]' func.Parameters[0]' new SqlValue(1));    					case "Convert"   :   						{  							switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  							{  								case TypeCode.String   : return new SqlFunction(func.SystemType' "CStr"'  func.Parameters[1]);  								case TypeCode.DateTime :  									if (IsDateDataType(func.Parameters[0]' "Date"))  										return new SqlFunction(func.SystemType' "DateValue"' func.Parameters[1]);    									if (IsTimeDataType(func.Parameters[0]))  										return new SqlFunction(func.SystemType' "TimeValue"' func.Parameters[1]);    									return new SqlFunction(func.SystemType' "CDate"' func.Parameters[1]);    								default:  									if (func.SystemType == typeof(DateTime))  										goto case TypeCode.DateTime;  									break;  							}    							return func.Parameters[1];  						}    						/*  					case "Convert"   :  						{  							string name = null;    							switch (((SqlDataType)func.Parameters[0]).DbType)  							{  								case SqlDbType.BigInt           : name = "CLng"; break;  								case SqlDbType.TinyInt          : name = "CByte"; break;  								case SqlDbType.Int              :  								case SqlDbType.SmallInt         : name = "CInt"; break;  								case SqlDbType.Bit              : name = "CBool"; break;  								case SqlDbType.Char             :  								case SqlDbType.Text             :  								case SqlDbType.VarChar          :  								case SqlDbType.NChar            :  								case SqlDbType.NText            :  								case SqlDbType.NVarChar         : name = "CStr"; break;  								case SqlDbType.DateTime         :  								case SqlDbType.Date             :  								case SqlDbType.Time             :  								case SqlDbType.DateTime2        :  								case SqlDbType.SmallDateTime    :  								case SqlDbType.DateTimeOffset   : name = "CDate"; break;  								case SqlDbType.Decimal          : name = "CDec"; break;  								case SqlDbType.Float            : name = "CDbl"; break;  								case SqlDbType.Money            :  								case SqlDbType.SmallMoney       : name = "CCur"; break;  								case SqlDbType.Real             : name = "CSng"; break;  								case SqlDbType.Image            :  								case SqlDbType.Binary           :  								case SqlDbType.UniqueIdentifier :  								case SqlDbType.Timestamp        :  								case SqlDbType.VarBinary        :  								case SqlDbType.Variant          :  								case SqlDbType.Xml              :  								case SqlDbType.Udt              :  								case SqlDbType.Structured       : name = "CVar"; break;  							}    							return new SqlFunction(name' func.Parameters[1]);  						}  						*/  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation[0])  				{  					case '%': return new SqlBinaryExpression(be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  					case '&':  					case '|':  					case '^': throw new SqlException("Operator '{0}' is not supported by the {1}."' be.Operation' GetType().Name);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce":    						if (func.Parameters.Length > 2)  						{  							var parms = new ISqlExpression[func.Parameters.Length - 1];    							Array.Copy(func.Parameters' 1' parms' 0' parms.Length);  							return new SqlFunction(func.SystemType' func.Name' func.Parameters[0]' new SqlFunction(func.SystemType' func.Name' parms));  						}    						var sc = new SqlQuery.SearchCondition();    						sc.Conditions.Add(new SqlQuery.Condition(false' new SqlQuery.Predicate.IsNull(func.Parameters[0]' false)));    						return new SqlFunction(func.SystemType' "Iif"' sc' func.Parameters[1]' func.Parameters[0]);    					case "CASE"      : return ConvertCase(func.SystemType' func.Parameters' 0);  					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' new SqlValue(1)'    func.Parameters[1]' func.Parameters[0]' new SqlValue(1)):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[2]' func.Parameters[1]' func.Parameters[0]' new SqlValue(1));    					case "Convert"   :   						{  							switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  							{  								case TypeCode.String   : return new SqlFunction(func.SystemType' "CStr"'  func.Parameters[1]);  								case TypeCode.DateTime :  									if (IsDateDataType(func.Parameters[0]' "Date"))  										return new SqlFunction(func.SystemType' "DateValue"' func.Parameters[1]);    									if (IsTimeDataType(func.Parameters[0]))  										return new SqlFunction(func.SystemType' "TimeValue"' func.Parameters[1]);    									return new SqlFunction(func.SystemType' "CDate"' func.Parameters[1]);    								default:  									if (func.SystemType == typeof(DateTime))  										goto case TypeCode.DateTime;  									break;  							}    							return func.Parameters[1];  						}    						/*  					case "Convert"   :  						{  							string name = null;    							switch (((SqlDataType)func.Parameters[0]).DbType)  							{  								case SqlDbType.BigInt           : name = "CLng"; break;  								case SqlDbType.TinyInt          : name = "CByte"; break;  								case SqlDbType.Int              :  								case SqlDbType.SmallInt         : name = "CInt"; break;  								case SqlDbType.Bit              : name = "CBool"; break;  								case SqlDbType.Char             :  								case SqlDbType.Text             :  								case SqlDbType.VarChar          :  								case SqlDbType.NChar            :  								case SqlDbType.NText            :  								case SqlDbType.NVarChar         : name = "CStr"; break;  								case SqlDbType.DateTime         :  								case SqlDbType.Date             :  								case SqlDbType.Time             :  								case SqlDbType.DateTime2        :  								case SqlDbType.SmallDateTime    :  								case SqlDbType.DateTimeOffset   : name = "CDate"; break;  								case SqlDbType.Decimal          : name = "CDec"; break;  								case SqlDbType.Float            : name = "CDbl"; break;  								case SqlDbType.Money            :  								case SqlDbType.SmallMoney       : name = "CCur"; break;  								case SqlDbType.Real             : name = "CSng"; break;  								case SqlDbType.Image            :  								case SqlDbType.Binary           :  								case SqlDbType.UniqueIdentifier :  								case SqlDbType.Timestamp        :  								case SqlDbType.VarBinary        :  								case SqlDbType.Variant          :  								case SqlDbType.Xml              :  								case SqlDbType.Udt              :  								case SqlDbType.Structured       : name = "CVar"; break;  							}    							return new SqlFunction(name' func.Parameters[1]);  						}  						*/  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len < 3)  				throw new SqlException("CASE statement is not supported by the {0}."' GetType().Name);
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  				return new SqlFunction(systemType' "Iif"' parameters[start]' parameters[start + 1]' parameters[start + 2]);
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  				return new SqlFunction(systemType' "Iif"' parameters[start]' parameters[start + 1]' parameters[start + 2]);
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction(systemType' "Iif"' parameters[start]' parameters[start + 1]' ConvertCase(systemType' parameters' start + 2));
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildUpdateClause,The following statement contains a magic number: sb.Remove(0' 4).Insert(0' "UPDATE");
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction)expr;    				switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction)expr;    				switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,BuildString,The following statement contains a magic number: foreach (var ch in value)  			{  				if (ch > 127)  				{  					sb.Append("N");  					break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,BuildChar,The following statement contains a magic number: if (value > 127)  				sb.Append("N");
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					{  						var name = "@" + value.ToString().Replace(" "' string.Empty);    						if (name.Length > 27)  							name = name.Substring(0' 27);    						return name;  					}    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#'))  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					{  						var name = "@" + value.ToString().Replace(" "' string.Empty);    						if (name.Length > 27)  							name = name.Substring(0' 27);    						return name;  					}    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#'))  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					{  						var name = "@" + value.ToString().Replace(" "' string.Empty);    						if (name.Length > 27)  							name = name.Substring(0' 27);    						return name;  					}    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#'))  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					{  						var name = "@" + value.ToString().Replace(" "' string.Empty);    						if (name.Length > 27)  							name = name.Substring(0' 27);    						return name;  					}    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#'))  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildString,The following statement contains a magic number: foreach (var ch in value)  			{  				if (ch > 127)  				{  					sb.Append("N");  					break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildChar,The following statement contains a magic number: if (value > 127)  				sb.Append("N");
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildUpdateClause,The following statement contains a magic number: sb.Remove(0' 4).Insert(0' "UPDATE");
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: var c = new char[barray.Length * 2];
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i)  			{  				var b = ((byte)(barray[i] >> 4));    				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(barray[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i)  			{  				var b = ((byte)(barray[i] >> 4));    				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(barray[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i)  			{  				var b = ((byte)(barray[i] >> 4));    				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(barray[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i)  			{  				var b = ((byte)(barray[i] >> 4));    				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(barray[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i)  			{  				var b = ((byte)(barray[i] >> 4));    				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(barray[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  					case "^": // (a + b) - (a & b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlBinaryExpression(be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Space"   : return new SqlFunction(func.SystemType' "PadR"' new SqlValue(" ")' func.Parameters[0]);  					case "Convert" :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Date"))  									return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  								return new SqlFunction(func.SystemType' "DateTime"' func.Parameters[1]);  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]);  						}  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Cast(StrFTime(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));    				if (e.Expr.StartsWith("Cast(StrFTime('%w'"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));    				if (e.Expr.StartsWith("Cast(StrFTime('%f'"))  					return new SqlExpression(e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);    				if (e.Expr.StartsWith("DateTime"))  				{  					if (e.Expr.EndsWith("Quarter')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul(e.Parameters[0]' 3)' e.Parameters[1]);    					if (e.Expr.EndsWith("Week')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Day')"'   Precedence.Primary' Mul(e.Parameters[0]' 7)' e.Parameters[1]);  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  					case "^": // (a + b) - (a & b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlBinaryExpression(be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Space"   : return new SqlFunction(func.SystemType' "PadR"' new SqlValue(" ")' func.Parameters[0]);  					case "Convert" :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Date"))  									return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  								return new SqlFunction(func.SystemType' "DateTime"' func.Parameters[1]);  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]);  						}  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Cast(StrFTime(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));    				if (e.Expr.StartsWith("Cast(StrFTime('%w'"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));    				if (e.Expr.StartsWith("Cast(StrFTime('%f'"))  					return new SqlExpression(e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);    				if (e.Expr.StartsWith("DateTime"))  				{  					if (e.Expr.EndsWith("Quarter')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul(e.Parameters[0]' 3)' e.Parameters[1]);    					if (e.Expr.EndsWith("Week')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Day')"'   Precedence.Primary' Mul(e.Parameters[0]' 7)' e.Parameters[1]);  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  					case "^": // (a + b) - (a & b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlBinaryExpression(be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Space"   : return new SqlFunction(func.SystemType' "PadR"' new SqlValue(" ")' func.Parameters[0]);  					case "Convert" :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Date"))  									return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  								return new SqlFunction(func.SystemType' "DateTime"' func.Parameters[1]);  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]);  						}  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Cast(StrFTime(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));    				if (e.Expr.StartsWith("Cast(StrFTime('%w'"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));    				if (e.Expr.StartsWith("Cast(StrFTime('%f'"))  					return new SqlExpression(e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);    				if (e.Expr.StartsWith("DateTime"))  				{  					if (e.Expr.EndsWith("Quarter')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul(e.Parameters[0]' 3)' e.Parameters[1]);    					if (e.Expr.EndsWith("Week')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Day')"'   Precedence.Primary' Mul(e.Parameters[0]' 7)' e.Parameters[1]);  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  					case "^": // (a + b) - (a & b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlBinaryExpression(be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Space"   : return new SqlFunction(func.SystemType' "PadR"' new SqlValue(" ")' func.Parameters[0]);  					case "Convert" :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Date"))  									return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  								return new SqlFunction(func.SystemType' "DateTime"' func.Parameters[1]);  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]);  						}  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Cast(StrFTime(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));    				if (e.Expr.StartsWith("Cast(StrFTime('%w'"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));    				if (e.Expr.StartsWith("Cast(StrFTime('%f'"))  					return new SqlExpression(e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);    				if (e.Expr.StartsWith("DateTime"))  				{  					if (e.Expr.EndsWith("Quarter')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul(e.Parameters[0]' 3)' e.Parameters[1]);    					if (e.Expr.EndsWith("Week')"))  						return new SqlExpression(e.SystemType' "DateTime({1}' '{0} Day')"'   Precedence.Primary' Mul(e.Parameters[0]' 7)' e.Parameters[1]);  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as blob)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				SqlBinaryExpression be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				SqlFunction func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}  			}  			else if (expr is SqlExpression)  			{  				SqlExpression e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(Quarter"))  					return Inc(Div(Dec(new SqlExpression(e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));    				if (e.Expr.StartsWith("Extract(YearDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(YearDay"' "Extract(yearDay")' e.Parameters));    				if (e.Expr.StartsWith("Extract(WeekDay"))  					return Inc(new SqlExpression(e.SystemType' e.Expr.Replace("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: switch (type.SqlDbType)  			{  				case SqlDbType.Decimal       :  					base.BuildDataType(sb' type.Precision > 18 ? new SqlDataType(type.SqlDbType' type.Type' 18' type.Scale) : type);  					break;  				case SqlDbType.TinyInt       : sb.Append("SmallInt");        break;  				case SqlDbType.Money         : sb.Append("Decimal(18'4)");   break;  				case SqlDbType.SmallMoney    : sb.Append("Decimal(10'4)");   break;  #if !MONO  				case SqlDbType.DateTime2     :  #endif  				case SqlDbType.SmallDateTime :  				case SqlDbType.DateTime      : sb.Append("TimeStamp");       break;  				case SqlDbType.NVarChar      :  					sb.Append("VarChar");  					if (type.Length > 0)  						sb.Append('(').Append(type.Length).Append(')');  					break;  				default                      : base.BuildDataType(sb' type); break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: switch (type.SqlDbType)  			{  				case SqlDbType.Decimal       :  					base.BuildDataType(sb' type.Precision > 18 ? new SqlDataType(type.SqlDbType' type.Type' 18' type.Scale) : type);  					break;  				case SqlDbType.TinyInt       : sb.Append("SmallInt");        break;  				case SqlDbType.Money         : sb.Append("Decimal(18'4)");   break;  				case SqlDbType.SmallMoney    : sb.Append("Decimal(10'4)");   break;  #if !MONO  				case SqlDbType.DateTime2     :  #endif  				case SqlDbType.SmallDateTime :  				case SqlDbType.DateTime      : sb.Append("TimeStamp");       break;  				case SqlDbType.NVarChar      :  					sb.Append("VarChar");  					if (type.Length > 0)  						sb.Append('(').Append(type.Length).Append(')');  					break;  				default                      : base.BuildDataType(sb' type); break;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "^": return new SqlBinaryExpression(be.SystemType' be.Expr1' "#"' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"   :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]' func.Parameters[1]):  							Add<int>(  								new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]'  										Sub<int>(ConvertExpression(new SqlFunction(typeof(int)' "Length"' func.Parameters[1]))' func.Parameters[2]))))'  								Sub(func.Parameters[2]' 1));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(DOW"))  					return Inc(new SqlExpression(expr.SystemType' e.Expr.Replace("Extract(DOW"' "Extract(Dow")' e.Parameters));    				if (e.Expr.StartsWith("Extract(Millisecond"))  					return new SqlExpression(expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "^": return new SqlBinaryExpression(be.SystemType' be.Expr1' "#"' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"   :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]' func.Parameters[1]):  							Add<int>(  								new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]'  										Sub<int>(ConvertExpression(new SqlFunction(typeof(int)' "Length"' func.Parameters[1]))' func.Parameters[2]))))'  								Sub(func.Parameters[2]' 1));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(DOW"))  					return Inc(new SqlExpression(expr.SystemType' e.Expr.Replace("Extract(DOW"' "Extract(Dow")' e.Parameters));    				if (e.Expr.StartsWith("Extract(Millisecond"))  					return new SqlExpression(expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "^": return new SqlBinaryExpression(be.SystemType' be.Expr1' "#"' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"   :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]' func.Parameters[1]):  							Add<int>(  								new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]'  										Sub<int>(ConvertExpression(new SqlFunction(typeof(int)' "Length"' func.Parameters[1]))' func.Parameters[2]))))'  								Sub(func.Parameters[2]' 1));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(DOW"))  					return Inc(new SqlExpression(expr.SystemType' e.Expr.Replace("Extract(DOW"' "Extract(Dow")' e.Parameters));    				if (e.Expr.StartsWith("Extract(Millisecond"))  					return new SqlExpression(expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "^": return new SqlBinaryExpression(be.SystemType' be.Expr1' "#"' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"   :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]' func.Parameters[1]):  							Add<int>(  								new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]'  										Sub<int>(ConvertExpression(new SqlFunction(typeof(int)' "Length"' func.Parameters[1]))' func.Parameters[2]))))'  								Sub(func.Parameters[2]' 1));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("Extract(DOW"))  					return Inc(new SqlExpression(expr.SystemType' e.Expr.Replace("Extract(DOW"' "Extract(Dow")' e.Parameters));    				if (e.Expr.StartsWith("Extract(Millisecond"))  					return new SqlExpression(expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildSql,The following statement contains a magic number: if (buildRowNum)  			{  				aliases = GetTempAliases(2' "t");    				if (_rowNumberAlias == null)  					_rowNumberAlias = GetTempAliases(1' "rn")[0];    				AppendIndent(sb).AppendFormat("SELECT {0}.*"' aliases[1]).AppendLine();  				AppendIndent(sb).Append("FROM").    AppendLine();  				AppendIndent(sb).Append("(").       AppendLine();  				Indent++;    				AppendIndent(sb).AppendFormat("SELECT {0}.*' ROWNUM as {1}"' aliases[0]' _rowNumberAlias).AppendLine();  				AppendIndent(sb).Append("FROM").    AppendLine();  				AppendIndent(sb).Append("(").       AppendLine();  				Indent++;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}  			}  			else if (expr is SqlExpression)  			{  				var e = (SqlExpression)expr;    				if (e.Expr.StartsWith("To_Number(To_Char(") && e.Expr.EndsWith("' 'FF'))"))  					return Div(new SqlExpression(e.SystemType' e.Expr.Replace("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Finalize,The following statement contains a magic number: CheckAliases(sqlQuery' 30);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast('")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as raw(16))");  			}  			else if (value is DateTime)  			{  				sb.AppendFormat("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  					string name = value.ToString().Replace(" "' string.Empty);    					if (name.Length <= 28)  						return ":" + name;    					int hashCode = name.GetHashCode();  					return string.Format(":P{0}{1}_"' hashCode < 0 ? "m" : ""' Math.Abs(hashCode));    			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,CommandCount,The following statement contains a magic number: if (sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity)  			{  				_identityField = sqlQuery.Insert.Into.GetIdentityField();    				if (_identityField == null)  					return 2;  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildSql,The following statement contains a magic number: if (_identityField != null)  			{  				indent += 2;    				AppendIndent(sb).AppendLine("SELECT");  				AppendIndent(sb).Append("\t");  				BuildExpression(sb' _identityField' false' true);  				sb.AppendLine();  				AppendIndent(sb).AppendLine("FROM");  				AppendIndent(sb).AppendLine("\tNEW TABLE");  				AppendIndent(sb).AppendLine("\t(");  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction) expr;    				switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}  			}
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid)  			{  				var s = ((Guid)value).ToString("N");    				sb  					.Append("Cast(x'")  					.Append(s.Substring( 6'  2))  					.Append(s.Substring( 4'  2))  					.Append(s.Substring( 2'  2))  					.Append(s.Substring( 0'  2))  					.Append(s.Substring(10'  2))  					.Append(s.Substring( 8'  2))  					.Append(s.Substring(14'  2))  					.Append(s.Substring(12'  2))  					.Append(s.Substring(16' 16))  					.Append("' as char(16) for bit data)");  			}  			else  				base.BuildValue(sb' value);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression)  			{  				var be = (SqlBinaryExpression)expr;    				switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}  			}  			else if (expr is SqlFunction)  			{  				var func = (SqlFunction)expr;    				switch (func.Name)  				{  					case "Coalesce" : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"  :  						{  							var par0 = func.Parameters[0];  							var par1 = func.Parameters[1];    							switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  							{  								case TypeCode.String   : return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]);  								case TypeCode.Boolean  :  									{  										var ex = AlternativeConvertToBoolean(func' 1);  										if (ex != null)  											return ex;  										break;  									}    								case TypeCode.UInt64:  									if (TypeHelper.IsFloatType(func.Parameters[1].SystemType))  										par1 = new SqlFunction(func.SystemType' "Floor"' func.Parameters[1]);  									break;    								case TypeCode.DateTime :  									if (IsDateDataType(func.Parameters[0]' "Date"))  									{  										if (func.Parameters[1].SystemType == typeof(string))  										{  											return new SqlFunction(  												func.SystemType'  												"Date"'  												new SqlFunction(func.SystemType' "To_Date"' func.Parameters[1]' new SqlValue("%Y-%m-%d")));  										}    										return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  									}    									if (IsTimeDataType(func.Parameters[0]))  										return new SqlExpression(func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters[1]);    									return new SqlFunction(func.SystemType' "To_Date"' func.Parameters[1]);    								default:  									if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(DateTimeOffset))  										goto case TypeCode.DateTime;  									break;  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' par1' par0);  						}    					case "Quarter"  : return Inc(Div(Dec(new SqlFunction(func.SystemType' "Month"' func.Parameters))' 3));  					case "WeekDay"  : return Inc(new SqlFunction(func.SystemType' "weekDay"' func.Parameters));  					case "DayOfYear":  						return  							Inc(Sub<int>(  								new SqlFunction(null' "Mdy"'  									new SqlFunction(null' "Month"' func.Parameters)'  									new SqlFunction(null' "Day"'   func.Parameters)'  									new SqlFunction(null' "Year"'  func.Parameters))'  								new SqlFunction(null' "Mdy"'  									new SqlValue(1)'  									new SqlValue(1)'  									new SqlFunction(null' "Year"' func.Parameters))));  					case "Week"     :  						return  							new SqlExpression(  								func.SystemType'  								"((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"'  								func.Parameters);  					case "Hour"     :  					case "Minute"   :  					case "Second"   : return new SqlExpression(func.SystemType' string.Format("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters);  				}  			}
Magic Number,BLToolkit.Data.Sql,SqlFunction,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,ToString,The following statement contains a magic number: if (Parameters.Length > 0)  				sb.Length -= 2;
Magic Number,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,CheckColumn,The following statement contains a magic number: if (optimizeColumns &&  				visitor.Find(expr' e => e is SqlQuery || IsAggregationFunction(e)) == null)  			{  				var n = 0;  				var q = query.ParentSql ?? query;    				visitor.VisitAll(q' e => { if (e == column) n++; });    				return n > 2;  			}
Magic Number,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetAlias,The following statement contains a magic number: if (string.IsNullOrEmpty(desiredAlias) || desiredAlias.Length > 30)  			{  				desiredAlias = defaultAlias;  				alias        = defaultAlias + "1";  			}
Magic Number,BLToolkit.Data.Sql,TableSource,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The following statement contains a magic number: if (sb.Length > 500)  					return sb;
Magic Number,BLToolkit.Data.Sql,SearchCondition,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The following statement contains a magic number: if (Conditions.Count > 0)  					sb.Length -= 4;
Magic Number,BLToolkit.Data.Sql,SelectClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The following statement contains a magic number: sb.Length -= 3;
Magic Number,BLToolkit.Data.Sql,FromClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The following statement contains a magic number: if (Tables.Count > 0)  				{  					foreach (IQueryElement ts in Tables)  					{  						sb.Append('\t');  						var len = sb.Length;  						ts.ToString(sb' dic).Replace("\n"' "\n\t"' len' sb.Length - len);  						sb.Append("' ");  					}    					sb.Length -= 2;  				}
Magic Number,BLToolkit.Data.Sql,OrderByClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The following statement contains a magic number: sb.Length -= 2;
Magic Number,BLToolkit.Mapping,ExpressionMapper<TSource;TDest>,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetMapper,The following statement contains a magic number: if (_parameters.ContextParameterUsed)  			{  				var l = Expression.Lambda<Func<TSource'MappingContext'TDest>>(expr' parm' _parameters.MappingContext);  				var f = l.Compile();    				if (!_parameters.UseContext)  					return s => f(s' null);    				return s =>  				{  					var ctx  = new MappingContext  					{  						Objects   = new Dictionary<object'object>(10) { { s' null } }'  						GetParent = p => p'  					};    					var dest = f(s' ctx);    					if (ctx.CrossActions != null)  						foreach (var circle in ctx.CrossActions)  							circle(dest);    					if (ctx.Crosses != null)  					{  						List<Action<object'object>> list;    						if (ctx.Crosses.TryGetValue(s' out list))  							foreach (var action in list)  								action(dest' dest);  					}    					return dest;  				};  			}
Magic Number,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadHeader,The following statement contains a magic number: while (ReadNextLine())  			{  				if (_line.StartsWith("*:"))  				{  					_names  = _line.Substring(2).Split(':');  					_values = new string[_names.Length];    					for (int i = 0; i < _names.Length; i++)  						_names[i] = _names[i].Trim();  				}  				else if (_line.StartsWith("**") || _line.StartsWith("*-"))  					break;  			}
Magic Number,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof)  			{  				if (_line.StartsWith("*-"))  					return false;    				if (_line.StartsWith("**") && _line.Length > 3)  				{  					var values = _line.Substring(3).Split(_line[2]);    					for (var i = 0; i < _values.Length && i < values.Length; i++)  					{  						var value = values[i];    						_values[i] =  							value.Length == 0? null:  							value[0] == '*'?   value.Substring(1):  							value[0] == '+'?   Encode(value.Substring(1)) : value;  					}    					ReadNextLine();    					return true;  				}    				throw new MappingException(  					string.Format("Invalid data format in the line {0}."' _lineNumber));  			}
Magic Number,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof)  			{  				if (_line.StartsWith("*-"))  					return false;    				if (_line.StartsWith("**") && _line.Length > 3)  				{  					var values = _line.Substring(3).Split(_line[2]);    					for (var i = 0; i < _values.Length && i < values.Length; i++)  					{  						var value = values[i];    						_values[i] =  							value.Length == 0? null:  							value[0] == '*'?   value.Substring(1):  							value[0] == '+'?   Encode(value.Substring(1)) : value;  					}    					ReadNextLine();    					return true;  				}    				throw new MappingException(  					string.Format("Invalid data format in the line {0}."' _lineNumber));  			}
Magic Number,BLToolkit.Mapping,TextDataReader,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof)  			{  				if (_line.StartsWith("*-"))  					return false;    				if (_line.StartsWith("**") && _line.Length > 3)  				{  					var values = _line.Substring(3).Split(_line[2]);    					for (var i = 0; i < _values.Length && i < values.Length; i++)  					{  						var value = values[i];    						_values[i] =  							value.Length == 0? null:  							value[0] == '*'?   value.Substring(1):  							value[0] == '+'?   Encode(value.Substring(1)) : value;  					}    					ReadNextLine();    					return true;  				}    				throw new MappingException(  					string.Format("Invalid data format in the line {0}."' _lineNumber));  			}
Magic Number,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetMember,The following statement contains a magic number: switch (memberType)  			{  				case 1: mi = Type.GetField   (memberName' allInstaceMembers); break;  				case 2:  					mi =  						Type.        GetProperty(memberName' allInstaceMembers) ??  						OriginalType.GetProperty(memberName' allInstaceMembers);  					break;  				default:  					throw new InvalidOperationException();  			}
Magic Number,BLToolkit.Reflection,TypeAccessor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,GetHashCode,The following statement contains a magic number: foreach (MemberAccessor ma in GetAccessor(obj.GetType()))  			{  				value = ma.GetValue(obj);  				hash = ((hash << 5) + hash) ^ (value == null ? 0 : value.GetHashCode());  			}
Magic Number,BLToolkit.ServiceModel,DeserializerBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,ReadInt,The following statement contains a magic number: for (var c = Peek(); char.IsDigit(c); c = Next())  					value = value * 10 + (c - '0');
Magic Number,BLToolkit.ServiceModel,DeserializerBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,ReadCount,The following statement contains a magic number: for (var c = Peek(); char.IsDigit(c); c = Next())  					value = value * 10 + (c - '0');
Magic Number,BLToolkit.ServiceModel,ResultSerializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Serialize,The following statement contains a magic number: foreach (var data in result.Data)  				{  					foreach (var str in data)  					{  						if (result.VaryingTypes.Length > 0 && !string.IsNullOrEmpty(str) && str[0] == '\0')  						{  							Builder.Append('*');  							Append((int)str[1]);  							Append(str.Substring(2));  						}  						else  							Append(str);  					}    					Builder.AppendLine();  				}
Magic Number,BLToolkit.ServiceModel,ServiceModelDataReader,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,The following statement contains a magic number: if (_result.VaryingTypes.Length > 0 && !string.IsNullOrEmpty(value) && value[0] == '\0') 			{ 				type  = _result.VaryingTypes[value[1]]; 				value = value.Substring(2); 			}
Magic Number,BLToolkit.TypeBuilder,TypeFactory,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,The following statement contains a magic number: if (nameParts.Length > 0 && nameParts[0].ToLower().EndsWith(".dll"))  			{  				nameParts[0] = nameParts[0].Substring(0' nameParts[0].Length - 4);  				name         = string.Join("'"' nameParts);  			}
Magic Number,BLToolkit.TypeBuilder.Builders,BuildContext,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\BuildContext.cs,BuildContext,The following statement contains a magic number: Items = new Dictionary<object'object>(10);
Magic Number,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildInitMember,The following statement contains a magic number: _typeBuilder.DefaultConstructor.Emitter  				.ldarg_0  				.ldarg_0  				.ldarg_0  				.ldc_i4  (mi is FieldInfo? 1: 2)  				.ldstr   (mi.Name)  				.call    (_accessorType.GetMethod("GetMember"' typeof(int)' typeof(string)))  				.newobj  (ctorBuilder)  				.call    (_accessorType.GetMethod("AddMember"' typeof(MemberAccessor)))  				;
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (idx > 0)  			{  				path = path.Substring(0' idx);    				if (path.Length >= 200)  				{  					idx = path.IndexOf('`');    					if (idx > 0)  					{  						var idx2 = path.LastIndexOf('.');    						if (idx2 > 0 && idx2 > idx)  							path = path.Substring(0' idx + 1) + path.Substring(idx2 + 1);  					}  				}  			}
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (path.Length >= 260)  			{  				path = path.Substring(0' 248);    				for (var i = 0; i < int.MaxValue; i++)  				{  					var newPath = string.Format("{0}_{1:0000}.dll"' path' i);    					if (!System.IO.File.Exists(newPath))  					{  						path = newPath;  						break;  					}  				}  			}
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (path.Length >= 260)  			{  				path = path.Substring(0' 248);    				for (var i = 0; i < int.MaxValue; i++)  				{  					var newPath = string.Format("{0}_{1:0000}.dll"' path' i);    					if (!System.IO.File.Exists(newPath))  					{  						path = newPath;  						break;  					}  				}  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldarg,The following statement contains a magic number: switch (index)  			{  				case 0: ldarg_0.end(); break;  				case 1: ldarg_1.end(); break;  				case 2: ldarg_2.end(); break;  				case 3: ldarg_3.end(); break;  				default:  					if      (index <= byte. MaxValue) ldarg_s((byte)index);  					else if (index <= short.MaxValue) ldarg ((short)index);  					else  						throw new ArgumentOutOfRangeException("index");    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldarg,The following statement contains a magic number: switch (index)  			{  				case 0: ldarg_0.end(); break;  				case 1: ldarg_1.end(); break;  				case 2: ldarg_2.end(); break;  				case 3: ldarg_3.end(); break;  				default:  					if      (index <= byte. MaxValue) ldarg_s((byte)index);  					else if (index <= short.MaxValue) ldarg ((short)index);  					else  						throw new ArgumentOutOfRangeException("index");    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num)  			{  				case -1: ldc_i4_m1.end(); break;  				case  0: ldc_i4_0. end(); break;  				case  1: ldc_i4_1. end(); break;  				case  2: ldc_i4_2. end(); break;  				case  3: ldc_i4_3. end(); break;  				case  4: ldc_i4_4. end(); break;  				case  5: ldc_i4_5. end(); break;  				case  6: ldc_i4_6. end(); break;  				case  7: ldc_i4_7. end(); break;  				case  8: ldc_i4_8. end(); break;  				default:  					if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  						ldc_i4_s((sbyte)num);  					else  						ldc_i4   (num);    					break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stloc_s,The following statement contains a magic number: switch (index)  			{  				case 0: stloc_0.end(); break;  				case 1: stloc_1.end(); break;  				case 2: stloc_2.end(); break;  				case 3: stloc_3.end(); break;    				default:  					_ilGenerator.Emit(OpCodes.Stloc_S' index); break;  			}
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stloc_s,The following statement contains a magic number: switch (index)  			{  				case 0: stloc_0.end(); break;  				case 1: stloc_1.end(); break;  				case 2: stloc_2.end(); break;  				case 3: stloc_3.end(); break;    				default:  					_ilGenerator.Emit(OpCodes.Stloc_S' index); break;  			}
Magic Number,BLToolkit.Net,HttpReader,C:\repos\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Post,The following statement contains a magic number: for (int i = 0; i < 10; i++)  			{  				bool post = false;    				switch (StatusCode)  				{  					case HttpStatusCode.MultipleChoices:   // 300  					case HttpStatusCode.MovedPermanently:  // 301  					case HttpStatusCode.Found:             // 302  					case HttpStatusCode.SeeOther:          // 303  						break;    					case HttpStatusCode.TemporaryRedirect: // 307  						post = true;  						break;    					default:  						return StatusCode;  				}    				if (Location == null)  					break;    				Uri uri = new Uri(new Uri(PreviousUri)' Location);    				BaseUri    = uri.Scheme + "://" + uri.Host;  				requestUri = uri.AbsolutePath + uri.Query;    				Request(  					requestUri'  					post? "POST": "GET"'  					post? requestStreamProcessor: null'  					responseStreamProcessor);  			}
Duplicate Code,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The method contains a code clone-set at the following line numbers (starting from the method definition): ((21' 42)' (137' 158))
Missing Default,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,IsApplied,The following switch statement is missing a default case: switch (context.Step)  			{  				case BuildStep.Begin:   return true;  				case BuildStep.Before:  return (_interceptType & InterceptType.BeforeCall) != 0;  				case BuildStep.After:   return (_interceptType & InterceptType.AfterCall)  != 0;  				case BuildStep.Catch:   return (_interceptType & InterceptType.OnCatch)    != 0;  				case BuildStep.Finally: return (_interceptType & InterceptType.OnFinally)  != 0;  				case BuildStep.End:     return true;  			}
Missing Default,BLToolkit.Aspects,CacheAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,The following switch statement is missing a default case: switch (vs[0].ToLower().Trim())  					{  						case "maxcachetime": _instanceMaxCacheTime = int. Parse(vs[1].Trim()); break;  						case "isweak":       _instanceIsWeak       = bool.Parse(vs[1].Trim()); break;  					}
Missing Default,BLToolkit.Aspects,Interceptor,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\Interceptor.cs,Intercept,The following switch statement is missing a default case: switch (info.InterceptType)  			{  				case InterceptType.BeforeCall: BeforeCall(info); break;  				case InterceptType.AfterCall:  AfterCall (info); break;  				case InterceptType.OnCatch:    OnCatch   (info); break;  				case InterceptType.OnFinally:  OnFinally (info); break;  			}
Missing Default,BLToolkit.Aspects,LoggingAspect,C:\repos\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,The following switch statement is missing a default case: switch (vs[0].ToLower().Trim())  					{  						case "filename":      _instanceFileName      =            vs[1].Trim();  break;  						case "mincalltime":   _instanceMinCallTime   = int. Parse(vs[1].Trim()); break;  						case "logexceptions": _instanceLogExceptions = bool.Parse(vs[1].Trim()); break;  						case "logparameters": _instanceLogParameters = bool.Parse(vs[1].Trim()); break;  					}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Boolean;  				case TypeCode.Boolean : return (Boolean)p;  				case TypeCode.Char    : return ToBoolean((Char)   p);  				case TypeCode.String  : return ToBoolean((String) p);  				case TypeCode.SByte   : return ToBoolean((SByte)  p);  				case TypeCode.Int16   : return ToBoolean((Int16)  p);  				case TypeCode.Int32   : return ToBoolean((Int32)  p);  				case TypeCode.Int64   : return ToBoolean((Int64)  p);  				case TypeCode.Byte    : return ToBoolean((Byte)   p);  				case TypeCode.UInt16  : return ToBoolean((UInt16) p);  				case TypeCode.UInt32  : return ToBoolean((UInt32) p);  				case TypeCode.UInt64  : return ToBoolean((UInt64) p);  				case TypeCode.Single  : return ToBoolean((Single) p);  				case TypeCode.Double  : return ToBoolean((Double) p);  				case TypeCode.Decimal : return ToBoolean((Decimal)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByte,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Byte;  				case TypeCode.Byte    : return (Byte)p;  				case TypeCode.SByte   : return ToByte((SByte)  p);  				case TypeCode.Int16   : return ToByte((Int16)  p);  				case TypeCode.Int32   : return ToByte((Int32)  p);  				case TypeCode.Int64   : return ToByte((Int64)  p);  				case TypeCode.UInt16  : return ToByte((UInt16) p);  				case TypeCode.UInt32  : return ToByte((UInt32) p);  				case TypeCode.UInt64  : return ToByte((UInt64) p);  				case TypeCode.Single  : return ToByte((Single) p);  				case TypeCode.Double  : return ToByte((Double) p);  				case TypeCode.Decimal : return ToByte((Decimal)p);  				case TypeCode.Char    : return ToByte((Char)   p);  				case TypeCode.String  : return ToByte((String) p);  				case TypeCode.Boolean : return ToByte((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToChar,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Char;  				case TypeCode.Char    : return (Char)p;  				case TypeCode.SByte   : return ToChar((SByte)  p);  				case TypeCode.Int16   : return ToChar((Int16)  p);  				case TypeCode.Int32   : return ToChar((Int32)  p);  				case TypeCode.Int64   : return ToChar((Int64)  p);  				case TypeCode.Byte    : return ToChar((Byte)   p);  				case TypeCode.UInt16  : return ToChar((UInt16) p);  				case TypeCode.UInt32  : return ToChar((UInt32) p);  				case TypeCode.UInt64  : return ToChar((UInt64) p);  				case TypeCode.Single  : return ToChar((Single) p);  				case TypeCode.Double  : return ToChar((Double) p);  				case TypeCode.Decimal : return ToChar((Decimal)p);  				case TypeCode.String  : return ToChar((String) p);  				case TypeCode.Boolean : return ToChar((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return Configuration.NullableValues.DateTime;  				case TypeCode.DateTime : return (DateTime)p;  				case TypeCode.String   : return ToDateTime((String)  p);  				case TypeCode.Int64    : return ToDateTime((Int64)   p);  				case TypeCode.Double   : return ToDateTime((Double)  p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTimeOffset,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull         : return DateTimeOffset.MinValue;  				case TypeCode.Int64          : return ToDateTimeOffset((Int64)         p);  				case TypeCode.Double         : return ToDateTimeOffset((Double)        p);  				case TypeCode.DateTime       : return ToDateTimeOffset((DateTime)      p);  				case TypeCode.String         : return ToDateTimeOffset((String)        p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Decimal;  				case TypeCode.Decimal : return (Decimal)p;  				case TypeCode.SByte   : return ToDecimal((SByte)  p);  				case TypeCode.Int16   : return ToDecimal((Int16)  p);  				case TypeCode.Int32   : return ToDecimal((Int32)  p);  				case TypeCode.Int64   : return ToDecimal((Int64)  p);  				case TypeCode.Byte    : return ToDecimal((Byte)   p);  				case TypeCode.UInt16  : return ToDecimal((UInt16) p);  				case TypeCode.UInt32  : return ToDecimal((UInt32) p);  				case TypeCode.Char    : return ToDecimal((Char)   p);  				case TypeCode.UInt64  : return ToDecimal((UInt64) p);  				case TypeCode.Single  : return ToDecimal((Single) p);  				case TypeCode.Double  : return ToDecimal((Double) p);  				case TypeCode.String  : return ToDecimal((String) p);  				case TypeCode.Boolean : return ToDecimal((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return Configuration.NullableValues.Double;  				case TypeCode.Double   : return (Double)p;  				case TypeCode.DateTime : return ToDouble((DateTime)p);  				case TypeCode.SByte    : return ToDouble((SByte)   p);  				case TypeCode.Int16    : return ToDouble((Int16)   p);  				case TypeCode.Int32    : return ToDouble((Int32)   p);  				case TypeCode.Int64    : return ToDouble((Int64)   p);  				case TypeCode.Byte     : return ToDouble((Byte)    p);  				case TypeCode.UInt16   : return ToDouble((UInt16)  p);  				case TypeCode.UInt32   : return ToDouble((UInt32)  p);  				case TypeCode.Char     : return ToDouble((Char)    p);  				case TypeCode.UInt64   : return ToDouble((UInt64)  p);  				case TypeCode.Single   : return ToDouble((Single)  p);  				case TypeCode.Decimal  : return ToDouble((Decimal) p);  				case TypeCode.String   : return ToDouble((String)  p);  				case TypeCode.Boolean  : return ToDouble((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull : return Configuration.NullableValues.Guid;  				case TypeCode.String : return ToGuid((String)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Int16;  				case TypeCode.Int16   : return (Int16)p;  				case TypeCode.SByte   : return ToInt16((SByte)  p);  				case TypeCode.Byte    : return ToInt16((Byte)   p);  				case TypeCode.Int32   : return ToInt16((Int32)  p);  				case TypeCode.Int64   : return ToInt16((Int64)  p);  				case TypeCode.UInt16  : return ToInt16((UInt16) p);  				case TypeCode.UInt32  : return ToInt16((UInt32) p);  				case TypeCode.UInt64  : return ToInt16((UInt64) p);  				case TypeCode.Single  : return ToInt16((Single) p);  				case TypeCode.Double  : return ToInt16((Double) p);  				case TypeCode.Decimal : return ToInt16((Decimal)p);  				case TypeCode.Char    : return ToInt16((Char)   p);  				case TypeCode.String  : return ToInt16((String) p);  				case TypeCode.Boolean : return ToInt16((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Int32;  				case TypeCode.Int32   : return (Int32)p;  				case TypeCode.SByte   : return ToInt32((SByte)  p);  				case TypeCode.Int16   : return ToInt32((Int16)  p);  				case TypeCode.Byte    : return ToInt32((Byte)   p);  				case TypeCode.UInt16  : return ToInt32((UInt16) p);  				case TypeCode.Char    : return ToInt32((Char)   p);  				case TypeCode.Int64   : return ToInt32((Int64)  p);  				case TypeCode.UInt32  : return ToInt32((UInt32) p);  				case TypeCode.UInt64  : return ToInt32((UInt64) p);  				case TypeCode.Single  : return ToInt32((Single) p);  				case TypeCode.Double  : return ToInt32((Double) p);  				case TypeCode.Decimal : return ToInt32((Decimal)p);  				case TypeCode.String  : return ToInt32((String) p);  				case TypeCode.Boolean : return ToInt32((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return Configuration.NullableValues.Int64;  				case TypeCode.Int64    : return (Int64)p;  				case TypeCode.DateTime : return ToInt64((DateTime)p);  				case TypeCode.SByte    : return ToInt64((SByte)   p);  				case TypeCode.Int16    : return ToInt64((Int16)   p);  				case TypeCode.Int32    : return ToInt64((Int32)   p);  				case TypeCode.Byte     : return ToInt64((Byte)    p);  				case TypeCode.UInt16   : return ToInt64((UInt16)  p);  				case TypeCode.UInt32   : return ToInt64((UInt32)  p);  				case TypeCode.Char     : return ToInt64((Char)    p);  				case TypeCode.UInt64   : return ToInt64((UInt64)  p);  				case TypeCode.Single   : return ToInt64((Single)  p);  				case TypeCode.Double   : return ToInt64((Double)  p);  				case TypeCode.Decimal  : return ToInt64((Decimal) p);  				case TypeCode.String   : return ToInt64((String)  p);  				case TypeCode.Boolean  : return ToInt64((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSByte,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.SByte;  				case TypeCode.SByte   : return (SByte)p;  				case TypeCode.Int16   : return ToSByte((Int16)  p);  				case TypeCode.Int32   : return ToSByte((Int32)  p);  				case TypeCode.Int64   : return ToSByte((Int64)  p);  				case TypeCode.Byte    : return ToSByte((Byte)   p);  				case TypeCode.UInt16  : return ToSByte((UInt16) p);  				case TypeCode.UInt32  : return ToSByte((UInt32) p);  				case TypeCode.UInt64  : return ToSByte((UInt64) p);  				case TypeCode.Single  : return ToSByte((Single) p);  				case TypeCode.Double  : return ToSByte((Double) p);  				case TypeCode.Decimal : return ToSByte((Decimal)p);  				case TypeCode.Char    : return ToSByte((Char)   p);  				case TypeCode.String  : return ToSByte((String) p);  				case TypeCode.Boolean : return ToSByte((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.Single;  				case TypeCode.Single  : return (Single)p;  				case TypeCode.SByte   : return ToSingle((SByte)  p);  				case TypeCode.Int16   : return ToSingle((Int16)  p);  				case TypeCode.Int32   : return ToSingle((Int32)  p);  				case TypeCode.Int64   : return ToSingle((Int64)  p);  				case TypeCode.Byte    : return ToSingle((Byte)   p);  				case TypeCode.UInt16  : return ToSingle((UInt16) p);  				case TypeCode.UInt32  : return ToSingle((UInt32) p);  				case TypeCode.Char    : return ToSingle((Char)   p);  				case TypeCode.UInt64  : return ToSingle((UInt64) p);  				case TypeCode.Double  : return ToSingle((Double) p);  				case TypeCode.Decimal : return ToSingle((Decimal)p);  				case TypeCode.String  : return ToSingle((String) p);  				case TypeCode.Boolean : return ToSingle((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToString,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return Configuration.NullableValues.String;  				case TypeCode.String   : return (String)p;  				case TypeCode.SByte    : return ToString((SByte)   p);  				case TypeCode.Int16    : return ToString((Int16)   p);  				case TypeCode.Int32    : return ToString((Int32)   p);  				case TypeCode.Int64    : return ToString((Int64)   p);  				case TypeCode.Byte     : return ToString((Byte)    p);  				case TypeCode.UInt16   : return ToString((UInt16)  p);  				case TypeCode.UInt32   : return ToString((UInt32)  p);  				case TypeCode.UInt64   : return ToString((UInt64)  p);  				case TypeCode.Single   : return ToString((Single)  p);  				case TypeCode.Double   : return ToString((Double)  p);  				case TypeCode.Boolean  : return ToString((Boolean) p);  				case TypeCode.Decimal  : return ToString((Decimal) p);  				case TypeCode.Char     : return ToString((Char)    p);  				case TypeCode.DateTime : return ToString((DateTime)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return Configuration.NullableValues.TimeSpan;  				case TypeCode.DateTime : return ToTimeSpan((DateTime)p);  				case TypeCode.Int64    : return ToTimeSpan((Int64)   p);  				case TypeCode.Double   : return ToTimeSpan((Double)  p);  				case TypeCode.String   : return ToTimeSpan((String)  p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.UInt16;  				case TypeCode.UInt16  : return (UInt16)p;  				case TypeCode.Byte    : return ToUInt16((Byte)   p);  				case TypeCode.SByte   : return ToUInt16((SByte)  p);  				case TypeCode.Int16   : return ToUInt16((Int16)  p);  				case TypeCode.Int32   : return ToUInt16((Int32)  p);  				case TypeCode.Int64   : return ToUInt16((Int64)  p);  				case TypeCode.UInt32  : return ToUInt16((UInt32) p);  				case TypeCode.UInt64  : return ToUInt16((UInt64) p);  				case TypeCode.Single  : return ToUInt16((Single) p);  				case TypeCode.Double  : return ToUInt16((Double) p);  				case TypeCode.Decimal : return ToUInt16((Decimal)p);  				case TypeCode.Char    : return ToUInt16((Char)   p);  				case TypeCode.String  : return ToUInt16((String) p);  				case TypeCode.Boolean : return ToUInt16((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.UInt32;  				case TypeCode.UInt32  : return (UInt32)p;  				case TypeCode.Byte    : return ToUInt32((Byte)   p);  				case TypeCode.UInt16  : return ToUInt32((UInt16) p);  				case TypeCode.SByte   : return ToUInt32((SByte)  p);  				case TypeCode.Int16   : return ToUInt32((Int16)  p);  				case TypeCode.Int32   : return ToUInt32((Int32)  p);  				case TypeCode.Int64   : return ToUInt32((Int64)  p);  				case TypeCode.UInt64  : return ToUInt32((UInt64) p);  				case TypeCode.Single  : return ToUInt32((Single) p);  				case TypeCode.Double  : return ToUInt32((Double) p);  				case TypeCode.Decimal : return ToUInt32((Decimal)p);  				case TypeCode.Char    : return ToUInt32((Char)   p);  				case TypeCode.String  : return ToUInt32((String) p);  				case TypeCode.Boolean : return ToUInt32((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return Configuration.NullableValues.UInt64;  				case TypeCode.UInt64  : return (UInt64)p;  				case TypeCode.Byte    : return ToUInt64((Byte)   p);  				case TypeCode.UInt16  : return ToUInt64((UInt16) p);  				case TypeCode.UInt32  : return ToUInt64((UInt32) p);  				case TypeCode.SByte   : return ToUInt64((SByte)  p);  				case TypeCode.Int16   : return ToUInt64((Int16)  p);  				case TypeCode.Int32   : return ToUInt64((Int32)  p);  				case TypeCode.Int64   : return ToUInt64((Int64)  p);  				case TypeCode.Single  : return ToUInt64((Single) p);  				case TypeCode.Double  : return ToUInt64((Double) p);  				case TypeCode.Decimal : return ToUInt64((Decimal)p);  				case TypeCode.Char    : return ToUInt64((Char)   p);  				case TypeCode.String  : return ToUInt64((String) p);  				case TypeCode.Boolean : return ToUInt64((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return null;  				case TypeCode.String   : return ToNullableBoolean((String)  p);  				case TypeCode.Boolean  : return ToNullableBoolean((Boolean) p);  				case TypeCode.Char     : return ToNullableBoolean((Char)    p);  				case TypeCode.SByte    : return ToNullableBoolean((SByte)   p);  				case TypeCode.Int16    : return ToNullableBoolean((Int16)   p);  				case TypeCode.Int32    : return ToNullableBoolean((Int32)   p);  				case TypeCode.Int64    : return ToNullableBoolean((Int64)   p);  				case TypeCode.Byte     : return ToNullableBoolean((Byte)    p);  				case TypeCode.UInt16   : return ToNullableBoolean((UInt16)  p);  				case TypeCode.UInt32   : return ToNullableBoolean((UInt32)  p);  				case TypeCode.UInt64   : return ToNullableBoolean((UInt64)  p);  				case TypeCode.Single   : return ToNullableBoolean((Single)  p);  				case TypeCode.Double   : return ToNullableBoolean((Double)  p);  				case TypeCode.Decimal  : return ToNullableBoolean((Decimal) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableByte,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.Byte    : return ToNullableByte((Byte)   p);  				case TypeCode.SByte   : return ToNullableByte((SByte)  p);  				case TypeCode.Int16   : return ToNullableByte((Int16)  p);  				case TypeCode.Int32   : return ToNullableByte((Int32)  p);  				case TypeCode.Int64   : return ToNullableByte((Int64)  p);  				case TypeCode.UInt16  : return ToNullableByte((UInt16) p);  				case TypeCode.UInt32  : return ToNullableByte((UInt32) p);  				case TypeCode.UInt64  : return ToNullableByte((UInt64) p);  				case TypeCode.Single  : return ToNullableByte((Single) p);  				case TypeCode.Double  : return ToNullableByte((Double) p);  				case TypeCode.Decimal : return ToNullableByte((Decimal)p);  				case TypeCode.Char    : return ToNullableByte((Char)   p);  				case TypeCode.String  : return ToNullableByte((String) p);  				case TypeCode.Boolean : return ToNullableByte((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableChar,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.Char    : return ToNullableChar((Char)   p);  				case TypeCode.SByte   : return ToNullableChar((SByte)  p);  				case TypeCode.Int16   : return ToNullableChar((Int16)  p);  				case TypeCode.Int32   : return ToNullableChar((Int32)  p);  				case TypeCode.Int64   : return ToNullableChar((Int64)  p);  				case TypeCode.Byte    : return ToNullableChar((Byte)   p);  				case TypeCode.UInt16  : return ToNullableChar((UInt16) p);  				case TypeCode.UInt32  : return ToNullableChar((UInt32) p);  				case TypeCode.UInt64  : return ToNullableChar((UInt64) p);  				case TypeCode.Single  : return ToNullableChar((Single) p);  				case TypeCode.Double  : return ToNullableChar((Double) p);  				case TypeCode.Decimal : return ToNullableChar((Decimal)p);  				case TypeCode.String  : return ToNullableChar((String) p);  				case TypeCode.Boolean : return ToNullableChar((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull    : return null;  				case TypeCode.DateTime  : return ToNullableDateTime((DateTime) p);  				case TypeCode.String    : return ToNullableDateTime((String)   p);  				case TypeCode.Int64     : return ToNullableDateTime((Int64)    p);  				case TypeCode.Double    : return ToNullableDateTime((Double)   p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTimeOffset,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull          : return null;  				case TypeCode.Int64           : return ToNullableDateTimeOffset((Int64)          p);  				case TypeCode.Double          : return ToNullableDateTimeOffset((Double)         p);  				case TypeCode.DateTime        : return ToNullableDateTimeOffset((DateTime)       p);  				case TypeCode.String          : return ToNullableDateTimeOffset((String)         p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return null;  				case TypeCode.SByte    : return ToNullableDecimal((SByte)   p);  				case TypeCode.Int16    : return ToNullableDecimal((Int16)   p);  				case TypeCode.Int32    : return ToNullableDecimal((Int32)   p);  				case TypeCode.Int64    : return ToNullableDecimal((Int64)   p);  				case TypeCode.Byte     : return ToNullableDecimal((Byte)    p);  				case TypeCode.UInt16   : return ToNullableDecimal((UInt16)  p);  				case TypeCode.UInt32   : return ToNullableDecimal((UInt32)  p);  				case TypeCode.Char     : return ToNullableDecimal((Char)    p);  				case TypeCode.UInt64   : return ToNullableDecimal((UInt64)  p);  				case TypeCode.Decimal  : return ToNullableDecimal((Decimal) p);  				case TypeCode.Single   : return ToNullableDecimal((Single)  p);  				case TypeCode.Double   : return ToNullableDecimal((Double)  p);  				case TypeCode.String   : return ToNullableDecimal((String)  p);  				case TypeCode.Boolean  : return ToNullableDecimal((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return null;  				case TypeCode.DateTime : return ToNullableDouble((DateTime)p);  				case TypeCode.SByte    : return ToNullableDouble((SByte)   p);  				case TypeCode.Int16    : return ToNullableDouble((Int16)   p);  				case TypeCode.Int32    : return ToNullableDouble((Int32)   p);  				case TypeCode.Int64    : return ToNullableDouble((Int64)   p);  				case TypeCode.Byte     : return ToNullableDouble((Byte)    p);  				case TypeCode.UInt16   : return ToNullableDouble((UInt16)  p);  				case TypeCode.UInt32   : return ToNullableDouble((UInt32)  p);  				case TypeCode.Char     : return ToNullableDouble((Char)    p);  				case TypeCode.UInt64   : return ToNullableDouble((UInt64)  p);  				case TypeCode.Single   : return ToNullableDouble((Single)  p);  				case TypeCode.Double   : return ToNullableDouble((Double)  p);  				case TypeCode.Decimal  : return ToNullableDouble((Decimal) p);  				case TypeCode.String   : return ToNullableDouble((String)  p);  				case TypeCode.Boolean  : return ToNullableDouble((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull : return null;  				case TypeCode.String : return ToNullableGuid((String)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.SByte   : return ToNullableInt16((SByte)  p);  				case TypeCode.Int16   : return ToNullableInt16((Int16)  p);  				case TypeCode.Byte    : return ToNullableInt16((Byte)   p);  				case TypeCode.Int32   : return ToNullableInt16((Int32)  p);  				case TypeCode.Int64   : return ToNullableInt16((Int64)  p);  				case TypeCode.UInt16  : return ToNullableInt16((UInt16) p);  				case TypeCode.UInt32  : return ToNullableInt16((UInt32) p);  				case TypeCode.UInt64  : return ToNullableInt16((UInt64) p);  				case TypeCode.Single  : return ToNullableInt16((Single) p);  				case TypeCode.Double  : return ToNullableInt16((Double) p);  				case TypeCode.Decimal : return ToNullableInt16((Decimal)p);  				case TypeCode.Char    : return ToNullableInt16((Char)   p);  				case TypeCode.String  : return ToNullableInt16((String) p);  				case TypeCode.Boolean : return ToNullableInt16((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.SByte   : return ToNullableInt32((SByte)  p);  				case TypeCode.Int16   : return ToNullableInt32((Int16)  p);  				case TypeCode.Int32   : return ToNullableInt32((Int32)  p);  				case TypeCode.Byte    : return ToNullableInt32((Byte)   p);  				case TypeCode.UInt16  : return ToNullableInt32((UInt16) p);  				case TypeCode.Char    : return ToNullableInt32((Char)   p);  				case TypeCode.Int64   : return ToNullableInt32((Int64)  p);  				case TypeCode.UInt32  : return ToNullableInt32((UInt32) p);  				case TypeCode.UInt64  : return ToNullableInt32((UInt64) p);  				case TypeCode.Single  : return ToNullableInt32((Single) p);  				case TypeCode.Double  : return ToNullableInt32((Double) p);  				case TypeCode.Decimal : return ToNullableInt32((Decimal)p);  				case TypeCode.String  : return ToNullableInt32((String) p);  				case TypeCode.Boolean : return ToNullableInt32((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return null;  				case TypeCode.DateTime : return ToNullableInt64((DateTime)p);  				case TypeCode.SByte    : return ToNullableInt64((SByte)   p);  				case TypeCode.Int16    : return ToNullableInt64((Int16)   p);  				case TypeCode.Int32    : return ToNullableInt64((Int32)   p);  				case TypeCode.Int64    : return ToNullableInt64((Int64)   p);  				case TypeCode.Byte     : return ToNullableInt64((Byte)    p);  				case TypeCode.UInt16   : return ToNullableInt64((UInt16)  p);  				case TypeCode.UInt32   : return ToNullableInt64((UInt32)  p);  				case TypeCode.Char     : return ToNullableInt64((Char)    p);  				case TypeCode.UInt64   : return ToNullableInt64((UInt64)  p);  				case TypeCode.Single   : return ToNullableInt64((Single)  p);  				case TypeCode.Double   : return ToNullableInt64((Double)  p);  				case TypeCode.Decimal  : return ToNullableInt64((Decimal) p);  				case TypeCode.String   : return ToNullableInt64((String)  p);  				case TypeCode.Boolean  : return ToNullableInt64((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSByte,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.SByte   : return ToNullableSByte((SByte)  p);  				case TypeCode.Int16   : return ToNullableSByte((Int16)  p);  				case TypeCode.Int32   : return ToNullableSByte((Int32)  p);  				case TypeCode.Int64   : return ToNullableSByte((Int64)  p);  				case TypeCode.Byte    : return ToNullableSByte((Byte)   p);  				case TypeCode.UInt16  : return ToNullableSByte((UInt16) p);  				case TypeCode.UInt32  : return ToNullableSByte((UInt32) p);  				case TypeCode.UInt64  : return ToNullableSByte((UInt64) p);  				case TypeCode.Single  : return ToNullableSByte((Single) p);  				case TypeCode.Double  : return ToNullableSByte((Double) p);  				case TypeCode.Decimal : return ToNullableSByte((Decimal)p);  				case TypeCode.Char    : return ToNullableSByte((Char)   p);  				case TypeCode.String  : return ToNullableSByte((String) p);  				case TypeCode.Boolean : return ToNullableSByte((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.SByte   : return ToNullableSingle((SByte)  p);  				case TypeCode.Int16   : return ToNullableSingle((Int16)  p);  				case TypeCode.Int32   : return ToNullableSingle((Int32)  p);  				case TypeCode.Int64   : return ToNullableSingle((Int64)  p);  				case TypeCode.Byte    : return ToNullableSingle((Byte)   p);  				case TypeCode.UInt16  : return ToNullableSingle((UInt16) p);  				case TypeCode.UInt32  : return ToNullableSingle((UInt32) p);  				case TypeCode.Char    : return ToNullableSingle((Char)   p);  				case TypeCode.UInt64  : return ToNullableSingle((UInt64) p);  				case TypeCode.Single  : return ToNullableSingle((Single) p);  				case TypeCode.Double  : return ToNullableSingle((Double) p);  				case TypeCode.Decimal : return ToNullableSingle((Decimal)p);  				case TypeCode.String  : return ToNullableSingle((String) p);  				case TypeCode.Boolean : return ToNullableSingle((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableTimeSpan,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull    : return null;  				case TypeCode.DateTime  : return ToNullableTimeSpan((DateTime) p);  				case TypeCode.Int64     : return ToNullableTimeSpan((Int64)    p);  				case TypeCode.Double    : return ToNullableTimeSpan((Double)   p);  				case TypeCode.String    : return ToNullableTimeSpan((String)   p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.UInt16  : return ToNullableUInt16((UInt16) p);  				case TypeCode.Byte    : return ToNullableUInt16((Byte)   p);  				case TypeCode.SByte   : return ToNullableUInt16((SByte)  p);  				case TypeCode.Int16   : return ToNullableUInt16((Int16)  p);  				case TypeCode.Int32   : return ToNullableUInt16((Int32)  p);  				case TypeCode.Int64   : return ToNullableUInt16((Int64)  p);  				case TypeCode.UInt32  : return ToNullableUInt16((UInt32) p);  				case TypeCode.UInt64  : return ToNullableUInt16((UInt64) p);  				case TypeCode.Single  : return ToNullableUInt16((Single) p);  				case TypeCode.Double  : return ToNullableUInt16((Double) p);  				case TypeCode.Decimal : return ToNullableUInt16((Decimal)p);  				case TypeCode.Char    : return ToNullableUInt16((Char)   p);  				case TypeCode.String  : return ToNullableUInt16((String) p);  				case TypeCode.Boolean : return ToNullableUInt16((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.Byte    : return ToNullableUInt32((Byte)   p);  				case TypeCode.UInt16  : return ToNullableUInt32((UInt16) p);  				case TypeCode.UInt32  : return ToNullableUInt32((UInt32) p);  				case TypeCode.SByte   : return ToNullableUInt32((SByte)  p);  				case TypeCode.Int16   : return ToNullableUInt32((Int16)  p);  				case TypeCode.Int32   : return ToNullableUInt32((Int32)  p);  				case TypeCode.Int64   : return ToNullableUInt32((Int64)  p);  				case TypeCode.UInt64  : return ToNullableUInt32((UInt64) p);  				case TypeCode.Single  : return ToNullableUInt32((Single) p);  				case TypeCode.Double  : return ToNullableUInt32((Double) p);  				case TypeCode.Decimal : return ToNullableUInt32((Decimal)p);  				case TypeCode.Char    : return ToNullableUInt32((Char)   p);  				case TypeCode.String  : return ToNullableUInt32((String) p);  				case TypeCode.Boolean : return ToNullableUInt32((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return null;  				case TypeCode.Byte    : return ToNullableUInt64((Byte)   p);  				case TypeCode.UInt16  : return ToNullableUInt64((UInt16) p);  				case TypeCode.UInt32  : return ToNullableUInt64((UInt32) p);  				case TypeCode.UInt64  : return ToNullableUInt64((UInt64) p);  				case TypeCode.SByte   : return ToNullableUInt64((SByte)  p);  				case TypeCode.Int16   : return ToNullableUInt64((Int16)  p);  				case TypeCode.Int32   : return ToNullableUInt64((Int32)  p);  				case TypeCode.Int64   : return ToNullableUInt64((Int64)  p);  				case TypeCode.Single  : return ToNullableUInt64((Single) p);  				case TypeCode.Double  : return ToNullableUInt64((Double) p);  				case TypeCode.Decimal : return ToNullableUInt64((Decimal)p);  				case TypeCode.Char    : return ToNullableUInt64((Char)   p);  				case TypeCode.String  : return ToNullableUInt64((String) p);  				case TypeCode.Boolean : return ToNullableUInt64((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull     : return SqlBoolean.Null;  				case TypeCode.String     : return ToSqlBoolean((String)    p);  				case TypeCode.Boolean    : return ToSqlBoolean((Boolean)   p);  				case TypeCode.Char       : return ToSqlBoolean((Char)      p);  				case TypeCode.SByte      : return ToSqlBoolean((SByte)     p);  				case TypeCode.Int16      : return ToSqlBoolean((Int16)     p);  				case TypeCode.Int32      : return ToSqlBoolean((Int32)     p);  				case TypeCode.Int64      : return ToSqlBoolean((Int64)     p);  				case TypeCode.Byte       : return ToSqlBoolean((Byte)      p);  				case TypeCode.UInt16     : return ToSqlBoolean((UInt16)    p);  				case TypeCode.UInt32     : return ToSqlBoolean((UInt32)    p);  				case TypeCode.UInt64     : return ToSqlBoolean((UInt64)    p);  				case TypeCode.Single     : return ToSqlBoolean((Single)    p);  				case TypeCode.Double     : return ToSqlBoolean((Double)    p);  				case TypeCode.Decimal    : return ToSqlBoolean((Decimal)   p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlByte,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return SqlByte.Null;  				case TypeCode.Byte    : return ToSqlByte((Byte)   p);  				case TypeCode.SByte   : return ToSqlByte((SByte)  p);  				case TypeCode.Int16   : return ToSqlByte((Int16)  p);  				case TypeCode.Int32   : return ToSqlByte((Int32)  p);  				case TypeCode.Int64   : return ToSqlByte((Int64)  p);  				case TypeCode.UInt16  : return ToSqlByte((UInt16) p);  				case TypeCode.UInt32  : return ToSqlByte((UInt32) p);  				case TypeCode.UInt64  : return ToSqlByte((UInt64) p);  				case TypeCode.Single  : return ToSqlByte((Single) p);  				case TypeCode.Double  : return ToSqlByte((Double) p);  				case TypeCode.Decimal : return ToSqlByte((Decimal)p);  				case TypeCode.Char    : return ToSqlByte((Char)   p);  				case TypeCode.String  : return ToSqlByte((String) p);  				case TypeCode.Boolean : return ToSqlByte((Boolean)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBytes,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return SqlBytes.Null;  				case TypeCode.String   : return ToSqlBytes((String)  p);  				case TypeCode.Byte     : return ToSqlBytes((Byte)    p);  				case TypeCode.SByte    : return ToSqlBytes((SByte)   p);  				case TypeCode.DateTime : return ToSqlBytes((DateTime)p);  				case TypeCode.Int16    : return ToSqlBytes((Int16)   p);  				case TypeCode.Int32    : return ToSqlBytes((Int32)   p);  				case TypeCode.Int64    : return ToSqlBytes((Int64)   p);  				case TypeCode.UInt16   : return ToSqlBytes((UInt16)  p);  				case TypeCode.UInt32   : return ToSqlBytes((UInt32)  p);  				case TypeCode.UInt64   : return ToSqlBytes((UInt64)  p);  				case TypeCode.Single   : return ToSqlBytes((Single)  p);  				case TypeCode.Double   : return ToSqlBytes((Double)  p);  				case TypeCode.Boolean  : return ToSqlBytes((Boolean) p);  				case TypeCode.Char     : return ToSqlBytes((Char)    p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull      : return SqlDateTime.Null;  				case TypeCode.DateTime    : return ToSqlDateTime((DateTime)   p);  				case TypeCode.String      : return ToSqlDateTime((String)     p);  				case TypeCode.Int64       : return ToSqlDateTime((Int64)      p);  				case TypeCode.Double      : return ToSqlDateTime((Double)     p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull     : return SqlDecimal.Null;  				case TypeCode.SByte      : return ToSqlDecimal((SByte)     p);  				case TypeCode.Int16      : return ToSqlDecimal((Int16)     p);  				case TypeCode.Int32      : return ToSqlDecimal((Int32)     p);  				case TypeCode.Int64      : return ToSqlDecimal((Int64)     p);  				case TypeCode.Byte       : return ToSqlDecimal((Byte)      p);  				case TypeCode.UInt16     : return ToSqlDecimal((UInt16)    p);  				case TypeCode.UInt32     : return ToSqlDecimal((UInt32)    p);  				case TypeCode.Char       : return ToSqlDecimal((Char)      p);  				case TypeCode.UInt64     : return ToSqlDecimal((UInt64)    p);  				case TypeCode.Decimal    : return ToSqlDecimal((Decimal)   p);  				case TypeCode.Single     : return ToSqlDecimal((Single)    p);  				case TypeCode.Double     : return ToSqlDecimal((Double)    p);  				case TypeCode.String     : return ToSqlDecimal((String)    p);  				case TypeCode.Boolean    : return ToSqlDecimal((Boolean)   p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull    : return SqlDouble.Null;  				case TypeCode.DateTime  : return ToSqlDouble((DateTime) p);  				case TypeCode.SByte     : return ToSqlDouble((SByte)    p);  				case TypeCode.Int16     : return ToSqlDouble((Int16)    p);  				case TypeCode.Int32     : return ToSqlDouble((Int32)    p);  				case TypeCode.Int64     : return ToSqlDouble((Int64)    p);  				case TypeCode.Byte      : return ToSqlDouble((Byte)     p);  				case TypeCode.UInt16    : return ToSqlDouble((UInt16)   p);  				case TypeCode.UInt32    : return ToSqlDouble((UInt32)   p);  				case TypeCode.Char      : return ToSqlDouble((Char)     p);  				case TypeCode.UInt64    : return ToSqlDouble((UInt64)   p);  				case TypeCode.Single    : return ToSqlDouble((Single)   p);  				case TypeCode.Double    : return ToSqlDouble((Double)   p);  				case TypeCode.Decimal   : return ToSqlDouble((Decimal)  p);  				case TypeCode.String    : return ToSqlDouble((String)   p);  				case TypeCode.Boolean   : return ToSqlDouble((Boolean)  p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull  : return SqlGuid.Null;  				case TypeCode.String  : return ToSqlGuid((String) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return SqlInt16.Null;  				case TypeCode.SByte    : return ToSqlInt16((SByte)   p);  				case TypeCode.Int16    : return ToSqlInt16((Int16)   p);  				case TypeCode.Byte     : return ToSqlInt16((Byte)    p);  				case TypeCode.Int32    : return ToSqlInt16((Int32)   p);  				case TypeCode.Int64    : return ToSqlInt16((Int64)   p);  				case TypeCode.UInt16   : return ToSqlInt16((UInt16)  p);  				case TypeCode.UInt32   : return ToSqlInt16((UInt32)  p);  				case TypeCode.UInt64   : return ToSqlInt16((UInt64)  p);  				case TypeCode.Single   : return ToSqlInt16((Single)  p);  				case TypeCode.Double   : return ToSqlInt16((Double)  p);  				case TypeCode.Decimal  : return ToSqlInt16((Decimal) p);  				case TypeCode.Char     : return ToSqlInt16((Char)    p);  				case TypeCode.String   : return ToSqlInt16((String)  p);  				case TypeCode.Boolean  : return ToSqlInt16((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return SqlInt32.Null;  				case TypeCode.SByte    : return ToSqlInt32((SByte)   p);  				case TypeCode.Int16    : return ToSqlInt32((Int16)   p);  				case TypeCode.Int32    : return ToSqlInt32((Int32)   p);  				case TypeCode.Byte     : return ToSqlInt32((Byte)    p);  				case TypeCode.UInt16   : return ToSqlInt32((UInt16)  p);  				case TypeCode.Char     : return ToSqlInt32((Char)    p);  				case TypeCode.Int64    : return ToSqlInt32((Int64)   p);  				case TypeCode.UInt32   : return ToSqlInt32((UInt32)  p);  				case TypeCode.UInt64   : return ToSqlInt32((UInt64)  p);  				case TypeCode.Single   : return ToSqlInt32((Single)  p);  				case TypeCode.Double   : return ToSqlInt32((Double)  p);  				case TypeCode.Decimal  : return ToSqlInt32((Decimal) p);  				case TypeCode.String   : return ToSqlInt32((String)  p);  				case TypeCode.Boolean  : return ToSqlInt32((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return SqlInt64.Null;  				case TypeCode.DateTime : return ToSqlInt64((DateTime)p);  				case TypeCode.SByte    : return ToSqlInt64((SByte)   p);  				case TypeCode.Int16    : return ToSqlInt64((Int16)   p);  				case TypeCode.Int32    : return ToSqlInt64((Int32)   p);  				case TypeCode.Int64    : return ToSqlInt64((Int64)   p);  				case TypeCode.Byte     : return ToSqlInt64((Byte)    p);  				case TypeCode.UInt16   : return ToSqlInt64((UInt16)  p);  				case TypeCode.UInt32   : return ToSqlInt64((UInt32)  p);  				case TypeCode.Char     : return ToSqlInt64((Char)    p);  				case TypeCode.UInt64   : return ToSqlInt64((UInt64)  p);  				case TypeCode.Single   : return ToSqlInt64((Single)  p);  				case TypeCode.Double   : return ToSqlInt64((Double)  p);  				case TypeCode.Decimal  : return ToSqlInt64((Decimal) p);  				case TypeCode.String   : return ToSqlInt64((String)  p);  				case TypeCode.Boolean  : return ToSqlInt64((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlMoney,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return SqlMoney.Null;  				case TypeCode.SByte    : return ToSqlMoney((SByte)   p);  				case TypeCode.Int16    : return ToSqlMoney((Int16)   p);  				case TypeCode.Int32    : return ToSqlMoney((Int32)   p);  				case TypeCode.Int64    : return ToSqlMoney((Int64)   p);  				case TypeCode.Byte     : return ToSqlMoney((Byte)    p);  				case TypeCode.UInt16   : return ToSqlMoney((UInt16)  p);  				case TypeCode.UInt32   : return ToSqlMoney((UInt32)  p);  				case TypeCode.Char     : return ToSqlMoney((Char)    p);  				case TypeCode.UInt64   : return ToSqlMoney((UInt64)  p);  				case TypeCode.Decimal  : return ToSqlMoney((Decimal) p);  				case TypeCode.Single   : return ToSqlMoney((Single)  p);  				case TypeCode.Double   : return ToSqlMoney((Double)  p);  				case TypeCode.String   : return ToSqlMoney((String)  p);  				case TypeCode.Boolean  : return ToSqlMoney((Boolean) p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull    : return SqlSingle.Null;  				case TypeCode.SByte     : return ToSqlSingle((SByte)    p);  				case TypeCode.Int16     : return ToSqlSingle((Int16)    p);  				case TypeCode.Int32     : return ToSqlSingle((Int32)    p);  				case TypeCode.Int64     : return ToSqlSingle((Int64)    p);  				case TypeCode.Byte      : return ToSqlSingle((Byte)     p);  				case TypeCode.UInt16    : return ToSqlSingle((UInt16)   p);  				case TypeCode.UInt32    : return ToSqlSingle((UInt32)   p);  				case TypeCode.Char      : return ToSqlSingle((Char)     p);  				case TypeCode.UInt64    : return ToSqlSingle((UInt64)   p);  				case TypeCode.Single    : return ToSqlSingle((Single)   p);  				case TypeCode.Double    : return ToSqlSingle((Double)   p);  				case TypeCode.Decimal   : return ToSqlSingle((Decimal)  p);  				case TypeCode.String    : return ToSqlSingle((String)   p);  				case TypeCode.Boolean   : return ToSqlSingle((Boolean)  p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlString,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull    : return SqlString.Null;  				case TypeCode.SByte     : return ToSqlString((SByte)    p);  				case TypeCode.Int16     : return ToSqlString((Int16)    p);  				case TypeCode.Int32     : return ToSqlString((Int32)    p);  				case TypeCode.Int64     : return ToSqlString((Int64)    p);  				case TypeCode.Byte      : return ToSqlString((Byte)     p);  				case TypeCode.UInt16    : return ToSqlString((UInt16)   p);  				case TypeCode.UInt32    : return ToSqlString((UInt32)   p);  				case TypeCode.UInt64    : return ToSqlString((UInt64)   p);  				case TypeCode.Single    : return ToSqlString((Single)   p);  				case TypeCode.Double    : return ToSqlString((Double)   p);  				case TypeCode.Boolean   : return ToSqlString((Boolean)  p);  				case TypeCode.Decimal   : return ToSqlString((Decimal)  p);  				case TypeCode.Char      : return ToSqlString((Char)     p);  				case TypeCode.DateTime  : return ToSqlString((DateTime) p);  				case TypeCode.String    : return ToSqlString((String)   p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlXml,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull : return SqlXml.Null;  				case TypeCode.String : return ToSqlXml((String)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByteArray,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull   : return null;  				case TypeCode.Decimal  : return ToByteArray((Decimal) p);  				case TypeCode.String   : return ToByteArray((String)  p);  				case TypeCode.Byte     : return ToByteArray((Byte)    p);  				case TypeCode.SByte    : return ToByteArray((SByte)   p);  #if !SILVERLIGHT  				case TypeCode.DateTime : return ToByteArray((DateTime)p);  #endif  				case TypeCode.Int16    : return ToByteArray((Int16)   p);  				case TypeCode.Int32    : return ToByteArray((Int32)   p);  				case TypeCode.Int64    : return ToByteArray((Int64)   p);  				case TypeCode.UInt16   : return ToByteArray((UInt16)  p);  				case TypeCode.UInt32   : return ToByteArray((UInt32)  p);  				case TypeCode.UInt64   : return ToByteArray((UInt64)  p);  				case TypeCode.Single   : return ToByteArray((Single)  p);  				case TypeCode.Double   : return ToByteArray((Double)  p);  				case TypeCode.Boolean  : return ToByteArray((Boolean) p);  				case TypeCode.Char     : return ToByteArray((Char)    p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.DBNull : return null;  				case TypeCode.String : return ToType((String)p);  			}
Missing Default,BLToolkit.Common,Convert,C:\repos\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,The following switch statement is missing a default case: switch (p)  			{  				case '\x0' : // Allow int <=> Char <=> Boolean  				case   '0' :  				case   'n' :  				case   'N' :  				case   'f' :  				case   'F' : return false;    				case '\x1' : // Allow int <=> Char <=> Boolean  				case   '1' :  				case   'y' :  				case   'Y' :  				case   't' :  				case   'T' : return true;  			}
Missing Default,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,MapOutputParameters,The following switch statement is missing a default case: switch (parameter.Direction)  				{  					case ParameterDirection.InputOutput:  					case ParameterDirection.Output:  						ordinal = dest.GetOrdinal(  							_dataProvider.Convert(parameter.ParameterName' ConvertType.SprocParameterToName).ToString());  						break;    					case ParameterDirection.ReturnValue:    						if (returnValueMember != null)  						{  							if (!returnValueMember.StartsWith("@") && dest is ObjectMapper)  							{  								var om = (ObjectMapper) dest;  								var ma = om.TypeAccessor[returnValueMember];    								if (ma != null)  								{  									ma.SetValue(obj' _mappingSchema.ConvertChangeType(parameter.Value' ma.Type));  									continue;  								}  							}  							else  								returnValueMember = returnValueMember.Substring(1);    							ordinal = dest.GetOrdinal(returnValueMember);  						}    						break;  				}
Missing Default,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommand,The following switch statement is missing a default case: switch (commandAction)  			{  				case CommandAction.Select: _selectCommand = command; break;  				case CommandAction.Insert: _insertCommand = command; break;  				case CommandAction.Update: _updateCommand = command; break;  				case CommandAction.Delete: _deleteCommand = command; break;  			}
Missing Default,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommandParameters,The following switch statement is missing a default case: switch (commandAction)  			{  				case CommandAction.Select: _selectCommandParameters = commandParameters; break;  				case CommandAction.Insert: _insertCommandParameters = commandParameters; break;  				case CommandAction.Update: _updateCommandParameters = commandParameters; break;  				case CommandAction.Delete: _deleteCommandParameters = commandParameters; break;  			}
Missing Default,BLToolkit.Data,DbManager,C:\repos\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,InitParameters,The following switch statement is missing a default case: switch (p.DbType)  					{  						case DbType.AnsiString:  						case DbType.Binary:  						case DbType.Object:  						case DbType.String:  						case DbType.VarNumeric:  						case DbType.AnsiStringFixedLength:  						case DbType.StringFixedLength:  						case DbType.DateTime:  						case DbType.DateTime2:  						case DbType.DateTimeOffset:  						case DbType.Date:  							if (p.Size == 0)  							{  								p.Size = 1;  								prepare = true;  							}  							break;  						case DbType.Decimal:  							if (p.Precision == 0 && p.Scale == 0)  								p.Precision = 1;  							break;  					}
Missing Default,BLToolkit.Data.DataProvider,FirebirdMappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\FirebirdMappingSchema.cs,ConvertToBoolean,The following switch statement is missing a default case: switch (value[0])  				{  					case '1': case 'T' :case 'Y' : case 't': case 'y': return true;  					case '0': case 'F' :case 'N' : case 'f': case 'n': return false;  				}
Missing Default,BLToolkit.Data.DataProvider,AccessDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.ExceptionToErrorNumber:  					if (value is OleDbException)  					{  						var ex = (OleDbException)value;  						if (ex.Errors.Count > 0)  							return ex.Errors[0].NativeError;  					}    					break;  			}
Missing Default,BLToolkit.Data.DataProvider,OdbcDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OdbcDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.ExceptionToErrorNumber:  					if (value is OdbcException)  					{  						var ex = (OdbcException)value;  						if (ex.Errors.Count > 0)  							return ex.Errors[0].NativeError;  					}  					break;  			}
Missing Default,BLToolkit.Data.DataProvider,OleDbDataProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\OleDbDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;    				case ConvertType.ExceptionToErrorNumber:  					if (value is OleDbException)  					{  						var ex = (OleDbException)value;  						if (ex.Errors.Count > 0)  							return ex.Errors[0].NativeError;  					}    					break;  			}
Missing Default,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.ExceptionToErrorNumber:  					if (value is SqlException)  						return ((SqlException)value).Number;  					break;  			}
Missing Default,BLToolkit.Data.DataProvider,SqlDataProviderBase,C:\repos\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following switch statement is missing a default case: switch (number)  			{  				case 1205: return DataExceptionType.Deadlock;  				case   -2: return DataExceptionType.Timeout;  				case  547: return DataExceptionType.ForeignKeyViolation;  				case 2601: return DataExceptionType.UniqueIndexViolation;  				case 2627: return DataExceptionType.ConstraintViolation;  			}
Missing Default,BLToolkit.Data.Linq.Builder,UnionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  					{  						case ConvertFlags.All   :  						case ConvertFlags.Key   :    							if (expression == null)  							{  								return _members.Values  									.Select(m => ConvertToSql(m.MemberExpression' 0' ConvertFlags.Field)[0])  									.ToArray();  							}    							break;    						case ConvertFlags.Field :    							if (expression != null && (level == 0 || level == 1) && expression.NodeType == ExpressionType.MemberAccess)  							{  								var levelExpression = expression.GetLevelExpression(1);    								if (expression == levelExpression)  								{  									var ma     = (MemberExpression)expression;  									var member = _members[ma.Member];    									if (member.SqlQueryInfo == null)  									{  										member.SqlQueryInfo = new SqlInfo(member.MemberExpression.Member)  										{  											Index = -2'  											Sql   = SubQuery.SqlQuery.Select.Columns[member.SequenceInfo.Index]'  											Query = SqlQuery'  										};  									}    									return new[] { member.SqlQueryInfo };  								}  							}    							break;  					}
Missing Default,BLToolkit.Data.Linq.Builder,ContainsContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ContainsBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  					{  						case RequestFor.Expression :  						case RequestFor.Field      : return IsExpressionResult.False;  					}
Missing Default,BLToolkit.Data.Linq.Builder,AllAnyContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AllAnyBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  					{  						case RequestFor.Expression :  						case RequestFor.Field      : return IsExpressionResult.False;  					}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,The following switch statement is missing a default case: switch (expr.NodeType)  						{  							case ExpressionType.Add                :  							case ExpressionType.AddChecked         : _exprBuilder.Append(" + ");  break;  							case ExpressionType.And                : _exprBuilder.Append(" & ");  break;  							case ExpressionType.AndAlso            : _exprBuilder.Append(" && "); break;  #if FW4 || SILVERLIGHT  							case ExpressionType.Assign             : _exprBuilder.Append(" = ");  break;  #endif  							case ExpressionType.Coalesce           : _exprBuilder.Append(" ?? "); break;  							case ExpressionType.Divide             : _exprBuilder.Append(" / ");  break;  							case ExpressionType.Equal              : _exprBuilder.Append(" == "); break;  							case ExpressionType.ExclusiveOr        : _exprBuilder.Append(" ^ ");  break;  							case ExpressionType.GreaterThan        : _exprBuilder.Append(" > ");  break;  							case ExpressionType.GreaterThanOrEqual : _exprBuilder.Append(" >= "); break;  							case ExpressionType.LeftShift          : _exprBuilder.Append(" << "); break;  							case ExpressionType.LessThan           : _exprBuilder.Append(" < ");  break;  							case ExpressionType.LessThanOrEqual    : _exprBuilder.Append(" <= "); break;  							case ExpressionType.Modulo             : _exprBuilder.Append(" % ");  break;  							case ExpressionType.Multiply           :  							case ExpressionType.MultiplyChecked    : _exprBuilder.Append(" * ");  break;  							case ExpressionType.NotEqual           : _exprBuilder.Append(" != "); break;  							case ExpressionType.Or                 : _exprBuilder.Append(" | ");  break;  							case ExpressionType.OrElse             : _exprBuilder.Append(" || "); break;  							case ExpressionType.Power              : _exprBuilder.Append(" ** "); break;  							case ExpressionType.RightShift         : _exprBuilder.Append(" >> "); break;  							case ExpressionType.Subtract           :  							case ExpressionType.SubtractChecked    : _exprBuilder.Append(" - ");  break;  						}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitMembers,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Call :  					{  						var ex = (MethodCallExpression)expr;  						_usedMembers.Add(ex.Method);    						if (ex.Method.IsGenericMethod)  						{  							var gmd = ex.Method.GetGenericMethodDefinition();    							if (gmd != ex.Method)  								_usedMembers.Add(gmd);    							var ga = ex.Method.GetGenericArguments();    							foreach (var type in ga)  								_usedMembers.Add(type);  						}    						break;  					}    				case ExpressionType.MemberAccess :  					{  						var ex = (MemberExpression)expr;  						_usedMembers.Add(ex.Member);  						break;  					}    				case ExpressionType.MemberInit :  					{  						var ex = (MemberInitExpression)expr;    						Action<IEnumerable<MemberBinding>> visit = null; visit = bs =>  						{  							foreach (var b in bs)  							{  								_usedMembers.Add(b.Member);    								switch (b.BindingType)  								{  									case MemberBindingType.MemberBinding :  										visit(((MemberMemberBinding)b).Bindings);  										break;  								}}  						};    						visit(ex.Bindings);  						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitMembers,The following switch statement is missing a default case: switch (b.BindingType)  								{  									case MemberBindingType.MemberBinding :  										visit(((MemberMemberBinding)b).Bindings);  										break;  								}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitTypes,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Call :  					{  						var ex = (MethodCallExpression)expr;  						var mi = ex.Method;    						AddType(mi.DeclaringType);  						AddType(mi.ReturnType);    						foreach (var arg in mi.GetGenericArguments())  							AddType(arg);    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,UpdateBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Arguments.Count)  			{  				case 1 : // int Update<T>(this IUpdateable<T> source)  					CheckAssociation(sequence);  					break;    				case 2 : // int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)  					{  						CheckAssociation(sequence);    						BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Update.Items'  							sequence);  						break;  					}    				case 3 :  					{  						var expr = methodCall.Arguments[1].Unwrap();    						if (expr is LambdaExpression)  						{  							// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  							//  							sequence = builder.BuildWhere(buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments[1].Unwrap()' false);    							CheckAssociation(sequence);    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								sequence'  								sequence.SqlQuery.Update.Items'  								sequence);  						}  						else  						{  							// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  							//  							var into = builder.BuildSequence(new BuildInfo(buildInfo' expr' new SqlQuery()));    							sequence.ConvertToIndex(null' 0' ConvertFlags.All);  							sequence.SqlQuery.ResolveWeakJoins(new List<ISqlTableSource>());  							sequence.SqlQuery.Select.Columns.Clear();    							BuildSetter(  								builder'  								buildInfo'  								(LambdaExpression)methodCall.Arguments[2].Unwrap()'  								into'  								sequence.SqlQuery.Update.Items'  								sequence);    							var sql = sequence.SqlQuery;    							sql.Select.Columns.Clear();    							foreach (var item in sql.Update.Items)  								sql.Select.Columns.Add(new SqlQuery.Column(sql' item.Expression));    							sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  						}    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,InsertBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Arguments.Count)  			{  				case 1 :   					// static int Insert<T>              (this IValueInsertable<T> source)  					// static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)  					{  						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Expr(item.Expression);  						break;  					}    				case 2 : // static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)  					{  						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[1].Unwrap()'  							sequence'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Insert.Into  = ((TableBuilder.TableContext)sequence).SqlTable;  						sequence.SqlQuery.From.Tables.Clear();    						break;  					}    				case 3 : // static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  					{  						var into = builder.BuildSequence(new BuildInfo(buildInfo' methodCall.Arguments[1]' new SqlQuery()));    						UpdateBuilder.BuildSetter(  							builder'  							buildInfo'  							(LambdaExpression)methodCall.Arguments[2].Unwrap()'  							into'  							sequence.SqlQuery.Insert.Items'  							sequence);    						sequence.SqlQuery.Select.Columns.Clear();    						foreach (var item in sequence.SqlQuery.Insert.Items)  							sequence.SqlQuery.Select.Columns.Add(new SqlQuery.Column(sequence.SqlQuery' item.Expression));    						sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,TableAttributeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableAttributeBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Method.Name)  			{  				case "TableName"    : table.SqlTable.PhysicalName = value; break;  				case "DatabaseName" : table.SqlTable.Database     = value; break;  				case "OwnerName"    : table.SqlTable.Owner        = value; break;  			}
Missing Default,BLToolkit.Data.Linq.Builder,AggregationContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.All   :  					case ConvertFlags.Key   :  					case ConvertFlags.Field : return Sequence.ConvertToSql(expression' level + 1' flags);  				}
Missing Default,BLToolkit.Data.Linq.Builder,AggregationContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,ConvertToIndex,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  						return _index ?? (_index = new[]  						{  							new SqlInfo { Query = Parent.SqlQuery' Index = Parent.SqlQuery.Select.Add(Sql)' Sql = Sql' }  						});  				}
Missing Default,BLToolkit.Data.Linq.Builder,AggregationContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  				{  					case RequestFor.Root       : return new IsExpressionResult(Lambda != null && expression == Lambda.Parameters[0]);  					case RequestFor.Expression : return IsExpressionResult.True;  				}
Missing Default,BLToolkit.Data.Linq.Builder,CountContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field : return new[] { new SqlInfo { Query = Parent.SqlQuery' Sql = Sql } };  				}
Missing Default,BLToolkit.Data.Linq.Builder,CountContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,ConvertToIndex,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  						return _index ?? (_index = new[]  						{  							new SqlInfo { Query = Parent.SqlQuery' Index = Parent.SqlQuery.Select.Add(Sql)' Sql = Sql' }  						});  				}
Missing Default,BLToolkit.Data.Linq.Builder,CountContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  				{  					case RequestFor.Expression : return IsExpressionResult.True;  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertParameters,The following switch statement is missing a default case: switch (expr.NodeType)  				{  					case ExpressionType.Parameter:  						if (CompiledParameters != null)  						{  							var idx = Array.IndexOf(CompiledParameters' (ParameterExpression)expr);    							if (idx > 0)  								return  									Expression.Convert(  										Expression.ArrayIndex(  											ParametersParam'  											Expression.Constant(Array.IndexOf(CompiledParameters' (ParameterExpression)expr)))'  										expr.Type);  						}    						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ExposeExpression,The following switch statement is missing a default case: switch (expr.NodeType)  				{  					case ExpressionType.MemberAccess:  						{  							var me = (MemberExpression)expr;  							var l  = ConvertMethodExpression(me.Member);    							if (l != null)  							{  								var body = l.Body.Unwrap();  								var ex   = body.Convert2(wpi => new ExpressionHelper.ConvertInfo(wpi.NodeType == ExpressionType.Parameter ? me.Expression : wpi));    								if (ex.Type != expr.Type)  									ex = new ChangeTypeExpression(ex' expr.Type);    								return ExposeExpression(ex);  							}    							break;  						}    					case ExpressionType.Constant :  						{  							var c = (ConstantExpression)expr;    							// Fix Mono behaviour.  							//  							//if (c.Value is IExpressionQuery)  							//	return ((IQueryable)c.Value).Expression;    							if (c.Value is IQueryable && !(c.Value is ITable))  							{  								var e = ((IQueryable)c.Value).Expression;    								if (!_visitedExpressions.Contains(e))  								{  									_visitedExpressions.Add(e);  									return ExposeExpression(e);  								}  							}    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.MemberAccess:  					{  						var me = (MemberExpression)expr;    						// Replace Count with Count()  						//  						if (me.Member.Name == "Count")  						{  							var isList = typeof(ICollection).IsAssignableFrom(me.Member.DeclaringType);    							if (!isList)  								isList = me.Member.DeclaringType.GetInterfaces()  									.Any(t => t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IList<>));    							if (isList)  							{  								var mi = EnumerableMethods  									.First(m => m.Name == "Count" && m.GetParameters().Length == 1)  									.MakeGenericMethod(TypeHelper.GetElementType(me.Expression.Type));    								return Expression.Call(null' mi' me.Expression);  							}  						}    						if (CompiledParameters == null && TypeHelper.IsSameOrParent(typeof(IQueryable)' expr.Type))  						{  							var ex = ConvertIQueriable(expr);    							if (ex != expr)  								return ConvertExpressionTree(ex);  						}    						return ConvertSubquery(expr);  					}    				case ExpressionType.Call :  					{  						var call = (MethodCallExpression)expr;    						if (call.IsQueryable())  						{  							switch (call.Method.Name)  							{  								case "Where"              : return ConvertWhere     (call);  								case "GroupBy"            : return ConvertGroupBy   (call);  								case "SelectMany"         : return ConvertSelectMany(call);  								case "Select"             : return ConvertSelect    (call);  								case "LongCount"          :  								case "Count"              :  								case "Single"             :  								case "SingleOrDefault"    :  								case "First"              :  								case "FirstOrDefault"     : return ConvertPredicate (call);  								case "Min"                :  								case "Max"                : return ConvertSelector  (call' true);  								case "Sum"                :  								case "Average"            : return ConvertSelector  (call' false);  								case "ElementAt"          :  								case "ElementAtOrDefault" : return ConvertElementAt (call);  							}  						}  						else  						{  							var l = ConvertMethodExpression(call.Method);    							if (l != null)  								return OptimizeExpression(ConvertMethod(call' l));    							if (CompiledParameters == null && TypeHelper.IsSameOrParent(typeof(IQueryable)' expr.Type))  							{  								var attr = GetTableFunctionAttribute(call.Method);    								if (attr == null)  								{  									var ex = ConvertIQueriable(expr);    									if (ex != expr)  										return ConvertExpressionTree(ex);  								}  							}  						}    						return ConvertSubquery(expr);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The following switch statement is missing a default case: switch (call.Method.Name)  							{  								case "Where"              : return ConvertWhere     (call);  								case "GroupBy"            : return ConvertGroupBy   (call);  								case "SelectMany"         : return ConvertSelectMany(call);  								case "Select"             : return ConvertSelect    (call);  								case "LongCount"          :  								case "Count"              :  								case "Single"             :  								case "SingleOrDefault"    :  								case "First"              :  								case "FirstOrDefault"     : return ConvertPredicate (call);  								case "Min"                :  								case "Max"                : return ConvertSelector  (call' true);  								case "Sum"                :  								case "Average"            : return ConvertSelector  (call' false);  								case "ElementAt"          :  								case "ElementAtOrDefault" : return ConvertElementAt (call);  							}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSubquery,The following switch statement is missing a default case: switch (call.Method.Name)  								{  									case "Single"          :  									case "SingleOrDefault" :  									case "First"           :  									case "FirstOrDefault"  :  										return ConvertSingleOrFirst(expr' call);  								}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetPredicate,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.MemberAccess:  					var li = Expression.Lambda<Func<object>>(((MemberExpression) expr)).Compile().DynamicInvoke();  					return GetPredicate((System.Linq.Expressions.Expression) li);  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (ex.NodeType)  			{  				case ExpressionType.Convert        :  				case ExpressionType.ConvertChecked :  				case ExpressionType.MemberInit     :  				case ExpressionType.New            :  				case ExpressionType.NewArrayBounds :  				case ExpressionType.NewArrayInit   :  				case ExpressionType.Parameter      : return false;  				case ExpressionType.MemberAccess   :  					{  						var ma   = (MemberExpression)ex;  						var attr = GetFunctionAttribute(ma.Member);    						if (attr != null)  							return true;    						return false;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CheckSubQueryForWhere,The following switch statement is missing a default case: switch (expr.NodeType)  				{  					case ExpressionType.MemberAccess:  						{  							var ma = (MemberExpression)expr;    							if (TypeHelper.IsNullableValueMember(ma.Member) ||  							    TypeHelper.IsNullableHasValueMember(ma.Member))  								break;    							if (SqlProvider.ConvertMember(ma.Member) == null)  							{  								var ctx = GetContext(context' expr);    								if (ctx != null)  								{  									if (ctx.IsExpression(expr' 0' RequestFor.Expression).Result)  										makeSubQuery = true;  									stopWalking = true;  								}  							}    							isWhere = true;    							break;  						}    					case ExpressionType.Call:  						{  							var e = (MethodCallExpression)expr;    							if (e.Method.DeclaringType == typeof(Enumerable) && e.Method.Name != "Contains")  								return isHaving = true;    							isWhere = true;    							break;  						}    					case ExpressionType.Parameter:  						{  							var ctx = GetContext(context' expr);    							if (ctx != null)  							{  								if (ctx.IsExpression(expr' 0' RequestFor.Expression).Result)  									makeSubQuery = true;  								stopWalking = true;  							}    							isWhere = true;    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressions,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.New :  					{  						var expr = (NewExpression)expression;    // ReSharper disable ConditionIsAlwaysTrueOrFalse  // ReSharper disable HeuristicUnreachableCode  						if (expr.Members == null)  							return Array<SqlInfo>.Empty;  // ReSharper restore HeuristicUnreachableCode  // ReSharper restore ConditionIsAlwaysTrueOrFalse    						return expr.Arguments  							.Select((arg'i) =>  							{  								var mi = expr.Members[i];  								if (mi is MethodInfo)  									mi = TypeHelper.GetPropertyByMethod((MethodInfo)mi);    								return ConvertExpressions(context' arg' queryConvertFlag).Select(si => si.Clone(mi));  							})  							.SelectMany(si => si)  							.ToArray();  					}    				case ExpressionType.MemberInit :  					{  						var expr = (MemberInitExpression)expression;  						var dic  = TypeAccessor.GetAccessor(expr.Type)  							.Select((m'i) => new { m' i })  							.ToDictionary(_ => _.m.MemberInfo' _ => _.i);    						return expr.Bindings  							.Where  (b => b is MemberAssignment)  							.Cast<MemberAssignment>()  							.OrderBy(b => dic[b.Member])  							.Select (a =>  							{  								var mi = a.Member;  								if (mi is MethodInfo)  									mi = TypeHelper.GetPropertyByMethod((MethodInfo)mi);    								return ConvertExpressions(context' a.Expression' queryConvertFlag).Select(si => si.Clone(mi));  							})  							.SelectMany(si => si)  							.ToArray();  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (expression.NodeType)  						{  							case ExpressionType.Add             :  							case ExpressionType.AddChecked      : return Convert(context' new SqlBinaryExpression(t' l' "+"' r' Precedence.Additive));  							case ExpressionType.And             : return Convert(context' new SqlBinaryExpression(t' l' "&"' r' Precedence.Bitwise));  							case ExpressionType.Divide          : return Convert(context' new SqlBinaryExpression(t' l' "/"' r' Precedence.Multiplicative));  							case ExpressionType.ExclusiveOr     : return Convert(context' new SqlBinaryExpression(t' l' "^"' r' Precedence.Bitwise));  							case ExpressionType.Modulo          : return Convert(context' new SqlBinaryExpression(t' l' "%"' r' Precedence.Multiplicative));  							case ExpressionType.Multiply:  							case ExpressionType.MultiplyChecked : return Convert(context' new SqlBinaryExpression(t' l' "*"' r' Precedence.Multiplicative));  							case ExpressionType.Or              : return Convert(context' new SqlBinaryExpression(t' l' "|"' r' Precedence.Bitwise));  							case ExpressionType.Power           : return Convert(context' new SqlFunction(t' "Power"' l' r));  							case ExpressionType.Subtract        :  							case ExpressionType.SubtractChecked : return Convert(context' new SqlBinaryExpression(t' l' "-"' r' Precedence.Subtraction));  							case ExpressionType.Coalesce        :  								{  									if (r is SqlFunction)  									{  										var c = (SqlFunction)r;    										if (c.Name == "Coalesce")  										{  											var parms = new ISqlExpression[c.Parameters.Length + 1];    											parms[0] = l;  											c.Parameters.CopyTo(parms' 1);    											return Convert(context' new SqlFunction(t' "Coalesce"' parms));  										}  									}    									return Convert(context' new SqlFunction(t' "Coalesce"' l' r));  								}  						}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (expression.NodeType)  						{  							case ExpressionType.UnaryPlus     : return o;  							case ExpressionType.Negate        :  							case ExpressionType.NegateChecked :  								return Convert(context' new SqlBinaryExpression(t' new SqlValue(-1)' "*"' o' Precedence.Multiplicative));  						}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsServerSideOnly,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.MemberAccess:  					{  						var ex = (MemberExpression)expr;  						var l  = SqlProvider.ConvertMember(ex.Member);    						if (l != null)  							return IsServerSideOnly(l.Body.Unwrap());    						var attr = GetFunctionAttribute(ex.Member);  						return attr != null && attr.ServerSideOnly;  					}    				case ExpressionType.Call:  					{  						var e = (MethodCallExpression)expr;    						if (e.Method.DeclaringType == typeof(Enumerable))  						{  							if (CountBuilder.MethodNames.Concat(AggregationBuilder.MethodNames).Contains(e.Method.Name))  								return IsQueryMember(e.Arguments[0]);  						}  						else if (e.Method.DeclaringType == typeof(Queryable))  						{  							switch (e.Method.Name)  							{  								case "Any"      :  								case "All"      :  								case "Contains" : return true;  							}  						}  						else  						{  							var l = SqlProvider.ConvertMember(e.Method);    							if (l != null)  								return l.Body.Unwrap().Find(IsServerSideOnly) != null;    							var attr = GetFunctionAttribute(e.Method);  							return attr != null && attr.ServerSideOnly;  						}    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsServerSideOnly,The following switch statement is missing a default case: switch (e.Method.Name)  							{  								case "Any"      :  								case "All"      :  								case "Contains" : return true;  							}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsQueryMember,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Parameter    : return true;  				case ExpressionType.MemberAccess : return IsQueryMember(((MemberExpression)expr).Expression);  				case ExpressionType.Call         :  					{  						var call = (MethodCallExpression)expr;    						if (call.Method.DeclaringType == typeof(Queryable))  							return true;    						if (call.Method.DeclaringType == typeof(Enumerable) && call.Arguments.Count > 0)  							return IsQueryMember(call.Arguments[0]);    						return IsQueryMember(call.Object);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeConstant,The following switch statement is missing a default case: switch (ex.NodeType)  				{  					case ExpressionType.Constant     :  						{  							var c = (ConstantExpression)ex;    							if (c.Value == null || ExpressionHelper.IsConstant(ex.Type))  								return false;    							break;  						}    					case ExpressionType.MemberAccess :  						{  							var ma = (MemberExpression)ex;    							if (ExpressionHelper.IsConstant(ma.Member.DeclaringType) || TypeHelper.IsNullableValueMember(ma.Member))  								return false;    							break;  						}    					case ExpressionType.Call         :  						{  							var mc = (MethodCallExpression)ex;    							if (ExpressionHelper.IsConstant(mc.Method.DeclaringType) || mc.Method.DeclaringType == typeof(object))  								return false;    							var attr = GetFunctionAttribute(mc.Method);    							if (attr != null && !attr.ServerSideOnly)  								return false;    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeCompiled,The following switch statement is missing a default case: switch (ex.NodeType)  				{  					case ExpressionType.Parameter    :  						return ex != ParametersParam;    					case ExpressionType.MemberAccess :  						{  							var attr = GetFunctionAttribute(((MemberExpression)ex).Member);  							return attr != null && attr.ServerSideOnly;  						}    					case ExpressionType.Call         :  						{  							var attr = GetFunctionAttribute(((MethodCallExpression)ex).Method);  							return attr != null && attr.ServerSideOnly;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.Equal              :  				case ExpressionType.NotEqual           :  				case ExpressionType.GreaterThan        :  				case ExpressionType.GreaterThanOrEqual :  				case ExpressionType.LessThan           :  				case ExpressionType.LessThanOrEqual    :  					{  						var e = (BinaryExpression)expression;  						return ConvertCompare(context' expression.NodeType' e.Left' e.Right);  					}    				case ExpressionType.Call               :  					{  						var e = (MethodCallExpression)expression;    						ISqlPredicate predicate = null;    						if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  							return ConvertCompare(context' ExpressionType.Equal' e.Object' e.Arguments[0]);    						if (e.Method.DeclaringType == typeof(string))  						{  							switch (e.Method.Name)  							{  								case "Contains"   : predicate = ConvertLikePredicate(context' e' "%"' "%"); break;  								case "StartsWith" : predicate = ConvertLikePredicate(context' e' ""'  "%"); break;  								case "EndsWith"   : predicate = ConvertLikePredicate(context' e' "%"' "");  break;  							}  						}  						else if (e.Method.Name == "Contains")  						{  							if (e.Method.DeclaringType == typeof(Enumerable) ||  							    TypeHelper.IsSameOrParent(typeof(IList)' e.Method.DeclaringType) ||  							    TypeHelper.IsSameOrParent(typeof(ICollection<>)' e.Method.DeclaringType))  							{  								predicate = ConvertInPredicate(context' e);  							}  						}  						else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent(typeof(Dictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(Dictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[1]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Values")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  						else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent(typeof(IDictionary<'>)' e.Method.DeclaringType))  						{  							var args = TypeHelper.GetGenericArguments(e.Method.DeclaringType' typeof(IDictionary<'>));  							var minf = EnumerableMethods  								.First(m => m.Name == "Contains" && m.GetParameters().Length == 2)  								.MakeGenericMethod(args[0]);    							var expr = Expression.Call(  								minf'   								Expression.PropertyOrField(e.Object' "Keys")'  								e.Arguments[0]);    							predicate = ConvertInPredicate(context' expr);  						}  #if !SILVERLIGHT  						else if (e.Method == ReflectionHelper.Functions.String.Like11) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like12) predicate = ConvertLikePredicate(context' e);  #endif  						else if (e.Method == ReflectionHelper.Functions.String.Like21) predicate = ConvertLikePredicate(context' e);  						else if (e.Method == ReflectionHelper.Functions.String.Like22) predicate = ConvertLikePredicate(context' e);    						if (predicate != null)  							return Convert(context' predicate);    						break;  					}    				case ExpressionType.Conditional  :  					return Convert(context'  						new SqlQuery.Predicate.ExprExpr(  							ConvertToSql(context' expression' false)'  							SqlQuery.Predicate.Operator.Equal'  							new SqlValue(true)));    				case ExpressionType.MemberAccess :  					{  						var e = (MemberExpression)expression;    						if (e.Member.Name == "HasValue" &&   							e.Member.DeclaringType.IsGenericType &&   							e.Member.DeclaringType.GetGenericTypeDefinition() == typeof(Nullable<>))  						{  							var expr = ConvertToSql(context' e.Expression' false);  							return Convert(context' new SqlQuery.Predicate.IsNull(expr' true));  						}    						break;  					}    				case ExpressionType.TypeIs:  					{  						var e   = (TypeBinaryExpression)expression;  						var ctx = GetContext(context' e.Expression);    						if (ctx != null && ctx.IsExpression(e.Expression' 0' RequestFor.Table).Result)  							return MakeIsPredicate(ctx' e);    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following switch statement is missing a default case: switch (e.Method.Name)  							{  								case "Contains"   : predicate = ConvertLikePredicate(context' e' "%"' "%"); break;  								case "StartsWith" : predicate = ConvertLikePredicate(context' e' ""'  "%"); break;  								case "EndsWith"   : predicate = ConvertLikePredicate(context' e' "%"' "");  break;  							}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The following switch statement is missing a default case: switch (nodeType)  			{  				case ExpressionType.Equal    :  				case ExpressionType.NotEqual :    					var p = ConvertObjectComparison(nodeType' context' left' context' right);  					if (p != null)  						return p;    					p = ConvertObjectNullComparison(context' left' right' nodeType == ExpressionType.Equal);  					if (p != null)  						return p;    					p = ConvertObjectNullComparison(context' right' left' nodeType == ExpressionType.Equal);  					if (p != null)  						return p;    					if (left.NodeType == ExpressionType.New || right.NodeType == ExpressionType.New)  					{  						p = ConvertNewObjectComparison(context' nodeType' left' right);  						if (p != null)  							return p;  					}    					break;  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The following switch statement is missing a default case: switch (nodeType)  			{  				case ExpressionType.Equal   :  				case ExpressionType.NotEqual:    					if (!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull() || r is SqlParameter && r.CanBeNull()))  						context.SqlQuery.IsParameterDependent = true;    					// | (SqlQuery(Select([]) as q)' SqlValue(null))  					// | (SqlValue(null)' SqlQuery(Select([]) as q))  =>    					var q =  						l.ElementType == QueryElementType.SqlQuery &&  						r.ElementType == QueryElementType.SqlValue &&  						((SqlValue)r).Value == null &&  						((SqlQuery)l).Select.Columns.Count == 0 ?  							(SqlQuery)l :  						r.ElementType == QueryElementType.SqlQuery &&  						l.ElementType == QueryElementType.SqlValue &&  						((SqlValue)l).Value == null &&  						((SqlQuery)r).Select.Columns.Count == 0 ?  							(SqlQuery)r :  							null;    					if (q != null)  					{  						q.Select.Columns.Add(new SqlQuery.Column(q' new SqlValue(1)));  					}    					break;  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,The following switch statement is missing a default case: switch (value.NodeType)  			{  				case ExpressionType.Constant:  					{  						var enumValue = ((ConstantExpression)value).Value;  						if (enumValue == null)  							return null;    						var name = Enum.GetName(type' enumValue);    // ReSharper disable ConditionIsAlwaysTrueOrFalse  // ReSharper disable HeuristicUnreachableCode  						if (name == null)  							return null;  // ReSharper restore HeuristicUnreachableCode  // ReSharper restore ConditionIsAlwaysTrueOrFalse    						var origValue = Enum.Parse(type' name' false);  						var mapValue  = origValue;    						if (!(operand is MemberExpression))  						{  							if (!dic.TryGetValue(origValue' out mapValue))  								return null;  						}    						ISqlExpression l' r;    						SqlValue sqlValue;    						if (left.NodeType == ExpressionType.Convert)  						{  							l = ConvertToSql(context' operand' false);  							r = sqlValue = new SqlValue(mapValue);  						}  						else  						{  							r = ConvertToSql(context' operand' false);  							l = sqlValue = new SqlValue(mapValue);  						}    						if (operand is MemberExpression)  						{  							var me = (MemberExpression)operand;  							var memberAccessor = TypeAccessor.GetAccessor(me.Member.DeclaringType)[me.Member.Name];  							sqlValue.SetEnumConverter(memberAccessor' MappingSchema);  						}      						return Convert(context' new SqlQuery.Predicate.ExprExpr(l' op' r));  					}    				case ExpressionType.Convert:  					{  						value = ((UnaryExpression)value).Operand;    						var l = ConvertToSql(context' operand' false' false);  						var r = ConvertToSql(context' value'   false' false);    						MemberAccessor memberAccessor = null;    						if (operand is MemberExpression)  						{  							// is it even possible that operand is not MemberExpression?  							// if no' then we can remove this two last uses of SetEnumConverter(type' map)  							// and other depending code  							// At least currently there is no test coverage for this method and I didn't  							// manage to create such test  							var me = (MemberExpression)operand;  							memberAccessor = TypeAccessor.GetAccessor(me.Member.DeclaringType)[me.Member.Name];  						}    						if (l is SqlValueBase)  						{  							if (memberAccessor != null)  							{  								((SqlValueBase)l).SetEnumConverter(memberAccessor' MappingSchema);  							}  							else  							{  								((SqlValueBase)l).SetEnumConverter(type' MappingSchema);  							}  						}    						if (r is SqlValueBase)  						{  							if (memberAccessor != null)  							{  								((SqlValueBase)r).SetEnumConverter(memberAccessor' MappingSchema);  							}  							else  							{  								((SqlValueBase)r).SetEnumConverter(type' MappingSchema);  							}  						}    						return Convert(context' new SqlQuery.Predicate.ExprExpr(l' op' r));  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,FindExpression,The following switch statement is missing a default case: switch (pi.NodeType)  				{  					case ExpressionType.Convert      :  						{  							var e = (UnaryExpression)expr;    							return  								e.Operand.NodeType == ExpressionType.ArrayIndex &&  								((BinaryExpression)e.Operand).Left == ParametersParam;  						}    					case ExpressionType.MemberAccess :  					case ExpressionType.New          :  						return true;  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,EscapeLikeText,The following switch statement is missing a default case: switch (ch)  				{  					case '%':  					case '_':  					case '~':  						builder.Append('~');  						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeTranslatedToSql,The following switch statement is missing a default case: switch (pi.NodeType)  				{  					case ExpressionType.MemberAccess :  						{  							var ma   = (MemberExpression)pi;  							var attr = GetFunctionAttribute(ma.Member);    							if (attr == null && !TypeHelper.IsNullableValueMember(ma.Member))  							{  								if (canBeCompiled)  								{  									var ctx = GetContext(context' pi);    									if (ctx == null)  										return !CanBeCompiled(pi);    									if (ctx.IsExpression(pi' 0' RequestFor.Object).Result)  										return !CanBeCompiled(pi);    									ignoredMembers = ma.Expression.GetMembers();  								}  							}    							break;  						}    					case ExpressionType.Parameter    :  						{  							var ctx = GetContext(context' pi);    							if (ctx == null)  								if (canBeCompiled)  									return !CanBeCompiled(pi);    							break;  						}    					case ExpressionType.Call         :  						{  							var e = (MethodCallExpression)pi;    							if (e.Method.DeclaringType != typeof(Enumerable))  							{  								var attr = GetFunctionAttribute(e.Method);    								if (attr == null && canBeCompiled)  									return !CanBeCompiled(pi);  							}    							break;  						}    					case ExpressionType.TypeIs       : return canBeCompiled;  					case ExpressionType.TypeAs       :  					case ExpressionType.New          : return true;    					case ExpressionType.NotEqual     :  					case ExpressionType.Equal        :  						{  							var e = (BinaryExpression)pi;    							Expression obj = null;    							if (IsNullConstant(e.Left))  								obj = e.Right;  							else if (IsNullConstant(e.Right))  								obj = e.Left;    							if (obj != null)  							{  								var ctx = GetContext(context' obj);    								if (ctx != null)  								{  									if (ctx.IsExpression(obj' 0' RequestFor.Table).      Result ||  									    ctx.IsExpression(obj' 0' RequestFor.Association).Result)  									{  										ignoredMembers = obj.GetMembers();  									}  								}  							}    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildExpression,The following switch statement is missing a default case: switch (expr.NodeType)  				{  					case ExpressionType.MemberAccess:  						{  							if (IsServerSideOnly(expr) || PreferServerSide(expr))  								return new ExpressionHelper.ConvertInfo(BuildSql(context' expr));    							var ma = (MemberExpression)expr;    							if (SqlProvider.ConvertMember(ma.Member) != null)  								return new ExpressionHelper.ConvertInfo(BuildSql(context' expr)); //break;  							//var l = SqlProvider.ConvertMember(ma.Member);    							var ctx = GetContext(context' expr);    							if (ctx != null)  								return new ExpressionHelper.ConvertInfo(ctx.BuildExpression(expr' 0));    							var ex = ma.Expression;    							if (ex != null && ex.NodeType == ExpressionType.Constant)  							{  								// field = localVariable  								//  								var c = _expressionAccessors[ex];  								return new ExpressionHelper.ConvertInfo(  									Expression.MakeMemberAccess(Expression.Convert(c' ex.Type)' ma.Member));  							}    							break;  						}    					case ExpressionType.Parameter:  						{  							if (expr == ParametersParam)  								break;    							var ctx = GetContext(context' expr);    							if (ctx != null)  								return new ExpressionHelper.ConvertInfo(ctx.BuildExpression(expr' 0));    							break;  						}    					case ExpressionType.Constant:  						{  							if (ExpressionHelper.IsConstant(expr.Type))  								break;    							if (_expressionAccessors.ContainsKey(expr))  								return new ExpressionHelper.ConvertInfo(Expression.Convert(_expressionAccessors[expr]' expr.Type));    							break;  						}    					case ExpressionType.Coalesce:    						if (expr.Type == typeof(string) && MappingSchema.GetDefaultNullValue<string>() != null)  							return new ExpressionHelper.ConvertInfo(BuildSql(context' expr));    						if (CanBeTranslatedToSql(context' ConvertExpression(expr)' true))  							return new ExpressionHelper.ConvertInfo(BuildSql(context' expr));    						break;    					case ExpressionType.Conditional:    						if (CanBeTranslatedToSql(context' ConvertExpression(expr)' true))  							return new ExpressionHelper.ConvertInfo(BuildSql(context' expr));  						break;    					case ExpressionType.Call:  						{  							var ce = (MethodCallExpression)expr;    							if (IsGroupJoinSource(context' ce))  							{  								foreach (var arg in ce.Arguments.Skip(1))  									if (!_skippedExpressions.Contains(arg))  										_skippedExpressions.Add(arg);    								break;  							}    							if (IsSubQuery(context' ce))  							{  								if (TypeHelper.IsSameOrParent(typeof(IEnumerable)' expr.Type) && expr.Type != typeof(string) && !expr.Type.IsArray)  									return new ExpressionHelper.ConvertInfo(BuildMultipleQuery(context' expr));    								return new ExpressionHelper.ConvertInfo(GetSubQuery(context' ce).BuildExpression(null' 0));  							}    							if (IsServerSideOnly(expr) || PreferServerSide(expr))  								return new ExpressionHelper.ConvertInfo(BuildSql(context' expr));  						}    						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsNoneSqlMember,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.MemberAccess:  					{  						var me = (MemberExpression)expr;    						var om = (  							from c in Contexts.OfType<TableBuilder.TableContext>()  							where c.ObjectType == me.Member.DeclaringType  							select c.ObjectMapper  						).FirstOrDefault();    						return om != null && om.Associations.All(a => !TypeHelper.Equals(a.MemberAccessor.MemberInfo' me.Member)) && om[me.Member.Name' true] == null;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,PreferServerSide,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.MemberAccess:  					{  						var pi = (MemberExpression)expr;  						var l  = SqlProvider.ConvertMember(pi.Member);    						if (l != null)  						{  							var info = l.Body.Unwrap();    							if (l.Parameters.Count == 1 && pi.Expression != null)  								info = info.Convert(wpi => wpi == l.Parameters[0] ? pi.Expression : wpi);    							return info.Find(PreferServerSide) != null;  						}    						var attr = GetFunctionAttribute(pi.Member);  						return attr != null && attr.PreferServerSide && !CanBeCompiled(expr);  					}    				case ExpressionType.Call:  					{  						var pi = (MethodCallExpression)expr;  						var e  = pi;  						var l  = SqlProvider.ConvertMember(e.Method);    						if (l != null)  							return l.Body.Unwrap().Find(PreferServerSide) != null;    						var attr = GetFunctionAttribute(e.Method);  						return attr != null && attr.PreferServerSide && !CanBeCompiled(expr);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The following switch statement is missing a default case: switch (e.NodeType)  				{  					case ExpressionType.MemberAccess :  						{  							var root = e.GetRootObject();    							if (root != null &&  								root.NodeType == ExpressionType.Parameter &&  								!parameters.Contains((ParameterExpression)root))  							{  								var res = context.IsExpression(e' 0' RequestFor.Association);    								if (res.Result)  								{  									var table = (TableBuilder.AssociatedTableContext)res.Context;    									if (table.IsList)  									{  										var ttype  = typeof(Table<>).MakeGenericType(table.ObjectType);  										var tbl    = Activator.CreateInstance(ttype);  										var method = typeof(LinqExtensions)  											.GetMethod("Where"' BindingFlags.NonPublic | BindingFlags.Static)  											.MakeGenericMethod(e.Type' table.ObjectType' ttype);    										var me = (MemberExpression)e;  										var op = Expression.Parameter(table.ObjectType' "t");    										parameters.Add(op);    										Expression ex = null;    										for (var i = 0; i < table.Association.ThisKey.Length; i++)  										{  											var field1 = table.ParentAssociation.SqlTable.Fields[table.Association.ThisKey [i]];  											var field2 = table.                  SqlTable.Fields[table.Association.OtherKey[i]];    											var ee = Expression.Equal(  												Expression.MakeMemberAccess(op'            field2.MemberMapper.MemberAccessor.MemberInfo)'  												Expression.MakeMemberAccess(me.Expression' field1.MemberMapper.MemberAccessor.MemberInfo));    											ex = ex == null ? ee : Expression.AndAlso(ex' ee);  										}    										return Expression.Call(null' method' Expression.Constant(tbl)' Expression.Lambda(ex' op));  									}  								}  							}    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Method.Name)  				{  					case "First"           :  					case "FirstOrDefault"  :  						take = 1;  						break;    					case "Single"          :  					case "SingleOrDefault" :  						if (!buildInfo.IsSubQuery)  							take = 2;  						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,FirstSingleContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildQuery,The following switch statement is missing a default case: switch (_methodCall.Method.Name)  				{  					case "First"           : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).First();           break;  					case "FirstOrDefault"  : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).FirstOrDefault();  break;  					case "Single"          : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).Single();          break;  					case "SingleOrDefault" : query.GetElement = (ctx' db' expr' ps) => query.GetIEnumerable(ctx' db' expr' ps).SingleOrDefault(); break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,GroupByContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (expression.NodeType)  					{  						case ExpressionType.Call         :  							{  								var e = (MethodCallExpression)expression;    								if (e.Method.DeclaringType == typeof(Enumerable))  								{  									return new[] { new SqlInfo { Sql = ConvertEnumerable(e) } };  								}    								break;  							}    						case ExpressionType.MemberAccess :  							{  								var levelExpression = expression.GetLevelExpression(level);    								if (levelExpression.NodeType == ExpressionType.MemberAccess)  								{  									var e = (MemberExpression)levelExpression;    									if (e.Member.Name == "Key")  									{  										if (_keyProperty == null)  											_keyProperty = _groupingType.GetProperty("Key");    										if (e.Member == _keyProperty)  										{  											if (levelExpression == expression)  												return _key.ConvertToSql(null' 0' flags);    											return _key.ConvertToSql(expression' level + 1' flags);  										}  									}    									return Sequence.ConvertToSql(expression' level' flags);  								}    								break;  							}  					}
Missing Default,BLToolkit.Data.Linq.Builder,MethodCallBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.Parameter :    					if (info.ExpressionsToReplace != null)  						foreach (var item in info.ExpressionsToReplace)  							if (expression == item.Path || expression == param && item.Path.NodeType == ExpressionType.Parameter)  								return item.Expr;  					break;    				case ExpressionType.MemberAccess :    					if (info.ExpressionsToReplace != null)  					{  						foreach (var item in info.ExpressionsToReplace)  						{  							var ex1 = expression;  							var ex2 = item.Path;    							while (ex1.NodeType == ex2.NodeType)  							{  								if (ex1.NodeType == ExpressionType.Parameter)  									return ex1 == ex2 || info.Parameter == ex2? item.Expr : expression;    								if (ex2.NodeType != ExpressionType.MemberAccess)  									break;    								var ma1 = (MemberExpression)ex1;  								var ma2 = (MemberExpression)ex2;    								if (ma1.Member != ma2.Member)  									break;    								ex1 = ma1.Expression;  								ex2 = ma2.Expression;  							}  						}  					}    					break;  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  					case ConvertFlags.Key   :  					case ConvertFlags.All   :  						{  							var root = expression.GetRootObject();    							if (root.NodeType == ExpressionType.Parameter)  							{  								var ctx = Builder.GetContext(this' root);    								if (ctx != null)  								{  									if (ctx != this)  										return ctx.ConvertToSql(expression' 0' flags);    									return root == expression ?  										Sequence.ConvertToSql(null'       0'         flags) :  										Sequence.ConvertToSql(expression' level + 1' flags);  								}  							}    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  			{  				case RequestFor.Root        : return new IsExpressionResult(Lambda.Parameters.Count > 0 && expression == Lambda.Parameters[0]);    				case RequestFor.Table       :  				case RequestFor.Association :  				case RequestFor.Object      :  				case RequestFor.GroupJoin   :  				case RequestFor.Field       :  				case RequestFor.Expression  :  					{  						var levelExpression = expression.GetLevelExpression(level);    						return levelExpression == expression ?  							Sequence.IsExpression(null'       0'         requestFlag) :  							Sequence.IsExpression(expression' level + 1' requestFlag);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,GetContext,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.Constant   :  				case ExpressionType.New        :  				case ExpressionType.MemberInit : return null;  			}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (levelExpression.NodeType)  				{  					case ExpressionType.MemberAccess :  						{  							var memberExpression = GetMemberExpression(  								((MemberExpression)levelExpression).Member'  								levelExpression == expression'  								levelExpression.Type);    							if (levelExpression == expression)  							{  								if (IsSubQuery())  								{  									switch (memberExpression.NodeType)  									{  										case ExpressionType.New        :  										case ExpressionType.MemberInit :  											{  												return memberExpression.Convert(e =>  												{  													if (e != memberExpression)  													{  														switch (e.NodeType)  														{  															case ExpressionType.MemberAccess :  																var sequence = GetSequence(memberExpression' 0);    																if (sequence != null &&  																	!sequence.IsExpression(e' 0' RequestFor.Object).Result &&  																	!sequence.IsExpression(e' 0' RequestFor.Field). Result)  																{  																	var info = ConvertToIndex(e' 0' ConvertFlags.Field).Single();  																	var idx  = Parent == null ? info.Index : Parent.ConvertToParentIndex(info.Index' this);    																	return Builder.BuildSql(e.Type' idx);  																}    																return Builder.BuildExpression(this' e);  														}  													}    													return e;  												});  											}  									}    									var me = memberExpression.NodeType == ExpressionType.Parameter ? null : memberExpression;    									if (!IsExpression(me' 0' RequestFor.Object).Result &&  										!IsExpression(me' 0' RequestFor.Field). Result)  									{  										var info = ConvertToIndex(expression' level' ConvertFlags.Field).Single();  										var idx  = Parent == null ? info.Index : Parent.ConvertToParentIndex(info.Index' this);    										return Builder.BuildSql(expression.Type' idx);  									}  								}    								return Builder.BuildExpression(this' memberExpression);  							}    							{  								var sequence = GetSequence(expression' level);    								switch (memberExpression.NodeType)  								{  									case ExpressionType.Parameter  :  										{  											var parameter = Lambda.Parameters[Sequence.Length == 0 ? 0 : Array.IndexOf(Sequence' sequence)];  										  											if (memberExpression == parameter)  												return sequence.BuildExpression(expression' level + 1);    											break;  										  										}    									case ExpressionType.New        :  									case ExpressionType.MemberInit :  										{  											var mmExpresion = GetMemberExpression(memberExpression' expression' level + 1);  											return Builder.BuildExpression(this' mmExpresion);  										}  								}    								var expr = expression.Convert(ex => ex == levelExpression ? memberExpression : ex);    								return sequence.BuildExpression(expr' 1);  							}  						}    					case ExpressionType.Parameter :  						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType)  									{  										case ExpressionType.New        :  										case ExpressionType.MemberInit :  											{  												return memberExpression.Convert(e =>  												{  													if (e != memberExpression)  													{  														switch (e.NodeType)  														{  															case ExpressionType.MemberAccess :  																var sequence = GetSequence(memberExpression' 0);    																if (sequence != null &&  																	!sequence.IsExpression(e' 0' RequestFor.Object).Result &&  																	!sequence.IsExpression(e' 0' RequestFor.Field). Result)  																{  																	var info = ConvertToIndex(e' 0' ConvertFlags.Field).Single();  																	var idx  = Parent == null ? info.Index : Parent.ConvertToParentIndex(info.Index' this);    																	return Builder.BuildSql(e.Type' idx);  																}    																return Builder.BuildExpression(this' e);  														}  													}    													return e;  												});  											}  									}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (e.NodeType)  														{  															case ExpressionType.MemberAccess :  																var sequence = GetSequence(memberExpression' 0);    																if (sequence != null &&  																	!sequence.IsExpression(e' 0' RequestFor.Object).Result &&  																	!sequence.IsExpression(e' 0' RequestFor.Field). Result)  																{  																	var info = ConvertToIndex(e' 0' ConvertFlags.Field).Single();  																	var idx  = Parent == null ? info.Index : Parent.ConvertToParentIndex(info.Index' this);    																	return Builder.BuildSql(e.Type' idx);  																}    																return Builder.BuildExpression(this' e);  														}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType)  								{  									case ExpressionType.Parameter  :  										{  											var parameter = Lambda.Parameters[Sequence.Length == 0 ? 0 : Array.IndexOf(Sequence' sequence)];  										  											if (memberExpression == parameter)  												return sequence.BuildExpression(expression' level + 1);    											break;  										  										}    									case ExpressionType.New        :  									case ExpressionType.MemberInit :  										{  											var mmExpresion = GetMemberExpression(memberExpression' expression' level + 1);  											return Builder.BuildExpression(this' mmExpresion);  										}  								}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  					case ConvertFlags.Key   :  					case ConvertFlags.All   :  						{  							if (Body.NodeType != ExpressionType.Parameter && level == 0)  							{  								var levelExpression = expression.GetLevelExpression(level);    								if (levelExpression != expression)  									if (flags != ConvertFlags.Field && IsExpression(expression' level' RequestFor.Field).Result)  										flags = ConvertFlags.Field;  							}    							return ProcessScalar(  								expression'  								level'  								(ctx' ex' l) => ctx.ConvertToSql(ex' l' flags)'  								() => new[] { new SqlInfo { Sql = Builder.ConvertToSql(this' expression' false) } });  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  					case ConvertFlags.All   :  						return ProcessScalar(  							expression'  							level'  							(ctx' ex' l) => ctx.ConvertToIndex(ex' l' flags)'  							() => GetSequence(expression' level).ConvertToIndex(expression' level + 1' flags));  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags)  					{  						case ConvertFlags.Field : throw new InvalidOperationException();  						case ConvertFlags.Key   :  						case ConvertFlags.All   :  							{  								var p = Expression.Parameter(Body.Type' "p");  								var q =  									from m in Members.Keys  									where !(m is MethodInfo)  									select new  									{  										Sql    = ConvertToIndex(Expression.MakeMemberAccess(p' m)' 1' flags)'  										Member = m  									} into mm  									from m in mm.Sql.Select(s => s.Clone(mm.Member))  									select m;    								return q.ToArray();  							}  					}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.All   :  					case ConvertFlags.Key   :  					case ConvertFlags.Field :  						{  							if (level == 0)  							{  								var idx = Builder.ConvertExpressions(this' expression' flags);    								foreach (var info in idx)  									SetInfo(info);    								return idx;  							}    							var levelExpression = expression.GetLevelExpression(level);    							switch (levelExpression.NodeType)  							{  								case ExpressionType.MemberAccess :  									{  										if (levelExpression == expression)  										{  											var member = Tuple.Create(((MemberExpression)levelExpression).Member' flags);    											SqlInfo[] idx;    											if (!_memberIndex.TryGetValue(member' out idx))  											{  												idx = ConvertToSql(expression' level' flags);    												if (flags == ConvertFlags.Field && idx.Length != 1)  													throw new InvalidOperationException();    												foreach (var info in idx)  													SetInfo(info);    												_memberIndex.Add(member' idx);  											}    											return idx;  										}    										return ProcessMemberAccess(  											expression'  											(MemberExpression)levelExpression'  											level'  											(n' ctx' ex' l' _) => n == 0 ?  												GetSequence(expression' level).ConvertToIndex(expression' level + 1' flags) :  												ctx.ConvertToIndex(ex' l' flags));  									}    								case ExpressionType.Parameter:    									if (levelExpression != expression)  										return GetSequence(expression' level).ConvertToIndex(expression' level + 1' flags);  									break;  							}    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (levelExpression.NodeType)  							{  								case ExpressionType.MemberAccess :  									{  										if (levelExpression == expression)  										{  											var member = Tuple.Create(((MemberExpression)levelExpression).Member' flags);    											SqlInfo[] idx;    											if (!_memberIndex.TryGetValue(member' out idx))  											{  												idx = ConvertToSql(expression' level' flags);    												if (flags == ConvertFlags.Field && idx.Length != 1)  													throw new InvalidOperationException();    												foreach (var info in idx)  													SetInfo(info);    												_memberIndex.Add(member' idx);  											}    											return idx;  										}    										return ProcessMemberAccess(  											expression'  											(MemberExpression)levelExpression'  											level'  											(n' ctx' ex' l' _) => n == 0 ?  												GetSequence(expression' level).ConvertToIndex(expression' level + 1' flags) :  												ctx.ConvertToIndex(ex' l' flags));  									}    								case ExpressionType.Parameter:    									if (levelExpression != expression)  										return GetSequence(expression' level).ConvertToIndex(expression' level + 1' flags);  									break;  							}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  			{  				case RequestFor.SubQuery : return IsExpressionResult.False;  				case RequestFor.Root     :  					return new IsExpressionResult(Sequence.Length == 1 ?  						expression == Lambda.Parameters[0] :  						Lambda.Parameters.Any(p => p == expression));  			}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType)  											{  												case ExpressionType.New        :  												case ExpressionType.MemberInit :  													return new IsExpressionResult(requestFlag == RequestFor.Object);  											}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetContext,The following switch statement is missing a default case: switch (levelExpression.NodeType)  				{  					case ExpressionType.MemberAccess :  						{  							if (levelExpression == expression && Sequence.Length == 1 && !(Sequence[0] is GroupByBuilder.GroupByContext))  							{  								var memberExpression = GetMemberExpression(  									((MemberExpression)levelExpression).Member'  									levelExpression == expression'  									levelExpression.Type);    								//var sequence = GetSequence(memberExpression' 0);  								//return sequence.GetContext(memberExpression' 1' new BuildInfo(buildInfo' memberExpression));    								var ctx = GetContext(memberExpression' 0' new BuildInfo(this' memberExpression' buildInfo.SqlQuery));    								if (ctx != null)  								{  									return ctx;  								}  							}    							var context = ProcessMemberAccess(  								expression'  								(MemberExpression)levelExpression'  								level'  								(n'ctx'ex'l'_) => n == 0 ?  									null :  									ctx.GetContext(ex' l' buildInfo));    							if (context == null)  								throw new InvalidOperationException();    							return context;  						}    					case ExpressionType.Parameter    :  						{  							var sequence  = GetSequence(expression' level);  							var parameter = Lambda.Parameters[Sequence.Length == 0 ? 0 : Array.IndexOf(Sequence' sequence)];    							if (levelExpression == expression)  							{  								if (levelExpression == parameter)  									return sequence.GetContext(null' 0' buildInfo);  							}  							else if (level == 0)  								return sequence.GetContext(expression' 1' buildInfo);    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following switch statement is missing a default case: switch (memberExpression.NodeType)  			{  				case ExpressionType.MemberAccess :  				case ExpressionType.Parameter    :  					if (sequence != null)  						return action(2' sequence' newExpression' nextLevel' memberExpression);  					break;  					//throw new InvalidOperationException();    				case ExpressionType.New          :  				case ExpressionType.MemberInit   :  					{  						var mmExpresion = GetMemberExpression(memberExpression' expression' level + 1);  						return action(3' this' mmExpresion' 0' memberExpression);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetSequence,The following switch statement is missing a default case: switch (levelExpression.NodeType)  				{  					case ExpressionType.MemberAccess :  						{  							var memberExpression = Members[((MemberExpression)levelExpression).Member];    							root =  memberExpression.GetRootObject();    							if (root.NodeType != ExpressionType.Parameter)  								return null;    							break;  						}    					case ExpressionType.Parameter :  						{  							root = expression.GetRootObject();  							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetMemberExpression,The following switch statement is missing a default case: switch (newExpression.NodeType)  			{  				case ExpressionType.New:  					{  						var expr = (NewExpression)newExpression;    // ReSharper disable ConditionIsAlwaysTrueOrFalse  // ReSharper disable HeuristicUnreachableCode  						if (expr.Members == null)  							throw new LinqException("Invalid expression {0}"' expression);  // ReSharper restore HeuristicUnreachableCode  // ReSharper restore ConditionIsAlwaysTrueOrFalse    						for (var i = 0; i < expr.Members.Count; i++)  							if (me.Member == expr.Members[i])  								return levelExpresion == expression ?  									expr.Arguments[i].Unwrap() :  									GetMemberExpression(expr.Arguments[i].Unwrap()' expression' level + 1);    						throw new LinqException("Invalid expression {0}"' expression);  					}    				case ExpressionType.MemberInit:  					{  						var expr = (MemberInitExpression)newExpression;    						foreach (var binding in expr.Bindings.Cast<MemberAssignment>())  						{  							if (me.Member == binding.Member)  								return levelExpresion == expression ?  									binding.Expression.Unwrap() :  									GetMemberExpression(binding.Expression.Unwrap()' expression' level + 1);  						}    						throw new LinqException("Invalid expression {0}"' expression);  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,SelectBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,GetExpressions,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				// new { ... }  				//  				case ExpressionType.New        :  					{  						var expr = (NewExpression)expression;    						if (expr.Members != null) for (var i = 0; i < expr.Members.Count; i++)  						{  							var q = GetExpressions(param' Expression.MakeMemberAccess(path' expr.Members[i])' level + 1' expr.Arguments[i]);  							foreach (var e in q)  								yield return e;  						}    						break;  					}    				// new MyObject { ... }  				//  				case ExpressionType.MemberInit :  					{  						var expr = (MemberInitExpression)expression;  						var dic  = TypeAccessor.GetAccessor(expr.Type)  							.Select((m'i) => new { m' i })  							.ToDictionary(_ => _.m.MemberInfo.Name' _ => _.i);    						foreach (var binding in expr.Bindings.Cast<MemberAssignment>().OrderBy(b => dic[b.Member.Name]))  						{  							var q = GetExpressions(param' Expression.MakeMemberAccess(path' binding.Member)' level + 1' binding.Expression);  							foreach (var e in q)  								yield return e;  						}    						break;  					}    				// parameter  				//  				case ExpressionType.Parameter  :  					if (expression == param)  						yield return new SequenceConvertPath { Path = path' Expr = expression' Level = level };  					break;    				case ExpressionType.TypeAs     :  					yield return new SequenceConvertPath { Path = path' Expr = expression' Level = level };  					break;    				// Queriable method.  				//  				case ExpressionType.Call       :  					{  						var call = (MethodCallExpression)expression;    						if (call.IsQueryable())  							if (TypeHelper.IsSameOrParent(typeof(IEnumerable)' call.Type) ||  							    TypeHelper.IsSameOrParent(typeof(IQueryable)'  call.Type) ||  							    FirstSingleBuilder.MethodNames.Contains(call.Method.Name))  								yield return new SequenceConvertPath { Path = path' Expr = expression' Level = level };    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext2,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag)  				{  					case RequestFor.Expression :  					case RequestFor.Root       :  						if (expression == Lambda.Parameters[1])  							return IsExpressionResult.True;  						break;  				}
Missing Default,BLToolkit.Data.Linq.Builder,SubQueryContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SubQueryContext.cs,IsExpression,The following switch statement is missing a default case: switch (testFlag)  			{  				case RequestFor.SubQuery : return IsExpressionResult.True;  			}
Missing Default,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.Constant:  					{  						var c = (ConstantExpression)expression;  						if (c.Value is IQueryable)  							return action(1' null);    						break;  					}    				case ExpressionType.Call:  					{  						var mc = (MethodCallExpression)expression;    						if (mc.Method.Name == "GetTable")  							if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  								return action(2' null);    						var attr = builder.GetTableFunctionAttribute(mc.Method);    						if (attr != null)  							return action(5' null);    						break;  					}    				case ExpressionType.MemberAccess:    					if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Table<>))  						return action(3' null);    					// Looking for association.  					//  					if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  					{  						var ctx = builder.GetContext(buildInfo.Parent' expression);  						if (ctx != null)  							return action(4' ctx);  					}    					break;    				case ExpressionType.Parameter:  					{  						if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0)  						{  							var ctx = builder.GetContext(buildInfo.Parent' expression);  							if (ctx != null)  								return action(4' ctx);  						}    						break;  					}  			}
Missing Default,BLToolkit.Data.Linq.Builder,TableBuilder,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following switch statement is missing a default case: switch (n)  				{  					case 0 : return null;  					case 1 : return new TableContext(builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  					case 2 :  					case 3 : return new TableContext(builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments()[0]);  					case 4 : return ctx.GetContext(buildInfo.Expression' 0' buildInfo);  					case 5 : return new TableContext(builder' buildInfo);  				}
Missing Default,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.All   :  						{  							var table = FindTable(expression' level' false);    							if (table.Field == null)  								return table.Table.SqlTable.Fields.Values  									.Select(_ => new SqlInfo(_.MemberMapper.MemberAccessor.MemberInfo) { Sql = _ })  									.ToArray();    							break;  						}    					case ConvertFlags.Key   :  						{  							var table = FindTable(expression' level' false);    							if (table.Field == null)  							{  								var q =  									from f in table.Table.SqlTable.Fields.Values  									where f.IsPrimaryKey  									orderby f.PrimaryKeyOrder  									select new SqlInfo(f.MemberMapper.MemberAccessor.MemberInfo) { Sql = f };    								var key = q.ToArray();    								return key.Length != 0 ? key : ConvertToSql(expression' level' ConvertFlags.All);  							}    							break;  						}    					case ConvertFlags.Field :  						{  							var table = FindTable(expression' level' true);    							if (table.Field != null)  								return new[]  								{  									new SqlInfo(table.Field.MemberMapper.MemberAccessor.MemberInfo) { Sql = table.Field }  								};    							break;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,ConvertToIndex,The following switch statement is missing a default case: switch (flags)  				{  					case ConvertFlags.Field :  					case ConvertFlags.Key   :  					case ConvertFlags.All   :    						var info = ConvertToSql(expression' level' flags);    						for (var i = 0; i < info.Length; i++)  							info[i] = GetIndex(info[i]);    						return info;  				}
Missing Default,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (requestFor)  				{  					case RequestFor.Field      :  						{  							var table = FindTable(expression' level' false);  							return new IsExpressionResult(table != null && table.Field != null);  						}    					case RequestFor.Table       :  					case RequestFor.Object      :  						{  							var table   = FindTable(expression' level' false);  							var isTable =  								table       != null &&  								table.Field == null &&  								(expression == null || expression.GetLevelExpression(table.Level) == expression);    							return new IsExpressionResult(isTable' isTable ? table.Table : null);  						}    					case RequestFor.Expression :  						{  							if (expression == null)  								return IsExpressionResult.False;    							var levelExpression = expression.GetLevelExpression(level);    							switch (levelExpression.NodeType)  							{  								case ExpressionType.MemberAccess :  								case ExpressionType.Parameter    :  								case ExpressionType.Call         :    									var table = FindTable(expression' level' false);  									return new IsExpressionResult(table == null);  							}    							return IsExpressionResult.True;  						}    					case RequestFor.Association      :  						{  							if (ObjectMapper.Associations.Count > 0)  							{  								var table = FindTable(expression' level' false);  								var isat  =  									table       != null &&  									table.Table is AssociatedTableContext &&  									table.Field == null &&  									(expression == null || expression.GetLevelExpression(table.Level) == expression);    								return new IsExpressionResult(isat' isat ? table.Table : null);  							}    							return IsExpressionResult.False;  						}  				}
Missing Default,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (levelExpression.NodeType)  							{  								case ExpressionType.MemberAccess :  								case ExpressionType.Parameter    :  								case ExpressionType.Call         :    									var table = FindTable(expression' level' false);  									return new IsExpressionResult(table == null);  							}
Missing Default,BLToolkit.Data.Linq.Builder,TableContext,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,FindTable,The following switch statement is missing a default case: switch (levelExpression.NodeType)  				{  					case ExpressionType.MemberAccess :  					case ExpressionType.Parameter    :  						{  							var field = GetField(expression' level' throwException);    							if (field != null || (level == 0 && levelExpression == expression))  								return new TableLevel { Table = this' Field = field' Level = level };    							return GetAssociation(expression' level);  						}  				}
Missing Default,BLToolkit.Data.Linq,CompiledQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,CompileQuery,The following switch statement is missing a default case: switch (pi.NodeType)  				{  					case ExpressionType.Parameter :  						{  							var idx = query.Parameters.IndexOf((ParameterExpression)pi);    							if (idx >= 0)  								return Expression.Convert(Expression.ArrayIndex(ps' Expression.Constant(idx))' pi.Type);    							break;  						}    					case ExpressionType.Call :  						{  							var expr = (MethodCallExpression)pi;    							if (expr.IsQueryable())  							{  								var qtype  = TypeHelper.GetGenericType(  									TypeHelper.IsSameOrParent(typeof(IQueryable)' expr.Type) ?  										typeof(IQueryable<>) :  										typeof(IEnumerable<>)'  									expr.Type);    								var helper = (ITableHelper)Activator.CreateInstance(  									typeof(TableHelper<>).MakeGenericType(qtype == null ? expr.Type : qtype.GetGenericArguments()[0]));    								return helper.CallTable(query' expr' ps' qtype != null);  							}    							if (expr.Method.Name == "GetTable" && expr.Method.DeclaringType == typeof(Extensions))  								goto case ExpressionType.MemberAccess;  						}    						break;    					case ExpressionType.MemberAccess :  						if (pi.Type.IsGenericType && pi.Type.GetGenericTypeDefinition() == typeof(Table<>))  						{  							var helper = (ITableHelper)Activator  								.CreateInstance(typeof(TableHelper<>)  								.MakeGenericType(pi.Type.GetGenericArguments()[0]));  							return helper.CallTable(query' pi' ps' true);  						}    						break;  				}
Missing Default,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following switch statement is missing a default case: switch (part)  			{  				case DateParts.Year        : return date.Value.AddYears       ((int)number);  				case DateParts.Quarter     : return date.Value.AddMonths      ((int)number * 3);  				case DateParts.Month       : return date.Value.AddMonths      ((int)number);  				case DateParts.DayOfYear   : return date.Value.AddDays        (number.Value);  				case DateParts.Day         : return date.Value.AddDays        (number.Value);  				case DateParts.Week        : return date.Value.AddDays        (number.Value * 7);  				case DateParts.WeekDay     : return date.Value.AddDays        (number.Value);  				case DateParts.Hour        : return date.Value.AddHours       (number.Value);  				case DateParts.Minute      : return date.Value.AddMinutes     (number.Value);  				case DateParts.Second      : return date.Value.AddSeconds     (number.Value);  				case DateParts.Millisecond : return date.Value.AddMilliseconds(number.Value);  			}
Missing Default,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following switch statement is missing a default case: switch (part)  			{  				case DateParts.Year        : return date.Value.Year;  				case DateParts.Quarter     : return (date.Value.Month - 1) / 3 + 1;  				case DateParts.Month       : return date.Value.Month;  				case DateParts.DayOfYear   : return date.Value.DayOfYear;  				case DateParts.Day         : return date.Value.Day;  				case DateParts.Week        : return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear(date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  				case DateParts.WeekDay     : return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  				case DateParts.Hour        : return date.Value.Hour;  				case DateParts.Minute      : return date.Value.Minute;  				case DateParts.Second      : return date.Value.Second;  				case DateParts.Millisecond : return date.Value.Millisecond;  			}
Missing Default,BLToolkit.Data.Linq,Sql,C:\repos\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateDiff,The following switch statement is missing a default case: switch (part)  			{  				case DateParts.Day         : return (int)(endDate - startDate).Value.TotalDays;  				case DateParts.Hour        : return (int)(endDate - startDate).Value.TotalHours;  				case DateParts.Minute      : return (int)(endDate - startDate).Value.TotalMinutes;  				case DateParts.Second      : return (int)(endDate - startDate).Value.TotalSeconds;  				case DateParts.Millisecond : return (int)(endDate - startDate).Value.TotalMilliseconds;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The following switch statement is missing a default case: switch (func.Name)  			{  				case "CASE"     : func = ConvertCase(func.SystemType' func.Parameters' 0); break;  				case "Coalesce" :    					if (func.Parameters.Length > 2)  					{  						var parms = new ISqlExpression[func.Parameters.Length - 1];    						Array.Copy(func.Parameters' 1' parms' 0' parms.Length);  						BuildFunction(sb' new SqlFunction(func.SystemType' func.Name' func.Parameters[0]'  						                  new SqlFunction(func.SystemType' func.Name' parms)));  						return;  					}    					var sc = new SqlQuery.SearchCondition();    					sc.Conditions.Add(new SqlQuery.Condition(false' new SqlQuery.Predicate.IsNull(func.Parameters[0]' false)));    					func = new SqlFunction(func.SystemType' "IIF"' sc' func.Parameters[1]' func.Parameters[0]);    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The following switch statement is missing a default case: switch (expr.Operator)  						{  							case SqlQuery.Predicate.Operator.Equal :  							case SqlQuery.Predicate.Operator.NotEqual :  								{  									ISqlExpression e = null;    									if (expr.Expr1 is SqlValueBase && ((SqlValueBase)expr.Expr1).Value == null)  										e = expr.Expr2;  									else if (expr.Expr2 is SqlValueBase && ((SqlValueBase)expr.Expr2).Value == null)  										e = expr.Expr1;    									if (e != null)  									{  										BuildExpression(sb' GetPrecedence(expr)' e);  										sb.Append(expr.Operator == SqlQuery.Predicate.Operator.Equal ? " IS NULL" : " IS NOT NULL");  										return;  									}    									break;  								}  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The following switch statement is missing a default case: switch (expr.Operator)  						{  							case SqlQuery.Predicate.Operator.Equal          : sb.Append(" = ");  break;  							case SqlQuery.Predicate.Operator.NotEqual       : sb.Append(" <> "); break;  							case SqlQuery.Predicate.Operator.Greater        : sb.Append(" > ");  break;  							case SqlQuery.Predicate.Operator.GreaterOrEqual : sb.Append(" >= "); break;  							case SqlQuery.Predicate.Operator.NotGreater     : sb.Append(" !> "); break;  							case SqlQuery.Predicate.Operator.Less           : sb.Append(" < ");  break;  							case SqlQuery.Predicate.Operator.LessOrEqual    : sb.Append(" <= "); break;  							case SqlQuery.Predicate.Operator.NotLess        : sb.Append(" !< "); break;  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetUnderlayingField,The following switch statement is missing a default case: switch (expr.ElementType)  			{  				case QueryElementType.SqlField: return (SqlField)expr;  				case QueryElementType.Column  : return GetUnderlayingField(((SqlQuery.Column)expr).Expression);  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsDateDataType,The following switch statement is missing a default case: switch (expr.ElementType)  			{  				case QueryElementType.SqlDataType   : return ((SqlDataType)  expr).SqlDbType == SqlDbType.Date;  				case QueryElementType.SqlExpression : return ((SqlExpression)expr).Expr      == dateName;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsTimeDataType,The following switch statement is missing a default case: switch (expr.ElementType)  			{  				case QueryElementType.SqlDataType   : return ((SqlDataType)expr).  SqlDbType == SqlDbType.Time;  				case QueryElementType.SqlExpression : return ((SqlExpression)expr).Expr      == "Time";  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The following switch statement is missing a default case: switch (expr.ElementType)  				{  					case QueryElementType.SearchCondition : return true;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The following switch statement is missing a default case: switch (e.ElementType)  				{  					case QueryElementType.SqlField     : ((SqlField)            e).Alias = SetAlias(((SqlField)            e).Alias' maxLen); break;  					case QueryElementType.SqlParameter : ((SqlParameter)        e).Name  = SetAlias(((SqlParameter)        e).Name'  maxLen); break;  					case QueryElementType.SqlTable     : ((SqlTable)            e).Alias = SetAlias(((SqlTable)            e).Alias' maxLen); break;  					case QueryElementType.Join         : ((Join)                e).Alias = SetAlias(((Join)                e).Alias' maxLen); break;  					case QueryElementType.Column       : ((SqlQuery.Column)     e).Alias = SetAlias(((SqlQuery.Column)     e).Alias' maxLen); break;  					case QueryElementType.TableSource  : ((SqlQuery.TableSource)e).Alias = SetAlias(((SqlQuery.TableSource)e).Alias' maxLen); break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = - value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be1.Operation)  													{  														case "+":  															{  																var value = (int)be1v2.Value - (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "-";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}    														case "-":  															{  																var value = (int)be1v2.Value + (int)v2.Value;  																var oper  = be1.Operation;    																if (value < 0)  																{  																	value = -value;  																	oper  = "+";  																}    																return new SqlBinaryExpression(be.SystemType' be1.Expr1' oper' new SqlValue(value)' be.Precedence);  															}  													}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  						{  							case "ConvertToCaseCompareTo":  								return ConvertExpression(new SqlFunction(func.SystemType' "CASE"'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Greater .Expr(func.Parameters[1]).ToExpr()' new SqlValue(1)'  									new SqlQuery.SearchCondition().Expr(func.Parameters[0]). Equal   .Expr(func.Parameters[1]).ToExpr()' new SqlValue(0)'  									new SqlValue(-1)));    							case "$Convert$": return ConvertConvertion(func);  							case "Average"  : return new SqlFunction(func.SystemType' "Avg"' func.Parameters);  							case "Max"      :  							case "Min"      :  								{  									if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?))  									{  										return new SqlFunction(typeof(int)' func.Name'  											new SqlFunction(func.SystemType' "CASE"' func.Parameters[0]' new SqlValue(1)' new SqlValue(0)));  									}    									break;  								}    							case "CASE"     :  								{  									var parms = func.Parameters;  									var len   = parms.Length;    									for (var i = 0; i < parms.Length - 1; i += 2)  									{  										var value = parms[i] as SqlValue;    										if (value != null)  										{  											if ((bool)value.Value == false)  											{  												var newParms = new ISqlExpression[parms.Length - 2];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												Array.Copy(parms' i + 2' newParms' i' parms.Length - i - 2);    												parms = newParms;  												i -= 2;  											}  											else  											{  												var newParms = new ISqlExpression[i + 1];    												if (i != 0)  													Array.Copy(parms' 0' newParms' 0' i);    												newParms[i] = parms[i + 1];    												parms = newParms;  												break;  											}  										}  									}    									if (parms.Length == 1)  										return parms[0];    									if (parms.Length != len)  										return new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);  								}    								break;    							case "Convert":  								{  									var from  = func.Parameters[1] as SqlFunction;  									var typef = TypeHelper.GetUnderlyingType(func.SystemType);    									if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType(from.Parameters[1].SystemType) == typef)  										return from.Parameters[1];    									var fe = func.Parameters[1] as SqlExpression;    									if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType(fe.Parameters[0].SystemType) == typef)  										return fe.Parameters[0];  								}    								break;  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (predicate.ElementType)  			{  				case QueryElementType.ExprExprPredicate:  					{  						var expr = (SqlQuery.Predicate.ExprExpr)predicate;    						if (expr.Operator == SqlQuery.Predicate.Operator.Equal && expr.Expr1 is SqlValue && expr.Expr2 is SqlValue)  						{  							var value = Equals(((SqlValue)expr.Expr1).Value' ((SqlValue)expr.Expr2).Value);  							return new SqlQuery.Predicate.Expr(new SqlValue(value)' Precedence.Comparison);  						}    						switch (expr.Operator)  						{  							case SqlQuery.Predicate.Operator.Equal         :  							case SqlQuery.Predicate.Operator.NotEqual      :  							case SqlQuery.Predicate.Operator.Greater       :  							case SqlQuery.Predicate.Operator.GreaterOrEqual:  							case SqlQuery.Predicate.Operator.Less          :  							case SqlQuery.Predicate.Operator.LessOrEqual   :  								predicate = OptimizeCase(expr);  								break;  						}    						if (predicate is SqlQuery.Predicate.ExprExpr)  						{  							expr = (SqlQuery.Predicate.ExprExpr)predicate;    							switch (expr.Operator)  							{  								case SqlQuery.Predicate.Operator.Equal :  								case SqlQuery.Predicate.Operator.NotEqual :  									var expr1 = expr.Expr1;  									var expr2 = expr.Expr2;    									if (expr1.CanBeNull() && expr2.CanBeNull())  									{  										if (expr1 is SqlParameter || expr2 is SqlParameter)  											SqlQuery.IsParameterDependent = true;  										else  											if (expr1 is SqlQuery.Column || expr1 is SqlField)  											if (expr2 is SqlQuery.Column || expr2 is SqlField)  												predicate = ConvertEqualPredicate(expr);  									}    									break;  							}  						}  					}    					break;    				case QueryElementType.NotExprPredicate:  					{  						var expr = (SqlQuery.Predicate.NotExpr)predicate;    						if (expr.IsNot && expr.Expr1 is SqlQuery.SearchCondition)  						{  							var sc = (SqlQuery.SearchCondition)expr.Expr1;    							if (sc.Conditions.Count == 1)  							{  								var cond = sc.Conditions[0];    								if (cond.IsNot)  									return cond.Predicate;    								if (cond.Predicate is SqlQuery.Predicate.ExprExpr)  								{  									var ee = (SqlQuery.Predicate.ExprExpr)cond.Predicate;    									if (ee.Operator == SqlQuery.Predicate.Operator.Equal)  										return new SqlQuery.Predicate.ExprExpr(ee.Expr1' SqlQuery.Predicate.Operator.NotEqual' ee.Expr2);    									if (ee.Operator == SqlQuery.Predicate.Operator.NotEqual)  										return new SqlQuery.Predicate.ExprExpr(ee.Expr1' SqlQuery.Predicate.Operator.Equal' ee.Expr2);  								}  							}  						}  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expr.Operator)  						{  							case SqlQuery.Predicate.Operator.Equal         :  							case SqlQuery.Predicate.Operator.NotEqual      :  							case SqlQuery.Predicate.Operator.Greater       :  							case SqlQuery.Predicate.Operator.GreaterOrEqual:  							case SqlQuery.Predicate.Operator.Less          :  							case SqlQuery.Predicate.Operator.LessOrEqual   :  								predicate = OptimizeCase(expr);  								break;  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expr.Operator)  							{  								case SqlQuery.Predicate.Operator.Equal :  								case SqlQuery.Predicate.Operator.NotEqual :  									var expr1 = expr.Expr1;  									var expr2 = expr.Expr2;    									if (expr1.CanBeNull() && expr2.CanBeNull())  									{  										if (expr1 is SqlParameter || expr2 is SqlParameter)  											SqlQuery.IsParameterDependent = true;  										else  											if (expr1 is SqlQuery.Column || expr1 is SqlField)  											if (expr2 is SqlQuery.Column || expr2 is SqlField)  												predicate = ConvertEqualPredicate(expr);  									}    									break;  							}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,Compare,The following switch statement is missing a default case: switch (op)  			{  				case SqlQuery.Predicate.Operator.Equal:           return v1 == v2;  				case SqlQuery.Predicate.Operator.NotEqual:        return v1 != v2;  				case SqlQuery.Predicate.Operator.Greater:         return v1 >  v2;  				case SqlQuery.Predicate.Operator.NotLess:  				case SqlQuery.Predicate.Operator.GreaterOrEqual:  return v1 >= v2;  				case SqlQuery.Predicate.Operator.Less:            return v1 <  v2;  				case SqlQuery.Predicate.Operator.NotGreater:  				case SqlQuery.Predicate.Operator.LessOrEqual:     return v1 <= v2;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The following switch statement is missing a default case: switch (e.ElementType)  						{  							case QueryElementType.SqlField : return !allTables.Contains(((SqlField)       e).Table);  							case QueryElementType.Column   : return !allTables.Contains(((SqlQuery.Column)e).Parent);  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The following switch statement is missing a default case: switch (e.ElementType)  							{  								case QueryElementType.SqlField :  									if (replaced.TryGetValue(e' out ne))  										return ne;    									if (levelTables.Contains(((SqlField)e).Table))  									{  										subQuery.GroupBy.Expr((SqlField)e);  										ne = subQuery.Select.Columns[subQuery.Select.Add((SqlField)e)];  										break;  									}    									break;    								case QueryElementType.Column   :  									if (replaced.TryGetValue(e' out ne))  										return ne;    									if (levelTables.Contains(((SqlQuery.Column)e).Parent))  									{  										subQuery.GroupBy.Expr((SqlQuery.Column)e);  										ne = subQuery.Select.Columns[subQuery.Select.Add((SqlQuery.Column)e)];  										break;  									}    									break;  							}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (e.ElementType)  							{  								case QueryElementType.SqlField : return !allTables.Contains(((SqlField)e).Table);  								case QueryElementType.Column   : return !allTables.Contains(((SqlQuery.Column)e).Parent);  							}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (((SqlFunction)subCol.Expression).Name)  								{  									case "Min"     :  									case "Max"     :  									case "Sum"     :  									case "Average" : isAggregated = true;                 break;  									case "Count"   : isAggregated = true; isCount = true; break;  								}
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (e.ElementType)  								{  									case QueryElementType.SqlField :  										if (replaced.TryGetValue(e' out ne))  											return ne;    										if (levelTables.Contains(((SqlField)e).Table))  										{  											if (isAggregated)  												subQuery.GroupBy.Expr((SqlField)e);  											ne = subQuery.Select.Columns[subQuery.Select.Add((SqlField)e)];  											break;  										}    										break;    									case QueryElementType.Column   :  										if (replaced.TryGetValue(e' out ne))  											return ne;    										if (levelTables.Contains(((SqlQuery.Column)e).Parent))  										{  											if (isAggregated)  												subQuery.GroupBy.Expr((SqlQuery.Column)e);  											ne = subQuery.Select.Columns[subQuery.Select.Add((SqlQuery.Column)e)];  											break;  										}    										break;  								}
Missing Default,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation[0])  				{  					case '%': return new SqlBinaryExpression(be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  					case '&':  					case '|':  					case '^': throw new SqlException("Operator '{0}' is not supported by the {1}."' be.Operation' GetType().Name);  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  				{  					case TypeCode.DateTime :    						if (func.Name == "Convert")  						{  							var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    							if (IsTimeDataType(func.Parameters[0]))  							{  								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  									return new SqlExpression(  										func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    								if (func.Parameters[1].SystemType == typeof(string))  									return func.Parameters[1];    								return new SqlExpression(  									func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  							}    							if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Datetime"))  									return new SqlExpression(  										func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  							}    							if (func.Parameters.Length == 2 && func.Parameters[0] is SqlDataType && func.Parameters[0] == SqlDataType.DateTime)  								return new SqlFunction(func.SystemType' func.Name' func.Precedence' func.Parameters[0]' func.Parameters[1]' new SqlValue(120));  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "CharIndex" :  						if (func.Parameters.Length == 3)  							return Add<int>(  								ConvertExpression(new SqlFunction(func.SystemType' "CharIndex"'  									func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]' new SqlFunction(typeof(int)' "Len"' func.Parameters[1])))))'  								Sub(func.Parameters[2]' 1));  						break;    					case "Stuff"     :  						if (func.Parameters[3] is SqlValue)  						{  							var value = (SqlValue)func.Parameters[3];    							if (value.Value is string && string.IsNullOrEmpty((string)value.Value))  								return new SqlFunction(  									func.SystemType'  									func.Name'  									func.Precedence'  									func.Parameters[0]'  									func.Parameters[1]'  									func.Parameters[1]'  									new SqlValue(null));  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					{  						var name = "@" + value.ToString().Replace(" "' string.Empty);    						if (name.Length > 27)  							name = name.Substring(0' 27);    						return name;  					}    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 28 || name.Length > 0 && (name[0] == '[' || name[0] == '#'))  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (expr.ElementType)  			{  				case QueryElementType.SqlBinaryExpression:  					{  						var be = (SqlBinaryExpression)expr;    						switch (be.Operation)  						{  							case "%":  								{  									var type1 = TypeHelper.GetUnderlyingType(be.Expr1.SystemType);    									if (type1 == typeof(double) || type1 == typeof(float))  									{  										return new SqlBinaryExpression(  											be.Expr2.SystemType'  											new SqlFunction(typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)'  											be.Operation'  											be.Expr2);  									}    									break;  								}  						}    						break;  					}    				case QueryElementType.SqlFunction:  					{  						var func = (SqlFunction)expr;    						switch (func.Name)  						{  							case "Convert" :  								{  									if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(ulong) &&  										TypeHelper.IsFloatType(func.Parameters[1].SystemType))  										return new SqlFunction(  											func.SystemType'  											func.Name'  											func.Precedence'  											func.Parameters[0]'  											new SqlFunction(func.SystemType' "Floor"' func.Parameters[1]));    									break;  								}  						}    						break;  					}  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  						{  							case "%":  								{  									var type1 = TypeHelper.GetUnderlyingType(be.Expr1.SystemType);    									if (type1 == typeof(double) || type1 == typeof(float))  									{  										return new SqlBinaryExpression(  											be.Expr2.SystemType'  											new SqlFunction(typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)'  											be.Operation'  											be.Expr2);  									}    									break;  								}  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  						{  							case "Convert" :  								{  									if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(ulong) &&  										TypeHelper.IsFloatType(func.Parameters[1].SystemType))  										return new SqlFunction(  											func.SystemType'  											func.Name'  											func.Precedence'  											func.Parameters[0]'  											new SqlFunction(func.SystemType' "Floor"' func.Parameters[1]));    									break;  								}  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}  					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "+":  						if (be.SystemType == typeof(string))  						{  							if (be.Expr1 is SqlFunction)  							{  								var func = (SqlFunction)be.Expr1;    								if (func.Name == "Concat")  								{  									var list = new List<ISqlExpression>(func.Parameters) { be.Expr2 };  									return new SqlFunction(be.SystemType' "Concat"' list.ToArray());  								}  							}    							return new SqlFunction(be.SystemType' "Concat"' be.Expr1' be.Expr2);  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Convert" :  						var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    						if (ftype == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if ((ftype == typeof(double) || ftype == typeof(float)) && TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(decimal))  							return func.Parameters[1];    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  					return ParameterSymbol + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToCommandParameter:  					return ParameterSymbol + CommandParameterPrefix + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToSprocParameter:  					{  						var valueStr = value.ToString().Replace(" "' string.Empty);    						if(string.IsNullOrEmpty(valueStr))  							throw new ArgumentException("Argument 'value' must represent parameter name.");    						if (valueStr[0] == ParameterSymbol)  							valueStr = valueStr.Substring(1);    						if (valueStr.StartsWith(SprocParameterPrefix' StringComparison.Ordinal))  							valueStr = valueStr.Substring(SprocParameterPrefix.Length);    						return ParameterSymbol + SprocParameterPrefix + valueStr;  					}    				case ConvertType.SprocParameterToName:  					{  						var str = value.ToString();  						str = (str.Length > 0 && (str[0] == ParameterSymbol || (TryConvertParameterSymbol && ConvertParameterSymbols.Contains(str[0])))) ? str.Substring(1) : str;    						if (!string.IsNullOrEmpty(SprocParameterPrefix) && str.StartsWith(SprocParameterPrefix))  							str = str.Substring(SprocParameterPrefix.Length);    						return str;  					}  				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();  						if (name.Length > 0 && name[0] == '`')  							return value;  					}  					return "`" + value + "`";  				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();  						if (name.Length > 0 && name[0] == '`')  						return value;    						if (name.IndexOf('.') > 0)  						value = string.Join("`.`"' name.Split('.'));  					}  					return "`" + value + "`";    			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "%":  						return TypeHelper.IsIntegerType(be.Expr1.SystemType)?  							be :  							new SqlBinaryExpression(  								typeof(int)'  								new SqlFunction(typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)'  								be.Operation'  								be.Expr2'  								be.Precedence);  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Convert" :  						switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  						{  							case TypeCode.UInt64 :  								if (TypeHelper.IsFloatType(func.Parameters[1].SystemType))  									return new SqlFunction(  										func.SystemType'  										func.Name'  										func.Precedence'  										func.Parameters[0]'  										new SqlFunction(func.SystemType' "Floor"' func.Parameters[1]));    								break;    							case TypeCode.DateTime :  								var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    								if (IsTimeDataType(func.Parameters[0]))  								{  									if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  										return new SqlExpression(  											func.SystemType' "Cast(Convert(NChar' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlExpression(  										func.SystemType' "Convert(NChar' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  								}    								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  								{  									if (IsDateDataType(func.Parameters[0]' "Datetime"))  										return new SqlExpression(  											func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  								}    								break;  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode(TypeHelper.GetUnderlyingType(func.SystemType)))  						{  							case TypeCode.UInt64 :  								if (TypeHelper.IsFloatType(func.Parameters[1].SystemType))  									return new SqlFunction(  										func.SystemType'  										func.Name'  										func.Precedence'  										func.Parameters[0]'  										new SqlFunction(func.SystemType' "Floor"' func.Parameters[1]));    								break;    							case TypeCode.DateTime :  								var type1 = TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType);    								if (IsTimeDataType(func.Parameters[0]))  								{  									if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  										return new SqlExpression(  											func.SystemType' "Cast(Convert(NChar' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters[1]);    									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlExpression(  										func.SystemType' "Convert(NChar' {0}' 114)"' Precedence.Primary' func.Parameters[1]);  								}    								if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  								{  									if (IsDateDataType(func.Parameters[0]' "Datetime"))  										return new SqlExpression(  											func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters[1]);  								}    								break;  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType)  			{  				case QueryType.Delete :  					sqlQuery = GetAlternativeDelete(sqlQuery);  					sqlQuery.From.Tables[0].Alias = "$";  					break;    				case QueryType.Update :  					sqlQuery = GetAlternativeUpdate(sqlQuery);  					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == '@'? str.Substring(1): str;  					}  					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  					case "^": // (a + b) - (a & b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlBinaryExpression(be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Space"   : return new SqlFunction(func.SystemType' "PadR"' new SqlValue(" ")' func.Parameters[0]);  					case "Convert" :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsDateDataType(func.Parameters[0]' "Date"))  									return new SqlFunction(func.SystemType' "Date"' func.Parameters[1]);  								return new SqlFunction(func.SystemType' "DateTime"' func.Parameters[1]);  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters[1]' func.Parameters[0]);  						}  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType)  			{  				case QueryType.Delete :  					sqlQuery = GetAlternativeDelete(base.Finalize(sqlQuery));  					sqlQuery.From.Tables[0].Alias = "$";  					break;    				case QueryType.Update :  					sqlQuery = GetAlternativeUpdate(sqlQuery);  					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTableAlias:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;  					}    					return "[" + value + "]";    				case ConvertType.NameToDatabase:  				case ConvertType.NameToOwner:  				case ConvertType.NameToQueryTable:  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '[')  							return value;    						if (name.IndexOf('.') > 0)  							value = string.Join("].["' name.Split('.'));  					}    					return "[" + value + "]";    				case ConvertType.SprocParameterToName:  					{  						var name = (string)value;  						return name.Length > 0 && name[0] == '@'? name.Substring(1): name;  					}  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'     be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "Bin_Or"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Convert" :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							ISqlExpression ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "DateAdd" :  						switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch ((Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  						{  							case Sql.DateParts.Quarter  :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Month)' Mul(func.Parameters[1]' 3)' func.Parameters[2]);  							case Sql.DateParts.DayOfYear:  							case Sql.DateParts.WeekDay:  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   func.Parameters[1]'         func.Parameters[2]);  							case Sql.DateParts.Week     :  								return new SqlFunction(func.SystemType' func.Name' new SqlValue(Sql.DateParts.Day)'   Mul(func.Parameters[1]' 7)' func.Parameters[2]);  						}
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryTable:  					if (QuoteIdentifiers)  					{  						string name = value.ToString();    						if (name.Length > 0 && name[0] == '"')  							return value;    						return '"' + name + '"';  					}    					break;    				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						string str = value.ToString();  						return str.Length > 0 && str[0] == '@' ? str.Substring(1) : str;  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "^": return new SqlBinaryExpression(be.SystemType' be.Expr1' "#"' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Convert"   :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);    					case "CharIndex" :  						return func.Parameters.Length == 2?  							new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]' func.Parameters[1]):  							Add<int>(  								new SqlExpression(func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters[0]'  									ConvertExpression(new SqlFunction(typeof(string)' "Substring"'  										func.Parameters[1]'  										func.Parameters[2]'  										Sub<int>(ConvertExpression(new SqlFunction(typeof(int)' "Length"' func.Parameters[1]))' func.Parameters[2]))))'  								Sub(func.Parameters[2]' 1));  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTable:  				case ConvertType.NameToQueryTableAlias:                  case ConvertType.NameToOwner:  					if (QuoteIdentifiers)  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '"')  							return value;    						return '"' + name + '"';  					}    					break;    				case ConvertType.NameToQueryParameter:  				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return ":" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return (str.Length > 0 && str[0] == ':')? str.Substring(1): str;  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "MOD"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2);  					case "|": // (a + b) - BITAND(a' b)  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)'  							be.SystemType);    					case "^": // (a + b) - BITAND(a' b) * 2  						return Sub(  							Add(be.Expr1' be.Expr2' be.SystemType)'  							Mul(new SqlFunction(be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)'  							be.SystemType);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Coalesce"       : return new SqlFunction(func.SystemType' "Nvl"' func.Parameters);  					case "Convert"        :  						{  							var ftype = TypeHelper.GetUnderlyingType(func.SystemType);    							if (ftype == typeof(bool))  							{  								var ex = AlternativeConvertToBoolean(func' 1);  								if (ex != null)  									return ex;  							}    							if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset))  							{  								if (IsTimeDataType(func.Parameters[0]))  								{  									if (func.Parameters[1].SystemType == typeof(string))  										return func.Parameters[1];    									return new SqlFunction(func.SystemType' "To_Char"' func.Parameters[1]' new SqlValue("HH24:MI:SS"));  								}    								if (TypeHelper.GetUnderlyingType(func.Parameters[1].SystemType) == typeof(DateTime) &&  									IsDateDataType(func.Parameters[0]' "Date"))  								{  									return new SqlFunction(func.SystemType' "Trunc"' func.Parameters[1]' new SqlValue("DD"));  								}    								return new SqlFunction(func.SystemType' "To_Timestamp"' func.Parameters[1]' new SqlValue("YYYY-MM-DD HH24:MI:SS"));  							}    							return new SqlExpression(func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert(func)' func.Parameters[0]);  						}  					case "ContainsExactly":  						return func.Parameters.Length == 2 ?  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]) :  							new SqlFunction(func.SystemType' "Contains"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "CharIndex"      :  						return func.Parameters.Length == 2?  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]):  							new SqlFunction(func.SystemType' "InStr"' func.Parameters[1]' func.Parameters[0]' func.Parameters[2]);  					case "AddYear"        : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]' 12));  					case "AddQuarter"     : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]' Mul(func.Parameters[1]'  3));  					case "AddMonth"       : return new SqlFunction(func.SystemType' "Add_Months"' func.Parameters[0]'     func.Parameters[1]);  					case "AddDayOfYear"   :  					case "AddWeekDay"     :  					case "AddDay"         : return Add<DateTime>(func.Parameters[0]'     func.Parameters[1]);  					case "AddWeek"        : return Add<DateTime>(func.Parameters[0]' Mul(func.Parameters[1]' 7));  					case "AddHour"        : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'                  24));  					case "AddMinute"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'             60 * 24));  					case "AddSecond"      : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]'        60 * 60 * 24));  					case "AddMillisecond" : return Add<DateTime>(func.Parameters[0]' Div(func.Parameters[1]' 1000 * 60 * 60 * 24));  					case "Avg"            :   						return new SqlFunction(  							func.SystemType'  							"Round"'  							new SqlFunction(func.SystemType' "AVG"' func.Parameters[0])'  							new SqlValue(27));  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  					string name = value.ToString().Replace(" "' string.Empty);    					if (name.Length <= 28)  						return ":" + name;    					int hashCode = name.GetHashCode();  					return string.Format(":P{0}{1}_"' hashCode < 0 ? "m" : ""' Math.Abs(hashCode));    			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "%":  						{  							var expr1 = !TypeHelper.IsIntegerType(be.Expr1.SystemType) ? new SqlFunction(typeof(int)' "Int"' be.Expr1) : be.Expr1;  							return new SqlFunction(be.SystemType' "Mod"' expr1' be.Expr2);  						}  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name)  				{  					case "Convert"    :  						if (TypeHelper.GetUnderlyingType(func.SystemType) == typeof(bool))  						{  							var ex = AlternativeConvertToBoolean(func' 1);  							if (ex != null)  								return ex;  						}    						if (func.Parameters[0] is SqlDataType)  						{  							var type = (SqlDataType)func.Parameters[0];    							if (type.Type == typeof(string) && func.Parameters[1].SystemType != typeof(string))  								return new SqlFunction(func.SystemType' "RTrim"' new SqlFunction(typeof(string)' "Char"' func.Parameters[1]));    							if (type.Length > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Length));    							if (type.Precision > 0)  								return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]' new SqlValue(type.Precision)' new SqlValue(type.Scale));    							return new SqlFunction(func.SystemType' type.SqlDbType.ToString()' func.Parameters[1]);  						}    						if (func.Parameters[0] is SqlFunction)  						{  							var f = (SqlFunction)func.Parameters[0];    							return  								f.Name == "Char" ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]) :  								f.Parameters.Length == 1 ?  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]) :  									new SqlFunction(func.SystemType' f.Name' func.Parameters[1]' f.Parameters[0]' f.Parameters[1]);  						}    						{  							var e = (SqlExpression)func.Parameters[0];  							return new SqlFunction(func.SystemType' e.Expr' func.Parameters[1]);  						}    					case "Millisecond"   : return Div(new SqlFunction(func.SystemType' "Microsecond"' func.Parameters)' 1000);  					case "SmallDateTime" :  					case "DateTime"      :  					case "DateTime2"     : return new SqlFunction(func.SystemType' "TimeStamp"' func.Parameters);  					case "TinyInt"       : return new SqlFunction(func.SystemType' "SmallInt"'  func.Parameters);  					case "Money"         : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(19)' new SqlValue(4));  					case "SmallMoney"    : return new SqlFunction(func.SystemType' "Decimal"'   func.Parameters[0]' new SqlValue(10)' new SqlValue(4));  					case "VarChar"       :  						if (TypeHelper.GetUnderlyingType(func.Parameters[0].SystemType) == typeof(decimal))  							return new SqlFunction(func.SystemType' "Char"' func.Parameters[0]);  						break;  					case "NChar"         :  					case "NVarChar"      : return new SqlFunction(func.SystemType' "Char"'      func.Parameters);  					case "DateDiff"      :  						{  							switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters[0]).Value)  							{  								case Linq.Sql.DateParts.Day         : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"'                                               Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Hour        : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"'                                                Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Minute      : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"'                                                  Precedence.Multiplicative' func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Second      : return new SqlExpression(typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"'                                                         Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  								case Linq.Sql.DateParts.Millisecond : return new SqlExpression(typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive'       func.Parameters[2]' func.Parameters[1]);  							}
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter:  					return "@" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.NameToCommandParameter:  				case ConvertType.NameToSprocParameter:  					return ":" + value.ToString().Replace(" "' string.Empty);    				case ConvertType.SprocParameterToName:  					if (value != null)  					{  						var str = value.ToString();  						return str.Length > 0 && str[0] == ':'? str.Substring(1): str;  					}    					break;    				case ConvertType.NameToQueryField:  				case ConvertType.NameToQueryFieldAlias:  				case ConvertType.NameToQueryTable:  				case ConvertType.NameToQueryTableAlias:  					if (QuoteIdentifiers)  					{  						var name = value.ToString();    						if (name.Length > 0 && name[0] == '"')  							return value;    						return '"' + name + '"';  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation)  				{  					case "%": return new SqlFunction(be.SystemType' "Mod"'    be.Expr1' be.Expr2);  					case "&": return new SqlFunction(be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  					case "|": return new SqlFunction(be.SystemType' "BitOr"'  be.Expr1' be.Expr2);  					case "^": return new SqlFunction(be.SystemType' "BitXor"' be.Expr1' be.Expr2);  					case "+": return be.SystemType == typeof(string)? new SqlBinaryExpression(be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence): expr;  				}
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType)  			{  				case QueryType.Delete :  					sqlQuery = GetAlternativeDelete(sqlQuery);  					sqlQuery.From.Tables[0].Alias = "$";  					break;    				case QueryType.Update :  					sqlQuery = GetAlternativeUpdate(sqlQuery);  					break;  			}
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType)  			{  				case ConvertType.NameToQueryParameter   : return "?";  				case ConvertType.NameToCommandParameter :  				case ConvertType.NameToSprocParameter   : return ":" + value.ToString().Replace(" "' string.Empty);  				case ConvertType.SprocParameterToName   :  					if (value != null)  					{  						var str = value.ToString();  						return (str.Length > 0 && str[0] == ':')? str.Substring(1): str;  					}    					break;  			}
Missing Default,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,The following switch statement is missing a default case: switch (element.ElementType)  			{  				case QueryElementType.SqlFunction       : return Find(((SqlFunction)                element).Parameters'      find);  				case QueryElementType.SqlExpression     : return Find(((SqlExpression)              element).Parameters'      find);  				case QueryElementType.Join              : return Find(((Join)                       element).JoinOns'         find);  				case QueryElementType.Column            : return Find(((SqlQuery.Column)            element).Expression'      find);  				case QueryElementType.SearchCondition   : return Find(((SqlQuery.SearchCondition)   element).Conditions'      find);  				case QueryElementType.Condition         : return Find(((SqlQuery.Condition)         element).Predicate'       find);  				case QueryElementType.ExprPredicate     : return Find(((SqlQuery.Predicate.Expr)    element).Expr1'           find);  				case QueryElementType.NotExprPredicate  : return Find(((SqlQuery.Predicate.NotExpr) element).Expr1'           find);  				case QueryElementType.IsNullPredicate   : return Find(((SqlQuery.Predicate.IsNull)  element).Expr1'           find);  				case QueryElementType.FromClause        : return Find(((SqlQuery.FromClause)        element).Tables'          find);  				case QueryElementType.WhereClause       : return Find(((SqlQuery.WhereClause)       element).SearchCondition' find);  				case QueryElementType.GroupByClause     : return Find(((SqlQuery.GroupByClause)     element).Items'           find);  				case QueryElementType.OrderByClause     : return Find(((SqlQuery.OrderByClause)     element).Items'           find);  				case QueryElementType.OrderByItem       : return Find(((SqlQuery.OrderByItem)       element).Expression'      find);  				case QueryElementType.Union             : return Find(((SqlQuery.Union)             element).SqlQuery'        find);  				case QueryElementType.FuncLikePredicate : return Find(((SqlQuery.Predicate.FuncLike)element).Function'        find);    				case QueryElementType.SqlBinaryExpression:  					{  						var bexpr = (SqlBinaryExpression)element;  						return  							Find(bexpr.Expr1' find) ??  							Find(bexpr.Expr2' find);  					}    				case QueryElementType.SqlTable:  					{  						var table = (SqlTable)element;  						return  							Find(table.All'            find) ??  							Find(table.Fields.Values'  find) ??  							Find(table.Joins'          find) ??  							Find(table.TableArguments' find);  					}    				case QueryElementType.TableSource:  					{  						var table = (SqlQuery.TableSource)element;  						return  							Find(table.Source' find) ??  							Find(table.Joins'  find);  					}    				case QueryElementType.JoinedTable:  					{  						var join = (SqlQuery.JoinedTable)element;  						return  							Find(join.Table'     find) ??  							Find(join.Condition' find);  					}    				case QueryElementType.ExprExprPredicate:  					{  						var p = (SqlQuery.Predicate.ExprExpr)element;  						return  							Find(p.Expr1' find) ??  							Find(p.Expr2' find);  					}    				case QueryElementType.LikePredicate:  					{  						var p = (SqlQuery.Predicate.Like)element;  						return  							Find(p.Expr1'  find) ??  							Find(p.Expr2'  find) ??  							Find(p.Escape' find);  					}    				case QueryElementType.BetweenPredicate:  					{  						var p = (SqlQuery.Predicate.Between)element;  						return  							Find(p.Expr1' find) ??  							Find(p.Expr2' find) ??  							Find(p.Expr3' find);  					}    				case QueryElementType.InSubQueryPredicate:  					{  						var p = (SqlQuery.Predicate.InSubQuery)element;  						return  							Find(p.Expr1'    find) ??  							Find(p.SubQuery' find);  					}    				case QueryElementType.InListPredicate:  					{  						var p = (SqlQuery.Predicate.InList)element;  						return  							Find(p.Expr1'  find) ??  							Find(p.Values' find);  					}    				case QueryElementType.SetExpression:  					{  						var s = (SqlQuery.SetExpression)element;  						return  							Find(s.Column'     find) ??  							Find(s.Expression' find);  					}    				case QueryElementType.InsertClause:  					{  						var sc = (SqlQuery.InsertClause)element;  						return  							Find(sc.Into'  find) ??  							Find(sc.Items' find);  					}    				case QueryElementType.UpdateClause:  					{  						var sc = (SqlQuery.UpdateClause)element;  						return  							Find(sc.Table' find) ??  							Find(sc.Items' find) ??  							Find(sc.Keys'  find);  					}    				case QueryElementType.DeleteClause:  					{  						var sc = (SqlQuery.DeleteClause)element;  						return Find(sc.Table' find);  					}    				case QueryElementType.SelectClause:  					{  						var sc = (SqlQuery.SelectClause)element;  						return  							Find(sc.TakeValue' find) ??  							Find(sc.SkipValue' find) ??  							Find(sc.Columns'   find);  					}    				case QueryElementType.SqlQuery:  					{  						var q = (SqlQuery)element;  						return  							Find(q.Select'  find) ??  							(q.IsInsert ? Find(q.Insert' find) : null) ??  							(q.IsUpdate ? Find(q.Update' find) : null) ??  							Find(q.From'    find) ??  							Find(q.Where'   find) ??  							Find(q.GroupBy' find) ??  							Find(q.Having'  find) ??  							Find(q.OrderBy' find) ??  							(q.HasUnion ? Find(q.Unions' find) : null);  					}  			}
Missing Default,BLToolkit.Data.Sql,QueryVisitor,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The following switch statement is missing a default case: switch (element.ElementType)  			{  				case QueryElementType.SqlFunction:  					{  						var func  = (SqlFunction)element;  						var parms = Convert(func.Parameters' action);    						if (parms != null && !ReferenceEquals(parms' func.Parameters))  							newElement = new SqlFunction(func.SystemType' func.Name' func.Precedence' parms);    						break;  					}    				case QueryElementType.SqlExpression:  					{  						var expr      = (SqlExpression)element;  						var parameter = Convert(expr.Parameters' action);    						if (parameter != null && !ReferenceEquals(parameter' expr.Parameters))  							newElement = new SqlExpression(expr.SystemType' expr.Expr' expr.Precedence' parameter);    						break;  					}    				case QueryElementType.SqlBinaryExpression:  					{  						var bexpr = (SqlBinaryExpression)element;  						var expr1 = (ISqlExpression)ConvertInternal(bexpr.Expr1' action);  						var expr2 = (ISqlExpression)ConvertInternal(bexpr.Expr2' action);    						if (expr1 != null && !ReferenceEquals(expr1' bexpr.Expr1) ||  							expr2 != null && !ReferenceEquals(expr2' bexpr.Expr2))  							newElement = new SqlBinaryExpression(bexpr.SystemType' expr1 ?? bexpr.Expr1' bexpr.Operation' expr2 ?? bexpr.Expr2' bexpr.Precedence);    						break;  					}    				case QueryElementType.SqlTable:  					{  						var table   = (SqlTable)element;  						var fields1 = ToArray(table.Fields);  						var fields2 = Convert(fields1'     action' f => new SqlField(f));  						var joins   = Convert(table.Joins' action' j => j.Clone());  						var targs   = table.TableArguments == null ? null : Convert(table.TableArguments' action);    						var fe = fields2 == null || ReferenceEquals(fields1'     fields2);  						var je = joins   == null || ReferenceEquals(table.Joins' joins);  						var ta = ReferenceEquals(table.TableArguments' targs);    						if (!fe || !je || !ta)  						{  							if (fe)  							{  								fields2 = fields1;    								for (var i = 0; i < fields2.Length; i++)  								{  									var field = fields2[i];    									fields2[i] = new SqlField(field);    									_visitedElements[field] = fields2[i];  								}  							}    							newElement = new SqlTable(table' fields2' joins ?? table.Joins' targs ?? table.TableArguments);    							_visitedElements[((SqlTable)newElement).All] = table.All;  						}    						break;  					}    				case QueryElementType.Join:  					{  						var join = (Join)element;  						var ons  = Convert(join.JoinOns' action);    						if (ons != null && !ReferenceEquals(join.JoinOns' ons))  							newElement = new Join(join.TableName' join.Alias' ons);    						break;  					}    				case QueryElementType.Column:  					{  						var col  = (SqlQuery.Column)element;  						var expr = (ISqlExpression)ConvertInternal(col.Expression' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(col.Parent' out parent);    						if (parent != null || expr != null && !ReferenceEquals(expr' col.Expression))  							newElement = new SqlQuery.Column(parent == null ? col.Parent : (SqlQuery)parent' expr ?? col.Expression' col._alias);    						break;  					}    				case QueryElementType.TableSource:  					{  						var table  = (SqlQuery.TableSource)element;  						var source = (ISqlTableSource)ConvertInternal(table.Source' action);  						var joins  = Convert(table.Joins' action);    						if (source != null && !ReferenceEquals(source' table.Source) ||  							joins  != null && !ReferenceEquals(table.Joins' joins))  							newElement = new SqlQuery.TableSource(source ?? table.Source' table._alias' joins ?? table.Joins);    						break;  					}    				case QueryElementType.JoinedTable:  					{  						var join  = (SqlQuery.JoinedTable)element;  						var table = (SqlQuery.TableSource)    ConvertInternal(join.Table'     action);  						var cond  = (SqlQuery.SearchCondition)ConvertInternal(join.Condition' action);    						if (table != null && !ReferenceEquals(table' join.Table) ||  							cond  != null && !ReferenceEquals(cond'  join.Condition))  							newElement = new SqlQuery.JoinedTable(join.JoinType' table ?? join.Table' join.IsWeak' cond ?? join.Condition);    						break;  					}    				case QueryElementType.SearchCondition:  					{  						var sc    = (SqlQuery.SearchCondition)element;  						var conds = Convert(sc.Conditions' action);    						if (conds != null && !ReferenceEquals(sc.Conditions' conds))  							newElement = new SqlQuery.SearchCondition(conds);    						break;  					}    				case QueryElementType.Condition:  					{  						var c = (SqlQuery.Condition)element;  						var p = (ISqlPredicate)ConvertInternal(c.Predicate' action);    						if (p != null && !ReferenceEquals(c.Predicate' p))  							newElement = new SqlQuery.Condition(c.IsNot' p' c.IsOr);    						break;  					}    				case QueryElementType.ExprPredicate:  					{  						var p = (SqlQuery.Predicate.Expr)element;  						var e = (ISqlExpression)ConvertInternal(p.Expr1' action);    						if (e != null && !ReferenceEquals(p.Expr1' e))  							newElement = new SqlQuery.Predicate.Expr(e' p.Precedence);    						break;  					}    				case QueryElementType.NotExprPredicate:  					{  						var p = (SqlQuery.Predicate.NotExpr)element;  						var e = (ISqlExpression)ConvertInternal(p.Expr1' action);    						if (e != null && !ReferenceEquals(p.Expr1' e))  							newElement = new SqlQuery.Predicate.NotExpr(e' p.IsNot' p.Precedence);    						break;  					}    				case QueryElementType.ExprExprPredicate:  					{  						var p  = (SqlQuery.Predicate.ExprExpr)element;  						var e1 = (ISqlExpression)ConvertInternal(p.Expr1' action);  						var e2 = (ISqlExpression)ConvertInternal(p.Expr2' action);    						if (e1 != null && !ReferenceEquals(p.Expr1' e1) || e2 != null && !ReferenceEquals(p.Expr2' e2))  							newElement = new SqlQuery.Predicate.ExprExpr(e1 ?? p.Expr1' p.Operator' e2 ?? p.Expr2);    						break;  					}    				case QueryElementType.LikePredicate:  					{  						var p  = (SqlQuery.Predicate.Like)element;  						var e1 = (ISqlExpression)ConvertInternal(p.Expr1'  action);  						var e2 = (ISqlExpression)ConvertInternal(p.Expr2'  action);  						var es = (ISqlExpression)ConvertInternal(p.Escape' action);    						if (e1 != null && !ReferenceEquals(p.Expr1' e1) ||  							e2 != null && !ReferenceEquals(p.Expr2' e2) ||  							es != null && !ReferenceEquals(p.Escape' es))  							newElement = new SqlQuery.Predicate.Like(e1 ?? p.Expr1' p.IsNot' e2 ?? p.Expr2' es ?? p.Escape);    						break;  					}    				case QueryElementType.BetweenPredicate:  					{  						var p = (SqlQuery.Predicate.Between)element;  						var e1 = (ISqlExpression)ConvertInternal(p.Expr1' action);  						var e2 = (ISqlExpression)ConvertInternal(p.Expr2' action);  						var e3 = (ISqlExpression)ConvertInternal(p.Expr3' action);    						if (e1 != null && !ReferenceEquals(p.Expr1' e1) ||  							e2 != null && !ReferenceEquals(p.Expr2' e2) ||  							e3 != null && !ReferenceEquals(p.Expr3' e3))  							newElement = new SqlQuery.Predicate.Between(e1 ?? p.Expr1' p.IsNot' e2 ?? p.Expr2' e3 ?? p.Expr3);    						break;  					}    				case QueryElementType.IsNullPredicate:  					{  						var p = (SqlQuery.Predicate.IsNull)element;  						var e = (ISqlExpression)ConvertInternal(p.Expr1' action);    						if (e != null && !ReferenceEquals(p.Expr1' e))  							newElement = new SqlQuery.Predicate.IsNull(e' p.IsNot);    						break;  					}    				case QueryElementType.InSubQueryPredicate:  					{  						var p = (SqlQuery.Predicate.InSubQuery)element;  						var e = (ISqlExpression)ConvertInternal(p.Expr1'    action);  						var q = (SqlQuery)ConvertInternal(p.SubQuery' action);    						if (e != null && !ReferenceEquals(p.Expr1' e) || q != null && !ReferenceEquals(p.SubQuery' q))  							newElement = new SqlQuery.Predicate.InSubQuery(e ?? p.Expr1' p.IsNot' q ?? p.SubQuery);    						break;  					}    				case QueryElementType.InListPredicate:  					{  						var p = (SqlQuery.Predicate.InList)element;  						var e = (ISqlExpression)ConvertInternal(p.Expr1'    action);  						var v = Convert(p.Values' action);    						if (e != null && !ReferenceEquals(p.Expr1' e) || v != null && !ReferenceEquals(p.Values' v))  							newElement = new SqlQuery.Predicate.InList(e ?? p.Expr1' p.IsNot' v ?? p.Values);    						break;  					}    				case QueryElementType.FuncLikePredicate:  					{  						var p = (SqlQuery.Predicate.FuncLike)element;  						var f = (SqlFunction)ConvertInternal(p.Function' action);    						if (f != null && !ReferenceEquals(p.Function' f))  							newElement = new SqlQuery.Predicate.FuncLike(f);    						break;  					}    				case QueryElementType.SetExpression:  					{  						var s = (SqlQuery.SetExpression)element;  						var c = (ISqlExpression)ConvertInternal(s.Column'     action);  						var e = (ISqlExpression)ConvertInternal(s.Expression' action);    						if (c != null && !ReferenceEquals(s.Column' c) || e != null && !ReferenceEquals(s.Expression' e))  							newElement = new SqlQuery.SetExpression(c ?? s.Column' e ?? s.Expression);    						break;  					}    				case QueryElementType.InsertClause:  					{  						var s = (SqlQuery.InsertClause)element;  						var t = s.Into != null ? (SqlTable)ConvertInternal(s.Into' action) : null;  						var i = Convert(s.Items' action);    						if (t != null && !ReferenceEquals(s.Into' t) || i != null && !ReferenceEquals(s.Items' i))  						{  							var sc = new SqlQuery.InsertClause { Into = t ?? s.Into };    							sc.Items.AddRange(i ?? s.Items);  							sc.WithIdentity = s.WithIdentity;    							newElement = sc;  						}    						break;  					}    				case QueryElementType.UpdateClause:  					{  						var s = (SqlQuery.UpdateClause)element;  						var t = s.Table != null ? (SqlTable)ConvertInternal(s.Table' action) : null;  						var i = Convert(s.Items' action);  						var k = Convert(s.Keys'  action);    						if (t != null && !ReferenceEquals(s.Table' t) ||  							i != null && !ReferenceEquals(s.Items' i) ||  							k != null && !ReferenceEquals(s.Keys'  k))  						{  							var sc = new SqlQuery.UpdateClause { Table = t ?? s.Table };    							sc.Items.AddRange(i ?? s.Items);  							sc.Keys. AddRange(k ?? s.Keys);    							newElement = sc;  						}    						break;  					}    				case QueryElementType.DeleteClause:  					{  						var s = (SqlQuery.DeleteClause)element;  						var t = s.Table != null ? (SqlTable)ConvertInternal(s.Table' action) : null;    						if (t != null && !ReferenceEquals(s.Table' t))  						{  							newElement = new SqlQuery.DeleteClause { Table = t ?? s.Table };  						}    						break;  					}    				case QueryElementType.SelectClause:  					{  						var sc   = (SqlQuery.SelectClause)element;  						var cols = Convert(sc.Columns' action);  						var take = (ISqlExpression)ConvertInternal(sc.TakeValue' action);  						var skip = (ISqlExpression)ConvertInternal(sc.SkipValue' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(sc.SqlQuery' out parent);    						if (parent != null ||  							cols != null && !ReferenceEquals(sc.Columns'   cols) ||  							take != null && !ReferenceEquals(sc.TakeValue' take) ||  							skip != null && !ReferenceEquals(sc.SkipValue' skip))  						{  							newElement = new SqlQuery.SelectClause(sc.IsDistinct' take ?? sc.TakeValue' skip ?? sc.SkipValue' cols ?? sc.Columns);  							((SqlQuery.SelectClause)newElement).SetSqlQuery((SqlQuery)parent);  						}    						break;  					}    				case QueryElementType.FromClause:  					{  						var fc   = (SqlQuery.FromClause)element;  						var ts = Convert(fc.Tables' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(fc.SqlQuery' out parent);    						if (parent != null || ts != null && !ReferenceEquals(fc.Tables' ts))  						{  							newElement = new SqlQuery.FromClause(ts ?? fc.Tables);  							((SqlQuery.FromClause)newElement).SetSqlQuery((SqlQuery)parent);  						}    						break;  					}    				case QueryElementType.WhereClause:  					{  						var wc   = (SqlQuery.WhereClause)element;  						var cond = (SqlQuery.SearchCondition)ConvertInternal(wc.SearchCondition' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(wc.SqlQuery' out parent);    						if (parent != null || cond != null && !ReferenceEquals(wc.SearchCondition' cond))  						{  							newElement = new SqlQuery.WhereClause(cond ?? wc.SearchCondition);  							((SqlQuery.WhereClause)newElement).SetSqlQuery((SqlQuery)parent);  						}    						break;  					}    				case QueryElementType.GroupByClause:  					{  						var gc = (SqlQuery.GroupByClause)element;  						var es = Convert(gc.Items' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(gc.SqlQuery' out parent);    						if (parent != null || es != null && !ReferenceEquals(gc.Items' es))  						{  							newElement = new SqlQuery.GroupByClause(es ?? gc.Items);  							((SqlQuery.GroupByClause)newElement).SetSqlQuery((SqlQuery)parent);  						}    						break;  					}    				case QueryElementType.OrderByClause:  					{  						var oc = (SqlQuery.OrderByClause)element;  						var es = Convert(oc.Items' action);    						IQueryElement parent;  						_visitedElements.TryGetValue(oc.SqlQuery' out parent);    						if (parent != null || es != null && !ReferenceEquals(oc.Items' es))  						{  							newElement = new SqlQuery.OrderByClause(es ?? oc.Items);  							((SqlQuery.OrderByClause)newElement).SetSqlQuery((SqlQuery)parent);  						}    						break;  					}    				case QueryElementType.OrderByItem:  					{  						var i = (SqlQuery.OrderByItem)element;  						var e = (ISqlExpression)ConvertInternal(i.Expression' action);    						if (e != null && !ReferenceEquals(i.Expression' e))  							newElement = new SqlQuery.OrderByItem(e' i.IsDescending);    						break;  					}    				case QueryElementType.Union:  					{  						var u = (SqlQuery.Union)element;  						var q = (SqlQuery)ConvertInternal(u.SqlQuery' action);    						if (q != null && !ReferenceEquals(u.SqlQuery' q))  							newElement = new SqlQuery.Union(q' u.IsAll);    						break;  					}    				case QueryElementType.SqlQuery:  					{  						var q = (SqlQuery)element;  						IQueryElement parent = null;    						var doConvert = q.ParentSql != null && !_visitedElements.TryGetValue(q.ParentSql' out parent);    						if (!doConvert)  						{  							doConvert = null != Find(q' e =>  							{  								if (_visitedElements.ContainsKey(e) && _visitedElements[e] != e)  									return true;    								var ret = action(e);    								if (ret != null && !ReferenceEquals(e' ret))  								{  									_visitedElements.Add(e' ret);  									return true;  								}    								return false;  							});  						}    						if (!doConvert)  							break;    						var nq = new SqlQuery { QueryType = q.QueryType };    						_visitedElements.Add(q' nq);    						var fc = (SqlQuery.FromClause)   ConvertInternal(q.From'    action) ?? q.From;  						var sc = (SqlQuery.SelectClause) ConvertInternal(q.Select'  action) ?? q.Select;  						var ic = q.IsInsert ? ((SqlQuery.InsertClause)ConvertInternal(q.Insert' action) ?? q.Insert) : null;  						var uc = q.IsUpdate ? ((SqlQuery.UpdateClause)ConvertInternal(q.Update' action) ?? q.Update) : null;  						var dc = q.IsDelete ? ((SqlQuery.DeleteClause)ConvertInternal(q.Delete' action) ?? q.Delete) : null;  						var wc = (SqlQuery.WhereClause)  ConvertInternal(q.Where'   action) ?? q.Where;  						var gc = (SqlQuery.GroupByClause)ConvertInternal(q.GroupBy' action) ?? q.GroupBy;  						var hc = (SqlQuery.WhereClause)  ConvertInternal(q.Having'  action) ?? q.Having;  						var oc = (SqlQuery.OrderByClause)ConvertInternal(q.OrderBy' action) ?? q.OrderBy;  						var us = q.HasUnion ? Convert(q.Unions' action) : q.Unions;    						var ps = new List<SqlParameter>(q.Parameters.Count);    						foreach (var p in q.Parameters)  						{  							IQueryElement e;    							if (_visitedElements.TryGetValue(p' out e))  							{  								if (e == null)  									ps.Add(p);  								else if (e is SqlParameter)  									ps.Add((SqlParameter)e);  							}  						}    						nq.Init(ic' uc' dc' sc' fc' wc' gc' hc' oc' us' (SqlQuery)parent' q.IsParameterDependent' ps);    						_visitedElements[q] = action(nq) ?? nq;    						return nq;  					}  			}
Missing Default,BLToolkit.Data.Sql,SqlDataType,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,GetDataType,The following switch statement is missing a default case: switch (type)  			{  				case SqlDbType.BigInt           : return DbBigInt;  				case SqlDbType.Binary           : return DbBinary;  				case SqlDbType.Bit              : return DbBit;  				case SqlDbType.Char             : return DbChar;  				case SqlDbType.DateTime         : return DbDateTime;  				case SqlDbType.Decimal          : return DbDecimal;  				case SqlDbType.Float            : return DbFloat;  				case SqlDbType.Image            : return DbImage;  				case SqlDbType.Int              : return DbInt;  				case SqlDbType.Money            : return DbMoney;  				case SqlDbType.NChar            : return DbNChar;  				case SqlDbType.NText            : return DbNText;  				case SqlDbType.NVarChar         : return DbNVarChar;  				case SqlDbType.Real             : return DbReal;  				case SqlDbType.UniqueIdentifier : return DbUniqueIdentifier;  				case SqlDbType.SmallDateTime    : return DbSmallDateTime;  				case SqlDbType.SmallInt         : return DbSmallInt;  				case SqlDbType.SmallMoney       : return DbSmallMoney;  				case SqlDbType.Text             : return DbText;  				case SqlDbType.Timestamp        : return DbTimestamp;  				case SqlDbType.TinyInt          : return DbTinyInt;  				case SqlDbType.VarBinary        : return DbVarBinary;  				case SqlDbType.VarChar          : return DbVarChar;  				case SqlDbType.Variant          : return DbVariant;  #if !SILVERLIGHT  				case SqlDbType.Xml              : return DbXml;  #endif  				case SqlDbType.Udt              : return DbUdt;  #if !MONO  				case SqlDbType.Structured       : return DbStructured;  #endif  				case SqlDbType.Date             : return DbDate;  				case SqlDbType.Time             : return DbTime;  #if !MONO  				case SqlDbType.DateTime2        : return DbDateTime2;  				case SqlDbType.DateTimeOffset   : return DbDateTimeOffset;  #endif  			}
Missing Default,BLToolkit.Data.Sql,SqlExpression,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,NeedsEqual,The following switch statement is missing a default case: switch (ex.ElementType)  			{  				case QueryElementType.SqlParameter:  				case QueryElementType.SqlField    :  				case QueryElementType.Column      : return true;  				case QueryElementType.SqlFunction :    					var f = (SqlFunction)ex;    					switch (f.Name)  					{  						case "EXISTS" : return false;  					}    					return true;  			}
Missing Default,BLToolkit.Data.Sql,SqlExpression,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,NeedsEqual,The following switch statement is missing a default case: switch (f.Name)  					{  						case "EXISTS" : return false;  					}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetQueryData,The following switch statement is missing a default case: switch (e.ElementType)  				{  					case QueryElementType.SqlField :  						{  							var field = (SqlField)e;    							if (field.Name.Length != 1 || field.Name[0] != '*')  								data.Fields.Add(field);    							break;  						}    					case QueryElementType.SqlQuery :  						{  							if (e != this)  							{  								data.Queries.Add(((SqlQuery)e).GetQueryData());  								return false;  							}    							break;  						}    					case QueryElementType.Column :  						return ((Column)e).Parent == this;    					case QueryElementType.SqlTable :  						return false;  				}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,The following switch statement is missing a default case: switch (e.ElementType)  					{  						case QueryElementType.SqlQuery :  							return e == data.Query;    						case QueryElementType.SqlFunction :  							{  								var parms = ((SqlFunction)e).Parameters;    								for (var i = 0; i < parms.Length; i++)  									if (dic.TryGetValue(parms[i]' out ex))  										parms[i] = ex;    								break;  							}    						case QueryElementType.SqlExpression :  							{  								var parms = ((SqlExpression)e).Parameters;    								for (var i = 0; i < parms.Length; i++)  									if (dic.TryGetValue(parms[i]' out ex))  										parms[i] = ex;    								break;  							}    						case QueryElementType.SqlBinaryExpression :  							{  								var expr = (SqlBinaryExpression)e;  								if (dic.TryGetValue(expr.Expr1' out ex)) expr.Expr1 = ex;  								if (dic.TryGetValue(expr.Expr2' out ex)) expr.Expr2 = ex;  								break;  							}    						case QueryElementType.ExprPredicate       :  						case QueryElementType.NotExprPredicate    :  						case QueryElementType.IsNullPredicate     :  						case QueryElementType.InSubQueryPredicate :  							{  								var expr = (Predicate.Expr)e;  								if (dic.TryGetValue(expr.Expr1' out ex)) expr.Expr1 = ex;  								break;  							}    						case QueryElementType.ExprExprPredicate :  							{  								var expr = (Predicate.ExprExpr)e;  								if (dic.TryGetValue(expr.Expr1' out ex)) expr.Expr1 = ex;  								if (dic.TryGetValue(expr.Expr2' out ex)) expr.Expr2 = ex;  								break;  							}    						case QueryElementType.LikePredicate :  							{  								var expr = (Predicate.Like)e;  								if (dic.TryGetValue(expr.Expr1'  out ex)) expr.Expr1  = ex;  								if (dic.TryGetValue(expr.Expr2'  out ex)) expr.Expr2  = ex;  								if (dic.TryGetValue(expr.Escape' out ex)) expr.Escape = ex;  								break;  							}    						case QueryElementType.BetweenPredicate :  							{  								var expr = (Predicate.Between)e;  								if (dic.TryGetValue(expr.Expr1' out ex)) expr.Expr1 = ex;  								if (dic.TryGetValue(expr.Expr2' out ex)) expr.Expr2 = ex;  								if (dic.TryGetValue(expr.Expr3' out ex)) expr.Expr3 = ex;  								break;  							}    						case QueryElementType.InListPredicate :  							{  								var expr = (Predicate.InList)e;    								if (dic.TryGetValue(expr.Expr1' out ex)) expr.Expr1 = ex;    								for (var i = 0; i < expr.Values.Count; i++)  									if (dic.TryGetValue(expr.Values[i]' out ex))  										expr.Values[i] = ex;    								break;  							}    						case QueryElementType.Column :  							{  								var expr = (Column)e;    								if (expr.Parent != data.Query)  									return false;    								if (dic.TryGetValue(expr.Expression' out ex)) expr.Expression = ex;    								break;  							}    						case QueryElementType.SetExpression :  							{  								var expr = (SetExpression)e;  								if (dic.TryGetValue(expr.Expression' out ex)) expr.Expression = ex;  								break;  							}    						case QueryElementType.GroupByClause :  							{  								var expr = (GroupByClause)e;    								for (var i = 0; i < expr.Items.Count; i++)  									if (dic.TryGetValue(expr.Items[i]' out ex))  										expr.Items[i] = ex;    								break;  							}    						case QueryElementType.OrderByItem :  							{  								var expr = (OrderByItem)e;  								if (dic.TryGetValue(expr.Expression' out ex)) expr.Expression = ex;  								break;  							}  					}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,IsAggregationFunction,The following switch statement is missing a default case: switch (((SqlFunction)expr).Name)  				{  					case "Count"   :  					case "Average" :  					case "Min"     :  					case "Max"     :  					case "Sum"     : return true;  				}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,SetAliases,The following switch statement is missing a default case: switch (expr.ElementType)  				{  					case QueryElementType.SqlParameter:  						{  							var p = (SqlParameter)expr;    							//if (p.IsQueryParameter)  							//{  								if (!objs.ContainsKey(expr))  								{  									objs.Add(expr' expr);  									p.Name = GetAlias(p.Name' "p");  								}    								Parameters.Add(p);  							//}  							//else  							//	IsParameterDependent = true;    							IsParameterDependent |= !p.IsQueryParameter;  						}    						break;    					case QueryElementType.Column:  						{  							if (!objs.ContainsKey(expr))  							{  								objs.Add(expr' expr);    								var c = (Column)expr;    								if (c.Alias != "*")  									c.Alias = GetAlias(c.Alias' "c");  							}  						}    						break;    					case QueryElementType.TableSource:  						{  							var table = (TableSource)expr;    							if (!objs.ContainsKey(table))  							{  								objs.Add(table' table);  								table.Alias = GetAlias(table.Alias' "t");  							}  						}    						break;    					case QueryElementType.SqlQuery:  						{  							var sql = (SqlQuery)expr;    							if (sql.HasUnion)  							{  								for (var i = 0; i < sql.Select.Columns.Count; i++)  								{  									var col = sql.Select.Columns[i];    									foreach (var t in sql.Unions)  									{  										var union = t.SqlQuery.Select;    										objs.Remove(union.Columns[i].Alias);    										union.Columns[i].Alias = col.Alias;  									}  								}  							}  						}    						break;  				}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ProcessParameters,The following switch statement is missing a default case: switch (e.ElementType)  					{  						case QueryElementType.SqlParameter :  							{  								var p = (SqlParameter)e;    								if (p.Value == null)  									return new SqlValue(null);  							}    							break;    						case QueryElementType.ExprExprPredicate :  							{  								var ee = (Predicate.ExprExpr)e;  								  								if (ee.Operator == Predicate.Operator.Equal || ee.Operator == Predicate.Operator.NotEqual)  								{  									object value1;  									object value2;    									if (ee.Expr1 is SqlValue)  										value1 = ((SqlValue)ee.Expr1).Value;  									else if (ee.Expr1 is SqlParameter)  										value1 = ((SqlParameter)ee.Expr1).Value;  									else  										break;    									if (ee.Expr2 is SqlValue)  										value2 = ((SqlValue)ee.Expr2).Value;  									else if (ee.Expr2 is SqlParameter)  										value2 = ((SqlParameter)ee.Expr2).Value;  									else  										break;    									var value = Equals(value1' value2);    									if (ee.Operator == Predicate.Operator.NotEqual)  										value = !value;    									return new Predicate.Expr(new SqlValue(value)' Sql.Precedence.Comparison);  								}  							}    							break;    						case QueryElementType.InListPredicate :  							return ConvertInListPredicate((Predicate.InList)e);  					}
Missing Default,BLToolkit.Data.Sql,SqlQuery,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetUnderlayingField,The following switch statement is missing a default case: switch (expr.ElementType)  			{  				case QueryElementType.SqlField: return (SqlField)expr;  				case QueryElementType.Column  : return GetUnderlayingField(((Column)expr).Expression);  			}
Missing Default,BLToolkit.Data.Sql,SelectClause,C:\repos\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,AddOrGetColumn,The following switch statement is missing a default case: switch (col.Expression.ElementType)  				{  					case QueryElementType.SqlField :  						{  							var table = ((SqlField)col.Expression).Table;    							//if (SqlQuery.From.GetFromTables().Any(_ => _ == table))  							//	throw new InvalidOperationException("Wrong field usage.");    							break;  						}    					case QueryElementType.Column :  						{  							var query = ((Column)col.Expression).Parent;    							//if (!SqlQuery.From.GetFromQueries().Any(_ => _ == query))  							//	throw new InvalidOperationException("Wrong column usage.");    							break;  						}    					case QueryElementType.SqlQuery :  						{  							if (col.Expression == SqlQuery)  								throw new InvalidOperationException("Wrong query usage.");  							break;  						}  				}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,IsConstant,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.Int16   :  				case TypeCode.Int32   :  				case TypeCode.Int64   :  				case TypeCode.UInt16  :  				case TypeCode.UInt32  :  				case TypeCode.UInt64  :  				case TypeCode.SByte   :  				case TypeCode.Byte    :  				case TypeCode.Decimal :  				case TypeCode.Double  :  				case TypeCode.Single  :  				case TypeCode.Boolean :  				case TypeCode.String  :  				case TypeCode.Char    : return true;  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The following switch statement is missing a default case: switch (expr1.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						var e1 = (BinaryExpression)expr1;  						var e2 = (BinaryExpression)expr2;  						return  							e1.Method == e2.Method &&  							Compare(e1.Conversion' e2.Conversion' visited' queryableAccessorDic) &&  							Compare(e1.Left'       e2.Left'       visited' queryableAccessorDic) &&  							Compare(e1.Right'      e2.Right'      visited' queryableAccessorDic);  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					{  						var e1 = (UnaryExpression)expr1;  						var e2 = (UnaryExpression)expr2;  						return e1.Method == e2.Method && Compare(e1.Operand' e2.Operand' visited' queryableAccessorDic);  					}    				case ExpressionType.Call:  					{  						var e1 = (MethodCallExpression)expr1;  						var e2 = (MethodCallExpression)expr2;    						if (e1.Arguments.Count != e2.Arguments.Count || e1.Method != e2.Method)  							return false;    						if (queryableAccessorDic.Count > 0)  						{  							QueryableAccessor qa;    							if (queryableAccessorDic.TryGetValue(expr1' out qa))  								return Compare(qa.Queryable.Expression' qa.Accessor(expr2).Expression' visited' queryableAccessorDic);  						}    						if (!Compare(e1.Object' e2.Object' visited' queryableAccessorDic))  							return false;    						for (var i = 0; i < e1.Arguments.Count; i++)  							if (!Compare(e1.Arguments[i]' e2.Arguments[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    				case ExpressionType.Conditional:  					{  						var e1 = (ConditionalExpression)expr1;  						var e2 = (ConditionalExpression)expr2;  						return  							Compare(e1.Test'    e2.Test'    visited' queryableAccessorDic) &&  							Compare(e1.IfTrue'  e2.IfTrue'  visited' queryableAccessorDic) &&  							Compare(e1.IfFalse' e2.IfFalse' visited' queryableAccessorDic);  					}    				case ExpressionType.Constant:  					{  						var e1 = (ConstantExpression)expr1;  						var e2 = (ConstantExpression)expr2;    						if (e1.Value == null && e2.Value == null)  							return true;    						if (IsConstant(e1.Type))  							return Equals(e1.Value' e2.Value);    						if (e1.Value == null || e2.Value == null)  							return false;    						if (e1.Value is IQueryable)  						{  							var eq1 = ((IQueryable)e1.Value).Expression;  							var eq2 = ((IQueryable)e2.Value).Expression;    							if (visited.Add(eq1))  								return Compare(eq1' eq2' visited' queryableAccessorDic);  						}    						return true;  					}    				case ExpressionType.Invoke:  					{  						var e1 = (InvocationExpression)expr1;  						var e2 = (InvocationExpression)expr2;    						if (e1.Arguments.Count != e2.Arguments.Count || !Compare(e1.Expression' e2.Expression' visited' queryableAccessorDic))  							return false;    						for (var i = 0; i < e1.Arguments.Count; i++)  							if (!Compare(e1.Arguments[i]' e2.Arguments[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    				case ExpressionType.Lambda:  					{  						var e1 = (LambdaExpression)expr1;  						var e2 = (LambdaExpression)expr2;    						if (e1.Parameters.Count != e2.Parameters.Count || !Compare(e1.Body' e2.Body' visited' queryableAccessorDic))  							return false;    						for (var i = 0; i < e1.Parameters.Count; i++)  							if (!Compare(e1.Parameters[i]' e2.Parameters[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    				case ExpressionType.ListInit:  					{  						var e1 = (ListInitExpression)expr1;  						var e2 = (ListInitExpression)expr2;    						if (e1.Initializers.Count != e2.Initializers.Count || !Compare(e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic))  							return false;    						for (var i = 0; i < e1.Initializers.Count; i++)  						{  							var i1 = e1.Initializers[i];  							var i2 = e2.Initializers[i];    							if (i1.Arguments.Count != i2.Arguments.Count || i1.AddMethod != i2.AddMethod)  								return false;    							for (var j = 0; j < i1.Arguments.Count; j++)  								if (!Compare(i1.Arguments[j]' i2.Arguments[j]' visited' queryableAccessorDic))  									return false;  						}    						return true;  					}    				case ExpressionType.MemberAccess:  					{  						var e1 = (MemberExpression)expr1;  						var e2 = (MemberExpression)expr2;    						if (e1.Member == e2.Member)  						{  							if (e1.Expression == e2.Expression || e1.Expression.Type == e2.Expression.Type)  							{  								if (queryableAccessorDic.Count > 0)  								{  									QueryableAccessor qa;    									if (queryableAccessorDic.TryGetValue(expr1' out qa))  										return  											Compare(e1.Expression' e2.Expression' visited' queryableAccessorDic) &&  											Compare(qa.Queryable.Expression' qa.Accessor(expr2).Expression' visited' queryableAccessorDic);  								}  							}    							return Compare(e1.Expression' e2.Expression' visited' queryableAccessorDic);  						}    						return false;  					}    				case ExpressionType.MemberInit:  					{  						var e1 = (MemberInitExpression)expr1;  						var e2 = (MemberInitExpression)expr2;    						if (e1.Bindings.Count != e2.Bindings.Count || !Compare(e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic))  							return false;    						Func<MemberBinding'MemberBinding'bool> compareBindings = null; compareBindings = (b1'b2) =>  						{  							if (b1 == b2)  								return true;    							if (b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member)  								return false;    							switch (b1.BindingType)  							{  								case MemberBindingType.Assignment:  									return Compare(((MemberAssignment)b1).Expression' ((MemberAssignment)b2).Expression' visited' queryableAccessorDic);    								case MemberBindingType.ListBinding:  									var ml1 = (MemberListBinding)b1;  									var ml2 = (MemberListBinding)b2;    									if (ml1.Initializers.Count != ml2.Initializers.Count)  										return false;    									for (var i = 0; i < ml1.Initializers.Count; i++)  									{  										var ei1 = ml1.Initializers[i];  										var ei2 = ml2.Initializers[i];    										if (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)  											return false;    										for (var j = 0; j < ei1.Arguments.Count; j++)  											if (!Compare(ei1.Arguments[j]' ei2.Arguments[j]' visited' queryableAccessorDic))  												return false;  									}    									break;    								case MemberBindingType.MemberBinding:  									var mm1 = (MemberMemberBinding)b1;  									var mm2 = (MemberMemberBinding)b2;    									if (mm1.Bindings.Count != mm2.Bindings.Count)  										return false;    									for (var i = 0; i < mm1.Bindings.Count; i++)  										if (!compareBindings(mm1.Bindings[i]' mm2.Bindings[i]))  											return false;    									break;  							}    							return true;  						};    						for (var i = 0; i < e1.Bindings.Count; i++)  						{  							var b1 = e1.Bindings[i];  							var b2 = e2.Bindings[i];    							if (!compareBindings(b1' b2))  								return false;  						}    						return true;  					}    				case ExpressionType.New:  					{  						var e1 = (NewExpression)expr1;  						var e2 = (NewExpression)expr2;    						if (e1.Arguments.Count != e2.Arguments.Count)  							return false;    						if (e1.Members == null && e2.Members != null)  							return false;    						if (e1.Members != null && e2.Members == null)  							return false;    						if (e1.Constructor != e2.Constructor)  							return false;    						if (e1.Members != null)  						{  							if (e1.Members.Count != e2.Members.Count)  								return false;    							for (var i = 0; i < e1.Members.Count; i++)  								if (e1.Members[i] != e2.Members[i])  									return false;  						}    						for (var i = 0; i < e1.Arguments.Count; i++)  							if (!Compare(e1.Arguments[i]' e2.Arguments[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    				case ExpressionType.NewArrayBounds:  				case ExpressionType.NewArrayInit:  					{  						var e1 = (NewArrayExpression)expr1;  						var e2 = (NewArrayExpression)expr2;    						if (e1.Expressions.Count != e2.Expressions.Count)  							return false;    						for (var i = 0; i < e1.Expressions.Count; i++)  							if (!Compare(e1.Expressions[i]' e2.Expressions[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    				case ExpressionType.Parameter:  					{  						var e1 = (ParameterExpression)expr1;  						var e2 = (ParameterExpression)expr2;  						return e1.Name == e2.Name;  					}    				case ExpressionType.TypeIs:  					{  						var e1 = (TypeBinaryExpression)expr1;  						var e2 = (TypeBinaryExpression)expr2;  						return e1.TypeOperand == e2.TypeOperand && Compare(e1.Expression' e2.Expression' visited' queryableAccessorDic);  					}    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						var e1 = (BlockExpression)expr1;  						var e2 = (BlockExpression)expr2;    						for (var i = 0; i < e1.Expressions.Count; i++)  							if (!Compare(e1.Expressions[i]' e2.Expressions[i]' visited' queryableAccessorDic))  								return false;    						for (var i = 0; i < e1.Variables.Count; i++)  							if (!Compare(e1.Variables[i]' e2.Variables[i]' visited' queryableAccessorDic))  								return false;    						return true;  					}    #endif  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The following switch statement is missing a default case: switch (b1.BindingType)  							{  								case MemberBindingType.Assignment:  									return Compare(((MemberAssignment)b1).Expression' ((MemberAssignment)b2).Expression' visited' queryableAccessorDic);    								case MemberBindingType.ListBinding:  									var ml1 = (MemberListBinding)b1;  									var ml2 = (MemberListBinding)b2;    									if (ml1.Initializers.Count != ml2.Initializers.Count)  										return false;    									for (var i = 0; i < ml1.Initializers.Count; i++)  									{  										var ei1 = ml1.Initializers[i];  										var ei2 = ml2.Initializers[i];    										if (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)  											return false;    										for (var j = 0; j < ei1.Arguments.Count; j++)  											if (!Compare(ei1.Arguments[j]' ei2.Arguments[j]' visited' queryableAccessorDic))  												return false;  									}    									break;    								case MemberBindingType.MemberBinding:  									var mm1 = (MemberMemberBinding)b1;  									var mm2 = (MemberMemberBinding)b2;    									if (mm1.Bindings.Count != mm2.Bindings.Count)  										return false;    									for (var i = 0; i < mm1.Bindings.Count; i++)  										if (!compareBindings(mm1.Bindings[i]' mm2.Bindings[i]))  											return false;    									break;  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						path  = ConvertTo(path' typeof(BinaryExpression));  						var e = (BinaryExpression)expr;    						Path(e.Conversion' visited' path' ReflectionHelper.Binary.Conversion' func);  						Path(e.Left'       visited' path' ReflectionHelper.Binary.Left'       func);  						Path(e.Right'      visited' path' ReflectionHelper.Binary.Right'      func);    						break;  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					Path(  						((UnaryExpression)expr).Operand'  						visited'  						path = ConvertTo(path' typeof(UnaryExpression))'  						ReflectionHelper.Unary.Operand'  						func);  					break;    				case ExpressionType.Call:  					{  						path  = ConvertTo(path' typeof(MethodCallExpression));  						var e = (MethodCallExpression)expr;    						Path(e.Object'    visited' path' ReflectionHelper.MethodCall.Object'    func);  						Path(e.Arguments' visited' path' ReflectionHelper.MethodCall.Arguments' func);    						break;  					}    				case ExpressionType.Conditional:  					{  						path  = ConvertTo(path' typeof(ConditionalExpression));  						var e = (ConditionalExpression)expr;    						Path(e.Test'    visited' path' ReflectionHelper.Conditional.Test'    func);  						Path(e.IfTrue'  visited' path' ReflectionHelper.Conditional.IfTrue'  func);  						Path(e.IfFalse' visited' path' ReflectionHelper.Conditional.IfFalse' func);    						break;  					}    				case ExpressionType.Invoke:  					{  						path  = ConvertTo(path' typeof(InvocationExpression));  						var e = (InvocationExpression)expr;    						Path(e.Expression' visited' path' ReflectionHelper.Invocation.Expression' func);  						Path(e.Arguments'  visited' path' ReflectionHelper.Invocation.Arguments'  func);    						break;  					}    				case ExpressionType.Lambda:  					{  						path  = ConvertTo(path' typeof(LambdaExpression));  						var e = (LambdaExpression)expr;    						Path(e.Body'       visited' path' ReflectionHelper.LambdaExpr.Body'       func);  						Path(e.Parameters' visited' path' ReflectionHelper.LambdaExpr.Parameters' func);    						break;  					}    				case ExpressionType.ListInit:  					{  						path  = ConvertTo(path' typeof(ListInitExpression));  						var e = (ListInitExpression)expr;    						Path(e.NewExpression' visited' path' ReflectionHelper.ListInit.NewExpression' func);  						Path(e.Initializers'  visited' path' ReflectionHelper.ListInit.Initializers'  							(ex'p) => Path(ex.Arguments' visited' p' ReflectionHelper.ElementInit.Arguments' func));    						break;  					}    				case ExpressionType.MemberAccess:  					Path(  						((MemberExpression)expr).Expression'  						visited'  						path = ConvertTo(path' typeof(MemberExpression))'  						ReflectionHelper.Member.Expression'  						func);  					break;    				case ExpressionType.MemberInit:  					{  						Action<MemberBinding'Expression> modify = null; modify = (b'pinf) =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									Path(  										((MemberAssignment)b).Expression'  										visited'  										ConvertTo(pinf' typeof(MemberAssignment))'  										ReflectionHelper.MemberAssignmentBind.Expression'  										func);  									break;    								case MemberBindingType.ListBinding:  									Path(  										((MemberListBinding)b).Initializers'  										visited'  										ConvertTo(pinf' typeof(MemberListBinding))'  										ReflectionHelper.MemberListBind.Initializers'  										(p'psi) => Path(p.Arguments' visited' psi' ReflectionHelper.ElementInit.Arguments' func));  									break;    								case MemberBindingType.MemberBinding:  									Path(  										((MemberMemberBinding)b).Bindings'  										visited'  										ConvertTo(pinf' typeof(MemberMemberBinding))'  										ReflectionHelper.MemberMemberBind.Bindings'  										modify);  									break;  							}  						};    						path  = ConvertTo(path' typeof(MemberInitExpression));  						var e = (MemberInitExpression)expr;    						Path(e.NewExpression' visited' path' ReflectionHelper.MemberInit.NewExpression' func);  						Path(e.Bindings'      visited' path' ReflectionHelper.MemberInit.Bindings'      modify);    						break;  					}    				case ExpressionType.New:  					Path(  						((NewExpression)expr).Arguments'  						visited'  						path = ConvertTo(path' typeof(NewExpression))'  						ReflectionHelper.New.Arguments'  						func);  					break;    				case ExpressionType.NewArrayBounds:  					Path(  						((NewArrayExpression)expr).Expressions'  						visited'  						path = ConvertTo(path' typeof(NewArrayExpression))'  						ReflectionHelper.NewArray.Expressions'  						func);  					break;    				case ExpressionType.NewArrayInit:  					Path(  						((NewArrayExpression)expr).Expressions'  						visited'  						path = ConvertTo(path' typeof(NewArrayExpression))'  						ReflectionHelper.NewArray.Expressions'  						func);  					break;    				case ExpressionType.TypeIs:  					Path(  						((TypeBinaryExpression)expr).Expression'  						visited'  						path = ConvertTo(path' typeof(TypeBinaryExpression))'  						ReflectionHelper.TypeBinary.Expression'  						func);  					break;    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						path  = ConvertTo(path' typeof(BlockExpression));  						var e = (BlockExpression)expr;    						Path(e.Expressions' visited' path' ReflectionHelper.Block.Expressions' func);  						Path(e.Variables'   visited' path' ReflectionHelper.Block.Variables'   func); // ?    						break;  					}    #endif    				case ExpressionType.Constant :  					{  						path   = ConvertTo(path' typeof(ConstantExpression));  						var e  = (ConstantExpression)expr;  						var iq = e.Value as IQueryable;    						if (iq != null && !visited.Contains(iq.Expression))  						{  							visited.Add(iq.Expression);    							Expression p = Expression.Property(path' ReflectionHelper.Constant.Value);  							p = ConvertTo(p' typeof(IQueryable));  							Path(iq.Expression' visited' p' ReflectionHelper.QueryableInt.Expression' func);  						}    						break;  					}    				case ExpressionType.Parameter: path = ConvertTo(path' typeof(ParameterExpression)); break;  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									Path(  										((MemberAssignment)b).Expression'  										visited'  										ConvertTo(pinf' typeof(MemberAssignment))'  										ReflectionHelper.MemberAssignmentBind.Expression'  										func);  									break;    								case MemberBindingType.ListBinding:  									Path(  										((MemberListBinding)b).Initializers'  										visited'  										ConvertTo(pinf' typeof(MemberListBinding))'  										ReflectionHelper.MemberListBind.Initializers'  										(p'psi) => Path(p.Arguments' visited' psi' ReflectionHelper.ElementInit.Arguments' func));  									break;    								case MemberBindingType.MemberBinding:  									Path(  										((MemberMemberBinding)b).Bindings'  										visited'  										ConvertTo(pinf' typeof(MemberMemberBinding))'  										ReflectionHelper.MemberMemberBind.Bindings'  										modify);  									break;  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						var e = (BinaryExpression)expr;    						Visit(e.Conversion' func);  						Visit(e.Left'       func);  						Visit(e.Right'      func);    						break;  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					Visit(((UnaryExpression)expr).Operand' func);  					break;    				case ExpressionType.Call:  					{  						var e = (MethodCallExpression)expr;    						Visit(e.Object'    func);  						Visit(e.Arguments' func);    						break;  					}    				case ExpressionType.Conditional:  					{  						var e = (ConditionalExpression)expr;    						Visit(e.Test'    func);  						Visit(e.IfTrue'  func);  						Visit(e.IfFalse' func);    						break;  					}    				case ExpressionType.Invoke:  					{  						var e = (InvocationExpression)expr;    						Visit(e.Expression' func);  						Visit(e.Arguments'  func);    						break;  					}    				case ExpressionType.Lambda:  					{  						var e = (LambdaExpression)expr;    						Visit(e.Body'       func);  						Visit(e.Parameters' func);    						break;  					}    				case ExpressionType.ListInit:  					{  						var e = (ListInitExpression)expr;    						Visit(e.NewExpression' func);  						Visit(e.Initializers'  ex => Visit(ex.Arguments' func));    						break;  					}    				case ExpressionType.MemberAccess: Visit(((MemberExpression)expr).Expression' func); break;    				case ExpressionType.MemberInit:  					{  						Action<MemberBinding> modify = null; modify = b =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break;  								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break;  								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break;  							}  						};    						var e = (MemberInitExpression)expr;    						Visit(e.NewExpression' func);  						Visit(e.Bindings'      modify);    						break;  					}    				case ExpressionType.New            : Visit(((NewExpression)       expr).Arguments'   func); break;  				case ExpressionType.NewArrayBounds : Visit(((NewArrayExpression)  expr).Expressions' func); break;  				case ExpressionType.NewArrayInit   : Visit(((NewArrayExpression)  expr).Expressions' func); break;  				case ExpressionType.TypeIs         : Visit(((TypeBinaryExpression)expr).Expression'  func); break;    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						var e = (BlockExpression)expr;    						Visit(e.Expressions' func);  						Visit(e.Variables'   func);    						break;  					}    #endif    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					Visit(((ChangeTypeExpression)expr).Expression'  func); break;  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break;  								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break;  								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break;  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						var e = (BinaryExpression)expr;    						Visit(e.Conversion' func);  						Visit(e.Left'       func);  						Visit(e.Right'      func);    						break;  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					Visit(((UnaryExpression)expr).Operand' func);  					break;    				case ExpressionType.Call:  					{  						var e = (MethodCallExpression)expr;    						Visit(e.Object'    func);  						Visit(e.Arguments' func);    						break;  					}    				case ExpressionType.Conditional:  					{  						var e = (ConditionalExpression)expr;    						Visit(e.Test'    func);  						Visit(e.IfTrue'  func);  						Visit(e.IfFalse' func);    						break;  					}    				case ExpressionType.Invoke:  					{  						var e = (InvocationExpression)expr;    						Visit(e.Expression' func);  						Visit(e.Arguments'  func);    						break;  					}    				case ExpressionType.Lambda:  					{  						var e = (LambdaExpression)expr;    						Visit(e.Body'       func);  						Visit(e.Parameters' func);    						break;  					}    				case ExpressionType.ListInit:  					{  						var e = (ListInitExpression)expr;    						Visit(e.NewExpression' func);  						Visit(e.Initializers'  ex => Visit(ex.Arguments' func));    						break;  					}    				case ExpressionType.MemberAccess: Visit(((MemberExpression)expr).Expression' func); break;    				case ExpressionType.MemberInit:  					{  						Func<MemberBinding'bool> modify = null; modify = b =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break;  								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break;  								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break;  							}    							return true;  						};    						var e = (MemberInitExpression)expr;    						Visit(e.NewExpression' func);  						Visit(e.Bindings'      modify);    						break;  					}    				case ExpressionType.New            : Visit(((NewExpression)       expr).Arguments'   func); break;  				case ExpressionType.NewArrayBounds : Visit(((NewArrayExpression)  expr).Expressions' func); break;  				case ExpressionType.NewArrayInit   : Visit(((NewArrayExpression)  expr).Expressions' func); break;  				case ExpressionType.TypeIs         : Visit(((TypeBinaryExpression)expr).Expression'  func); break;    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						var e = (BlockExpression)expr;    						Visit(e.Expressions' func);  						Visit(e.Variables'   func);    						break;  					}    #endif    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					Visit(((ChangeTypeExpression)expr).Expression'  func);  					break;  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : Visit(((MemberAssignment)b). Expression'   func);                          break;  								case MemberBindingType.ListBinding   : Visit(((MemberListBinding)b).Initializers' p => Visit(p.Arguments' func)); break;  								case MemberBindingType.MemberBinding : Visit(((MemberMemberBinding)b).Bindings'   modify);                        break;  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						var e = (BinaryExpression)expr;    						return  							Find(e.Conversion' func) ??  							Find(e.Left'       func) ??  							Find(e.Right'      func);  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					return Find(((UnaryExpression)expr).Operand' func);    				case ExpressionType.Call:  					{  						var e = (MethodCallExpression)expr;    						return  							Find(e.Object'    func) ??  							Find(e.Arguments' func);  					}    				case ExpressionType.Conditional:  					{  						var e = (ConditionalExpression)expr;    						return  							Find(e.Test'    func) ??  							Find(e.IfTrue'  func) ??  							Find(e.IfFalse' func);  					}    				case ExpressionType.Invoke:  					{  						var e = (InvocationExpression)expr;    						return  							Find(e.Expression' func) ??  							Find(e.Arguments'  func);  					}    				case ExpressionType.Lambda:  					{  						var e = (LambdaExpression)expr;    						return  							Find(e.Body'       func) ??  							Find(e.Parameters' func);  					}    				case ExpressionType.ListInit:  					{  						var e = (ListInitExpression)expr;    						return  							Find(e.NewExpression' func) ??  							Find(e.Initializers'  ex => Find(ex.Arguments' func));  					}    				case ExpressionType.MemberAccess:  					return Find(((MemberExpression)expr).Expression' func);    				case ExpressionType.MemberInit:  					{  						Func<MemberBinding'Expression> modify = null; modify = b =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : return Find(((MemberAssignment)b).   Expression'   func);  								case MemberBindingType.ListBinding   : return Find(((MemberListBinding)b).  Initializers' p => Find(p.Arguments' func));  								case MemberBindingType.MemberBinding : return Find(((MemberMemberBinding)b).Bindings'     modify);  							}    							return null;  						};    						var e = (MemberInitExpression)expr;    						return  							Find(e.NewExpression' func) ??  							Find(e.Bindings'      modify);  					}    				case ExpressionType.New            : return Find(((NewExpression)       expr).Arguments'   func);  				case ExpressionType.NewArrayBounds : return Find(((NewArrayExpression)  expr).Expressions' func);  				case ExpressionType.NewArrayInit   : return Find(((NewArrayExpression)  expr).Expressions' func);  				case ExpressionType.TypeIs         : return Find(((TypeBinaryExpression)expr).Expression'  func);    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						var e = (BlockExpression)expr;    						return  							Find(e.Expressions' func) ??  							Find(e.Variables'   func);  					}    #endif    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					return Find(((ChangeTypeExpression)expr).Expression' func);  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment    : return Find(((MemberAssignment)b).   Expression'   func);  								case MemberBindingType.ListBinding   : return Find(((MemberListBinding)b).  Initializers' p => Find(p.Arguments' func));  								case MemberBindingType.MemberBinding : return Find(((MemberMemberBinding)b).Bindings'     modify);  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (BinaryExpression)expr;  						var c = Convert(e.Conversion' func);  						var l = Convert(e.Left'       func);  						var r = Convert(e.Right'      func);    #if FW3  						return c != e.Conversion || l != e.Left || r != e.Right ?  							Expression.MakeBinary(expr.NodeType' l' r' e.IsLiftedToNull' e.Method' (LambdaExpression)c):  							expr;  #else  						return e.Update(l' (LambdaExpression)c' r);  #endif  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (UnaryExpression)expr;  						var o = Convert(e.Operand' func);    #if FW3  						return o != e.Operand ?  							Expression.MakeUnary(expr.NodeType' o' e.Type' e.Method) :  							expr;  #else  						return e.Update(o);  #endif  					}    				case ExpressionType.Call:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (MethodCallExpression)expr;  						var o = Convert(e.Object'    func);  						var a = Convert(e.Arguments' func);    #if FW3  						return o != e.Object || a != e.Arguments ?   							Expression.Call(o' e.Method' a) :  							expr;  #else  						return e.Update(o' a);  #endif  					}    				case ExpressionType.Conditional:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (ConditionalExpression)expr;  						var s = Convert(e.Test'    func);  						var t = Convert(e.IfTrue'  func);  						var f = Convert(e.IfFalse' func);    #if FW3  						return s != e.Test || t != e.IfTrue || f != e.IfFalse ?  							Expression.Condition(s' t' f) :  							expr;  #else  						return e.Update(s' t' f);  #endif  					}    				case ExpressionType.Invoke:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (InvocationExpression)expr;  						var ex = Convert(e.Expression' func);  						var a  = Convert(e.Arguments'  func);    #if FW3  						return ex != e.Expression || a != e.Arguments ? Expression.Invoke(ex' a) : expr;  #else  						return e.Update(ex' a);  #endif  					}    				case ExpressionType.Lambda:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (LambdaExpression)expr;  						var b = Convert(e.Body'       func);  						var p = Convert(e.Parameters' func);    						return b != e.Body || p != e.Parameters ? Expression.Lambda(ex.Type' b' p.ToArray()) : expr;  					}    				case ExpressionType.ListInit:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (ListInitExpression)expr;  						var n = Convert(e.NewExpression' func);  						var i = Convert(e.Initializers'  p =>  						{  							var args = Convert(p.Arguments' func);  							return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  						});    #if FW3  						return n != e.NewExpression || i != e.Initializers ?  							Expression.ListInit((NewExpression)n' i) :  							expr;  #else  						return e.Update((NewExpression)n' i);  #endif  					}    				case ExpressionType.MemberAccess:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (MemberExpression)expr;  						var ex = Convert(e.Expression' func);    #if FW3  						return ex != e.Expression ? Expression.MakeMemberAccess(ex' e.Member) : expr;  #else  						return e.Update(ex);  #endif  					}    				case ExpressionType.MemberInit:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						Func<MemberBinding'MemberBinding> modify = null; modify = b =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									{  										var ma = (MemberAssignment)b;  										var ex = Convert(ma.Expression' func);    										if (ex != ma.Expression)  											ma = Expression.Bind(ma.Member' ex);    										return ma;  									}    								case MemberBindingType.ListBinding:  									{  										var ml = (MemberListBinding)b;  										var i  = Convert(ml.Initializers' p =>  										{  											var args = Convert(p.Arguments' func);  											return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  										});    										if (i != ml.Initializers)  											ml = Expression.ListBind(ml.Member' i);    										return ml;  									}    								case MemberBindingType.MemberBinding:  									{  										var mm = (MemberMemberBinding)b;  										var bs = Convert(mm.Bindings' modify);    										if (bs != mm.Bindings)  											mm = Expression.MemberBind(mm.Member);    										return mm;  									}  							}    							return b;  						};    						var e  = (MemberInitExpression)expr;  						var ne = Convert(e.NewExpression' func);  						var bb = Convert(e.Bindings'      modify);    #if FW3  						return ne != e.NewExpression || bb != e.Bindings ?  							Expression.MemberInit((NewExpression)ne' bb) :  							expr;  #else  						return e.Update((NewExpression)ne' bb);  #endif  					}    				case ExpressionType.New:  					{  						var ex = func(expr);  						if (ex != expr)  							return ex;    						var e = (NewExpression)expr;  						var a = Convert(e.Arguments' func);    #if FW3  						return a != e.Arguments ?  							e.Members == null ?  								Expression.New(e.Constructor' a) :  								Expression.New(e.Constructor' a' e.Members) :  							expr;  #else  						return e.Update(a);  #endif  					}    				case ExpressionType.NewArrayBounds:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (NewArrayExpression)expr;  						var ex = Convert(e.Expressions' func);    #if FW3  						return ex != e.Expressions ? Expression.NewArrayBounds(e.Type' ex) : expr;  #else  						return e.Update(ex);  #endif  					}    				case ExpressionType.NewArrayInit:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (NewArrayExpression)expr;  						var ex = Convert(e.Expressions' func);    #if FW3  						return ex != e.Expressions ?  							Expression.NewArrayInit(e.Type.GetElementType()' ex) :  							expr;  #else  						return e.Update(ex);    #endif  					}    				case ExpressionType.TypeIs:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (TypeBinaryExpression)expr;  						var ex = Convert(e.Expression' func);    #if FW3  						return ex != e.Expression ? Expression.TypeIs(ex' e.Type) : expr;  #else  						return e.Update(ex);  #endif  					}    #if FW4 || SILVERLIGHT    				case ExpressionType.Block:  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = (BlockExpression)expr;  						var ex = Convert(e.Expressions' func);  						var v  = Convert(e.Variables'   func);    						return e.Update(v' ex);  					}    #endif    				case ExpressionType.Constant : return func(expr);  				case ExpressionType.Parameter: return func(expr);    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					{  						var exp = func(expr);  						if (exp != expr)  							return exp;    						var e  = expr as ChangeTypeExpression;  						var ex = Convert(e.Expression' func);    						if (ex == e.Expression)  							return expr;    						if (ex.Type == e.Type)  							return ex;    						return new ChangeTypeExpression(ex' e.Type);  					}  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									{  										var ma = (MemberAssignment)b;  										var ex = Convert(ma.Expression' func);    										if (ex != ma.Expression)  											ma = Expression.Bind(ma.Member' ex);    										return ma;  									}    								case MemberBindingType.ListBinding:  									{  										var ml = (MemberListBinding)b;  										var i  = Convert(ml.Initializers' p =>  										{  											var args = Convert(p.Arguments' func);  											return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  										});    										if (i != ml.Initializers)  											ml = Expression.ListBind(ml.Member' i);    										return ml;  									}    								case MemberBindingType.MemberBinding:  									{  										var mm = (MemberMemberBinding)b;  										var bs = Convert(mm.Bindings' modify);    										if (bs != mm.Bindings)  											mm = Expression.MemberBind(mm.Member);    										return mm;  									}  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Add:  				case ExpressionType.AddChecked:  				case ExpressionType.And:  				case ExpressionType.AndAlso:  				case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  				case ExpressionType.Assign:  #endif  				case ExpressionType.Coalesce:  				case ExpressionType.Divide:  				case ExpressionType.Equal:  				case ExpressionType.ExclusiveOr:  				case ExpressionType.GreaterThan:  				case ExpressionType.GreaterThanOrEqual:  				case ExpressionType.LeftShift:  				case ExpressionType.LessThan:  				case ExpressionType.LessThanOrEqual:  				case ExpressionType.Modulo:  				case ExpressionType.Multiply:  				case ExpressionType.MultiplyChecked:  				case ExpressionType.NotEqual:  				case ExpressionType.Or:  				case ExpressionType.OrElse:  				case ExpressionType.Power:  				case ExpressionType.RightShift:  				case ExpressionType.Subtract:  				case ExpressionType.SubtractChecked:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as BinaryExpression;  						var c = Convert2(e.Conversion' func);  						var l = Convert2(e.Left'       func);  						var r = Convert2(e.Right'      func);    						return c != e.Conversion || l != e.Left || r != e.Right ?  							Expression.MakeBinary(expr.NodeType' l' r' e.IsLiftedToNull' e.Method' (LambdaExpression)c):  							expr;  					}    				case ExpressionType.ArrayLength:  				case ExpressionType.Convert:  				case ExpressionType.ConvertChecked:  				case ExpressionType.Negate:  				case ExpressionType.NegateChecked:  				case ExpressionType.Not:  				case ExpressionType.Quote:  				case ExpressionType.TypeAs:  				case ExpressionType.UnaryPlus:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as UnaryExpression;  						var o = Convert2(e.Operand' func);    						return o != e.Operand ?  							Expression.MakeUnary(expr.NodeType' o' e.Type' e.Method) :  							expr;  					}    				case ExpressionType.Call:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as MethodCallExpression;  						var o = Convert2(e.Object'    func);  						var a = Convert2(e.Arguments' func);    						return o != e.Object || a != e.Arguments ?  							Expression.Call(o' e.Method' ConvertMethodArguments(a' e.Method)) :   							expr;  					}    				case ExpressionType.Conditional:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as ConditionalExpression;  						var s = Convert2(e.Test'    func);  						var t = Convert2(e.IfTrue'  func);  						var f = Convert2(e.IfFalse' func);    						return s != e.Test || t != e.IfTrue || f != e.IfFalse ?  							Expression.Condition(s' t' f) :  							expr;  					}    				case ExpressionType.Invoke:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as InvocationExpression;  						var ex = Convert2(e.Expression' func);  						var a  = Convert2(e.Arguments'  func);    						return ex != e.Expression || a != e.Arguments ? Expression.Invoke(ex' a) : expr;  					}    				case ExpressionType.Lambda:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as LambdaExpression;  						var b = Convert2(e.Body'       func);  						var p = Convert2(e.Parameters' func);    						return b != e.Body || p != e.Parameters ? Expression.Lambda(ci.Expression.Type' b' p.ToArray()) : expr;  					}    				case ExpressionType.ListInit:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as ListInitExpression;  						var n = Convert2(e.NewExpression' func);  						var i = Convert2(e.Initializers'  p =>  						{  							var args = Convert2(p.Arguments' func);  							return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  						});    						return n != e.NewExpression || i != e.Initializers ?  							Expression.ListInit((NewExpression)n' i) :  							expr;  					}    				case ExpressionType.MemberAccess:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as MemberExpression;  						var ex = Convert2(e.Expression' func);    						return ex != e.Expression ? Expression.MakeMemberAccess(ex' e.Member) : expr;  					}    				case ExpressionType.MemberInit:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						Func<MemberBinding'MemberBinding> modify = null; modify = b =>  						{  							switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									{  										var ma = (MemberAssignment)b;  										var ex = Convert2(ma.Expression' func);    										if (ex != ma.Expression)  										{  											if (ex.Type != ma.Expression.Type)  											{  												ex = Expression.Convert(ex' ma.Expression.Type);  											}  											ma = Expression.Bind(ma.Member' ex);  										}    										return ma;  									}    								case MemberBindingType.ListBinding:  									{  										var ml = (MemberListBinding)b;  										var i  = Convert(ml.Initializers' p =>  										{  											var args = Convert2(p.Arguments' func);  											return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  										});    										if (i != ml.Initializers)  											ml = Expression.ListBind(ml.Member' i);    										return ml;  									}    								case MemberBindingType.MemberBinding:  									{  										var mm = (MemberMemberBinding)b;  										var bs = Convert(mm.Bindings' modify);    										if (bs != mm.Bindings)  											mm = Expression.MemberBind(mm.Member);    										return mm;  									}  							}    							return b;  						};    						var e  = expr as MemberInitExpression;  						var ne = Convert2(e.NewExpression' func);  						var bb = Convert2(e.Bindings'      modify);    						return ne != e.NewExpression || bb != e.Bindings ?  							Expression.MemberInit((NewExpression)ne' bb) :  							expr;  					}    				case ExpressionType.New:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e = expr as NewExpression;  						var a = Convert2(e.Arguments' func);    						return a != e.Arguments ?  							e.Members == null ?  								Expression.New(e.Constructor' ConvertMethodArguments(a' e.Constructor)) :  								Expression.New(e.Constructor' ConvertMethodArguments(a' e.Constructor' e.Members)' e.Members) :  							expr;  					}    				case ExpressionType.NewArrayBounds:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as NewArrayExpression;  						var ex = Convert2(e.Expressions' func);    						return ex != e.Expressions ? Expression.NewArrayBounds(e.Type' ex) : expr;  					}    				case ExpressionType.NewArrayInit:  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as NewArrayExpression;  						var et = e.Type.GetElementType();  						var ex = Convert2(e.Expressions' func)  							.Select(ee => et == typeof(object) && ee.Type.IsValueType ?  								Expression.Convert(ee' typeof(object)) :  								ee);    						return ex != e.Expressions ?  							Expression.NewArrayInit(et' ex) :  							expr;  					}    				case ExpressionType.TypeIs :  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as TypeBinaryExpression;  						var ex = Convert2(e.Expression' func);    						return ex != e.Expression ? Expression.TypeIs(ex' e.Type) : expr;  					}    #if FW4 || SILVERLIGHT    				case ExpressionType.Block :  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as BlockExpression;  						var ex = Convert2(e.Expressions' func);  						var v  = Convert2(e.Variables'   func);    						return ex != e.Expressions || v != e.Variables ? Expression.Block(e.Type' v' ex) : expr;  					}    #endif    				case ExpressionType.Constant : return func(expr).Expression;  				case ExpressionType.Parameter: return func(expr).Expression;    				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :  					{  						ci = func(expr);  						if (ci.Stop || ci.Expression != expr)  							return ci.Expression;    						var e  = expr as ChangeTypeExpression;  						var ex = Convert2(e.Expression' func);    						if (ex == e.Expression)  							return expr;    						if (ex.Type == e.Type)  							return ex;    						return new ChangeTypeExpression(ex' e.Type);  					}  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The following switch statement is missing a default case: switch (b.BindingType)  							{  								case MemberBindingType.Assignment:  									{  										var ma = (MemberAssignment)b;  										var ex = Convert2(ma.Expression' func);    										if (ex != ma.Expression)  										{  											if (ex.Type != ma.Expression.Type)  											{  												ex = Expression.Convert(ex' ma.Expression.Type);  											}  											ma = Expression.Bind(ma.Member' ex);  										}    										return ma;  									}    								case MemberBindingType.ListBinding:  									{  										var ml = (MemberListBinding)b;  										var i  = Convert(ml.Initializers' p =>  										{  											var args = Convert2(p.Arguments' func);  											return args != p.Arguments? Expression.ElementInit(p.AddMethod' args): p;  										});    										if (i != ml.Initializers)  											ml = Expression.ListBind(ml.Member' i);    										return ml;  									}    								case MemberBindingType.MemberBinding:  									{  										var mm = (MemberMemberBinding)b;  										var bs = Convert(mm.Bindings' modify);    										if (bs != mm.Bindings)  											mm = Expression.MemberBind(mm.Member);    										return mm;  									}  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Unwrap,The following switch statement is missing a default case: switch (ex.NodeType)  			{  				case ExpressionType.Quote          : return ((UnaryExpression)ex).Operand.Unwrap();  				case ExpressionType.ConvertChecked :  				case ExpressionType.Convert        :  					{  						var ue = (UnaryExpression)ex;    						if (!ue.Operand.Type.IsEnum)  							return ue.Operand.Unwrap();    						break;  					}  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetExpressionAccessors,The following switch statement is missing a default case: switch (e.NodeType)  				{  					case ExpressionType.Call           :  					case ExpressionType.MemberAccess   :  					case ExpressionType.New            :  						if (!accessors.ContainsKey(e))  							accessors.Add(e' p);  						break;    					case ExpressionType.Constant       :  						if (!accessors.ContainsKey(e))  							accessors.Add(e' Expression.Property(p' ReflectionHelper.Constant.Value));  						break;    					case ExpressionType.ConvertChecked :  					case ExpressionType.Convert        :  						if (!accessors.ContainsKey(e))  						{  							var ue = (UnaryExpression)e;    							switch (ue.Operand.NodeType)  							{  								case ExpressionType.Call           :  								case ExpressionType.MemberAccess   :  								case ExpressionType.New            :  								case ExpressionType.Constant       :    									accessors.Add(e' p);  									break;  							}  						}    						break;  				}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetExpressionAccessors,The following switch statement is missing a default case: switch (ue.Operand.NodeType)  							{  								case ExpressionType.Call           :  								case ExpressionType.MemberAccess   :  								case ExpressionType.New            :  								case ExpressionType.Constant       :    									accessors.Add(e' p);  									break;  							}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetRootObject,The following switch statement is missing a default case: switch (expr.NodeType)  			{  				case ExpressionType.Call         :  					{  						var e = (MethodCallExpression)expr;    						if (e.Object != null)  							return GetRootObject(e.Object);    						if (e.Arguments != null && e.Arguments.Count > 0 && e.IsQueryable())  							return GetRootObject(e.Arguments[0]);    						if (e.Arguments != null && e.Arguments.Count > 0  							&& e.Method.GetCustomAttributes(typeof(SqlFunctionAttribute)' true).Length == 0)  							for (int i = 0; i < e.Arguments.Count; i++)  							{  								var arg = e.Arguments[i];  								if (arg.Type == e.Type)  									return GetRootObject(arg);  							}    						break;  					}    				case ExpressionType.MemberAccess :  					{  						var e = (MemberExpression)expr;    						if (e.Expression != null)  							return GetRootObject(e.Expression.Unwrap());    						break;  					}  			}
Missing Default,BLToolkit.Linq,ExpressionHelper,C:\repos\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,FindLevel,The following switch statement is missing a default case: switch (expression.NodeType)  			{  				case ExpressionType.Call :  					{  						var call = (MethodCallExpression)expression;  						var expr = call.Object;    						if (expr == null && call.IsQueryable() && call.Arguments.Count > 0)  							expr = call.Arguments[0];    						if (expr != null)  						{  							var ex = FindLevel(expr' level' ref current);    							if (level == current)  								return ex;    							current++;  						}    						break;  					}    				case ExpressionType.MemberAccess:  					{  						var e = ((MemberExpression)expression);    						if (e.Expression != null)  						{  							var expr = FindLevel(e.Expression.Unwrap()' level' ref current);    							if (level == current)  								return expr;    							current++;  						}    						break;  					}  			}
Missing Default,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbType,The following switch statement is missing a default case: switch (dataType.SqlDbType)  			{  				case SqlDbType.BigInt           : return DbType.Int64;  				case SqlDbType.Binary           : return DbType.Binary;  				case SqlDbType.Bit              : return DbType.Boolean;  				case SqlDbType.Char             : return DbType.AnsiStringFixedLength;  				case SqlDbType.DateTime         : return DbType.DateTime;  				case SqlDbType.Decimal          : return DbType.Decimal;  				case SqlDbType.Float            : return DbType.Double;  				case SqlDbType.Image            : return DbType.Binary;  				case SqlDbType.Int              : return DbType.Int32;  				case SqlDbType.Money            : return DbType.Currency;  				case SqlDbType.NChar            : return DbType.StringFixedLength;  				case SqlDbType.NText            : return DbType.String;  				case SqlDbType.NVarChar         : return DbType.String;  				case SqlDbType.Real             : return DbType.Single;  				case SqlDbType.UniqueIdentifier : return DbType.Guid;  				case SqlDbType.SmallDateTime    : return DbType.DateTime;  				case SqlDbType.SmallInt         : return DbType.Int16;  				case SqlDbType.SmallMoney       : return DbType.Currency;  				case SqlDbType.Text             : return DbType.AnsiString;  				case SqlDbType.Timestamp        : return DbType.Binary;  				case SqlDbType.TinyInt          : return DbType.Byte;  				case SqlDbType.VarBinary        : return DbType.Binary;  				case SqlDbType.VarChar          : return DbType.AnsiString;  				case SqlDbType.Variant          : return DbType.Object;  				case SqlDbType.Xml              : return DbType.Xml;  				case SqlDbType.Udt              : return DbType.Binary;  				case SqlDbType.Date             : return DbType.Date;  				case SqlDbType.Time             : return DbType.Time;  #if !MONO  				case SqlDbType.Structured       : return DbType.Binary;  				case SqlDbType.DateTime2        : return DbType.DateTime2;  				case SqlDbType.DateTimeOffset   : return DbType.DateTimeOffset;  #endif  			}
Missing Default,BLToolkit.Mapping,MemberMapper,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbSize,The following switch statement is missing a default case: switch (dataType.SqlDbType)  			{  				case SqlDbType.BigInt           : return 0;  				case SqlDbType.Binary           : return 0;  				case SqlDbType.Bit              : return 0;  				case SqlDbType.Char             : return 0;  				case SqlDbType.DateTime         : return 0;  				case SqlDbType.Decimal          : return 0;  				case SqlDbType.Float            : return 0;  				case SqlDbType.Image            : return 0;  				case SqlDbType.Int              : return 0;  				case SqlDbType.Money            : return 0;  				case SqlDbType.NChar            : return 0;  				case SqlDbType.NText            : return 0;  				case SqlDbType.NVarChar         : return 0;  				case SqlDbType.Real             : return 0;  				case SqlDbType.UniqueIdentifier : return 0;  				case SqlDbType.SmallDateTime    : return 0;  				case SqlDbType.SmallInt         : return 0;  				case SqlDbType.SmallMoney       : return 0;  				case SqlDbType.Text             : return 0;  				case SqlDbType.Timestamp        : return 0;  				case SqlDbType.TinyInt          : return 0;  				case SqlDbType.VarBinary        : return 0;  				case SqlDbType.VarChar          : return 0;  				case SqlDbType.Variant          : return 0;  				case SqlDbType.Xml              : return 0;  				case SqlDbType.Udt              : return 0;  				case SqlDbType.Date             : return 0;  				case SqlDbType.Time             : return 0;  #if !MONO  				case SqlDbType.Structured       : return 0;  				case SqlDbType.DateTime2        : return 0;  				case SqlDbType.DateTimeOffset   : return 0;  #endif  			}
Missing Default,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDefaultNullValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(typeof(T)))  			{  				case TypeCode.Boolean:  return (T)(object)DefaultBooleanNullValue;  				case TypeCode.Byte:     return (T)(object)DefaultByteNullValue;  				case TypeCode.Char:     return (T)(object)DefaultCharNullValue;  				case TypeCode.DateTime: return (T)(object)DefaultDateTimeNullValue;  				case TypeCode.Decimal:  return (T)(object)DefaultDecimalNullValue;  				case TypeCode.Double:   return (T)(object)DefaultDoubleNullValue;  				case TypeCode.Int16:    return (T)(object)DefaultInt16NullValue;  				case TypeCode.Int32:    return (T)(object)DefaultInt32NullValue;  				case TypeCode.Int64:    return (T)(object)DefaultInt64NullValue;  				case TypeCode.SByte:    return (T)(object)DefaultSByteNullValue;  				case TypeCode.Single:   return (T)(object)DefaultSingleNullValue;  				case TypeCode.String:   return (T)(object)DefaultStringNullValue;  				case TypeCode.UInt16:   return (T)(object)DefaultUInt16NullValue;  				case TypeCode.UInt32:   return (T)(object)DefaultUInt32NullValue;  				case TypeCode.UInt64:   return (T)(object)DefaultUInt64NullValue;  			}
Missing Default,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  				{  					case TypeCode.Boolean:  return ConvertToNullableBoolean (value);  					case TypeCode.Byte:     return ConvertToNullableByte    (value);  					case TypeCode.Char:     return ConvertToNullableChar    (value);  					case TypeCode.DateTime: return ConvertToNullableDateTime(value);  					case TypeCode.Decimal:  return ConvertToNullableDecimal (value);  					case TypeCode.Double:   return ConvertToNullableDouble  (value);  					case TypeCode.Int16:    return ConvertToNullableInt16   (value);  					case TypeCode.Int32:    return ConvertToNullableInt32   (value);  					case TypeCode.Int64:    return ConvertToNullableInt64   (value);  					case TypeCode.SByte:    return ConvertToNullableSByte   (value);  					case TypeCode.Single:   return ConvertToNullableSingle  (value);  					case TypeCode.UInt16:   return ConvertToNullableUInt16  (value);  					case TypeCode.UInt32:   return ConvertToNullableUInt32  (value);  					case TypeCode.UInt64:   return ConvertToNullableUInt64  (value);  				}
Missing Default,BLToolkit.Mapping,MappingSchema,C:\repos\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The following switch statement is missing a default case: switch (Type.GetTypeCode(conversionType))  			{  				case TypeCode.Boolean:  return ConvertToBoolean (value);  				case TypeCode.Byte:     return ConvertToByte    (value);  				case TypeCode.Char:     return ConvertToChar    (value);  				case TypeCode.DateTime: return ConvertToDateTime(value);  				case TypeCode.Decimal:  return ConvertToDecimal (value);  				case TypeCode.Double:   return ConvertToDouble  (value);  				case TypeCode.Int16:    return ConvertToInt16   (value);  				case TypeCode.Int32:    return ConvertToInt32   (value);  				case TypeCode.Int64:    return ConvertToInt64   (value);  				case TypeCode.SByte:    return ConvertToSByte   (value);  				case TypeCode.Single:   return ConvertToSingle  (value);  				case TypeCode.String:   return ConvertToString  (value);  				case TypeCode.UInt16:   return ConvertToUInt16  (value);  				case TypeCode.UInt32:   return ConvertToUInt32  (value);  				case TypeCode.UInt64:   return ConvertToUInt64  (value);  			}
Missing Default,BLToolkit.EditableObjects,EditableXmlDocument,C:\repos\igor-tkachev_bltoolkit\Source\EditableObjects\EditableXmlDocument.cs,RejectChanges,The following switch statement is missing a default case: switch (nodeTrackBack.Action)  					{  						case XmlNodeChangedAction.Insert:  							if (nodeTrackBack.Node.NodeType == XmlNodeType.Attribute)  								((XmlElement)nodeTrackBack.Value).Attributes.Remove((XmlAttribute)nodeTrackBack.Node);  							else  								((XmlNode)nodeTrackBack.Value).RemoveChild(nodeTrackBack.Node);  							break;  						case XmlNodeChangedAction.Remove:  							// NB: The order of children nodes may change.  							//  							if (nodeTrackBack.Node.NodeType == XmlNodeType.Attribute)  								((XmlElement)nodeTrackBack.Value).Attributes.Append((XmlAttribute)nodeTrackBack.Node);  							else  								((XmlNode)nodeTrackBack.Value).AppendChild(nodeTrackBack.Node);  							break;  						case XmlNodeChangedAction.Change:  							nodeTrackBack.Node.Value = (string)nodeTrackBack.Value;  							break;  					}
Missing Default,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMemberType,The following switch statement is missing a default case: switch (memberInfo.MemberType)  			{  				case MemberTypes.Property    : return ((PropertyInfo)   memberInfo).PropertyType;  				case MemberTypes.Field       : return ((FieldInfo)      memberInfo).FieldType;  				case MemberTypes.Method      : return ((MethodInfo)     memberInfo).ReturnType;  				case MemberTypes.Constructor : return ((ConstructorInfo)memberInfo).DeclaringType;  			}
Missing Default,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsFloatType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.Single  :  				case TypeCode.Double  :  				case TypeCode.Decimal : return true;  			}
Missing Default,BLToolkit.Reflection,TypeHelper,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsIntegerType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.SByte  :  				case TypeCode.Byte   :  				case TypeCode.Int16  :  				case TypeCode.UInt16 :  				case TypeCode.Int32  :  				case TypeCode.UInt32 :  				case TypeCode.Int64  :  				case TypeCode.UInt64 : return true;  			}
Missing Default,BLToolkit.Reflection,StandardPropertyDescriptor,C:\repos\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessor.cs,CheckNull,The following switch statement is missing a default case: switch (Common.Configuration.CheckNullReturnIfNull)  					{  						case Common.Configuration.NullEquivalent.DBNull:  							return DBNull.Value;  						case Common.Configuration.NullEquivalent.Null:  							return null;  						case Common.Configuration.NullEquivalent.Value:  							return value;  					}
Missing Default,BLToolkit.ServiceModel,SerializerBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,ConvertToString,The following switch statement is missing a default case: switch (Type.GetTypeCode(type)) 				{ 					case TypeCode.Decimal  : return ((decimal) value).ToString(CultureInfo.InvariantCulture); 					case TypeCode.Double   : return ((double)  value).ToString(CultureInfo.InvariantCulture); 					case TypeCode.Single   : return ((float)   value).ToString(CultureInfo.InvariantCulture); 					case TypeCode.DateTime : return ((DateTime)value).ToString("o"); 				}
Missing Default,BLToolkit.ServiceModel,DeserializerBase,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,ReadValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  				{  					case TypeCode.Decimal  : return decimal. Parse(str' CultureInfo.InvariantCulture);  					case TypeCode.Double   : return double.  Parse(str' CultureInfo.InvariantCulture);  					case TypeCode.Single   : return float.   Parse(str' CultureInfo.InvariantCulture);  					case TypeCode.DateTime : return DateTime.ParseExact(str' "o"' CultureInfo.InvariantCulture);  				}
Missing Default,BLToolkit.ServiceModel,QuerySerializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Visit,The following switch statement is missing a default case: switch (e.ElementType)  				{  					case QueryElementType.SqlField :  						{  							var fld = (SqlField)e;    							if (fld != fld.Table.All)  							{  								GetType(fld.SystemType);    								if (fld.MemberMapper != null)  									GetType(fld.MemberMapper.MemberAccessor.TypeAccessor.OriginalType);  							}    							break;  						}    					case QueryElementType.SqlParameter :  						{  							var p = (SqlParameter)e;  							var t = p.Value == null ? p.SystemType : p.Value.GetType();    							if (p.Value == null || t.IsArray || t == typeof(string) || !(p.Value is IEnumerable))  							{  								GetType(t);  							}  							else  							{  								var elemType = TypeHelper.GetElementType(t);  								GetType(GetArrayType(elemType));  							}    							//if (p.EnumTypes != null)  							//	foreach (var type in p.EnumTypes)  							//		GetType(type);    							break;  						}    					case QueryElementType.SqlFunction         : GetType(((SqlFunction)        e).SystemType); break;  					case QueryElementType.SqlExpression       : GetType(((SqlExpression)      e).SystemType); break;  					case QueryElementType.SqlBinaryExpression : GetType(((SqlBinaryExpression)e).SystemType); break;  					case QueryElementType.SqlDataType         : GetType(((SqlDataType)        e).Type);       break;  					case QueryElementType.SqlValue            : GetType(((SqlValue)           e).SystemType); break;  					case QueryElementType.SqlTable            : GetType(((SqlTable)           e).ObjectType); break;  				}
Missing Default,BLToolkit.ServiceModel,QueryDeserializer,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\LinqServiceSerializer.cs,Parse,The following switch statement is missing a default case: switch ((QueryElementType)type)  				{  					case (QueryElementType)_paramIndex     : obj = _parameters = ReadArray<SqlParameter>(); break;  					case (QueryElementType)_typeIndex      : obj = ResolveType(ReadString());               break;  					case (QueryElementType)_typeArrayIndex : obj = GetArrayType(Read<Type>());              break;    					case QueryElementType.SqlField :  						{  							var systemType       = Read<Type>();  							var name             = ReadString();  							var physicalName     = ReadString();  							var nullable         = ReadBool();  							var primaryKeyOrder  = ReadInt();  							var isIdentity       = ReadBool();  							var isUpdatable      = ReadBool();  							var isInsertable     = ReadBool();  							var memberMapperType = Read<Type>();  							var memberMapperName = ReadString();  							var memberMapper     = memberMapperType == null ? null : Map.GetObjectMapper(memberMapperType)[memberMapperName];    							obj = new SqlField(  								systemType'  								name'  								physicalName'  								nullable'  								primaryKeyOrder'  								isIdentity  									? new DataAccess.IdentityAttribute()  									: isInsertable || isUpdatable  										? new DataAccess.NonUpdatableAttribute(isInsertable' isUpdatable' false)  										: null'  								memberMapper);    							break;  						}    					case QueryElementType.SqlFunction :  						{  							var systemType = Read<Type>();  							var name       = ReadString();  							var precedence = ReadInt();  							var parameters = ReadArray<ISqlExpression>();    							obj = new SqlFunction(systemType' name' precedence' parameters);    							break;  						}    					case QueryElementType.SqlParameter :  						{  							var name             = ReadString();  							var isQueryParameter = ReadBool();  							var dbType           = (DbType)ReadInt(); 							var dbSize           = ReadInt();  							var systemType       = Read<Type>();  							var value            = ReadValue(systemType);  							//var enumTypes        = ReadList<Type>();  							//var takeValues       = null as List<int>;    							/*  							var count = ReadCount();    							if (count != null)  							{  								takeValues = new List<int>(count.Value);    								for (var i = 0; i < count; i++)  									takeValues.Add(ReadInt());  							}    							var likeStart = ReadString();  							var likeEnd   = ReadString();  							*/    							obj = new SqlParameter(systemType' name' value' (MappingSchema)null' isQueryParameter)  							{  								DbType           = dbType' 								DbSize           = dbSize'  								//EnumTypes        = enumTypes'  								//TakeValues       = takeValues'  								//LikeStart        = likeStart'  								//LikeEnd          = likeEnd'  							};    							/*  							if (enumTypes != null && UnresolvedTypes.Count > 0)  								foreach (var et in enumTypes)  									if (et == null)  										throw new LinqException(  											"Query cannot be deserialized. The possible reason is that the deserializer could not resolve the following types: {0}. Use LinqService.TypeResolver to resolve types."'  											string.Join("' "' UnresolvedTypes.Select(_ => "'" + _ + "'").ToArray()));  							*/    							break;  						}    					case QueryElementType.SqlExpression :  						{  							var systemType = Read<Type>();  							var expr       = ReadString();  							var precedence = ReadInt();  							var parameters = ReadArray<ISqlExpression>();    							obj = new SqlExpression(systemType' expr' precedence' parameters);    							break;  						}    					case QueryElementType.SqlBinaryExpression :  						{  							var systemType = Read<Type>();  							var expr1      = Read<ISqlExpression>();  							var operation  = ReadString();  							var expr2      = Read<ISqlExpression>();  							var precedence = ReadInt();    							obj = new SqlBinaryExpression(systemType' expr1' operation' expr2' precedence);    							break;  						}    					case QueryElementType.SqlValue :  						{  							var systemType = Read<Type>();  							var value      = ReadValue(systemType);    							obj = new SqlValue(systemType' value);    							break;  						}    					case QueryElementType.SqlDataType :  						{  							var dbType     = (SqlDbType)ReadInt();  							var systemType = Read<Type>();  							var length     = ReadInt();  							var precision  = ReadInt();  							var scale      = ReadInt();    							obj = new SqlDataType(dbType' systemType' length' precision' scale);    							break;  						}    					case QueryElementType.SqlTable :  						{  							var sourceID           = ReadInt();  							var name               = ReadString();  							var alias              = ReadString();  							var database           = ReadString();  							var owner              = ReadString();  							var physicalName       = ReadString();  							var objectType         = Read<Type>();  							var sequenceAttributes = null as SequenceNameAttribute[];    							var count = ReadCount();    							if (count != null)  							{  								sequenceAttributes = new SequenceNameAttribute[count.Value];    								for (var i = 0; i < count.Value; i++)  									sequenceAttributes[i] = new SequenceNameAttribute(ReadString()' ReadString());  							}    							var all    = Read<SqlField>();  							var fields = ReadArray<SqlField>();  							var flds   = new SqlField[fields.Length + 1];    							flds[0] = all;  							Array.Copy(fields' 0' flds' 1' fields.Length);    							var sqlTableType = (SqlTableType)ReadInt();  							var tableArgs    = sqlTableType == SqlTableType.Table ? null : ReadArray<ISqlExpression>();    							obj = new SqlTable(  								sourceID' name' alias' database' owner' physicalName' objectType' sequenceAttributes' flds'  								sqlTableType' tableArgs);    							break;  						}    					case QueryElementType.ExprPredicate :  						{  							var expr1      = Read<ISqlExpression>();  							var precedence = ReadInt();    							obj = new SqlQuery.Predicate.Expr(expr1' precedence);    							break;  						}    					case QueryElementType.NotExprPredicate :  						{  							var expr1      = Read<ISqlExpression>();  							var isNot      = ReadBool();  							var precedence = ReadInt();    							obj = new SqlQuery.Predicate.NotExpr(expr1' isNot' precedence);    							break;  						}    					case QueryElementType.ExprExprPredicate :  						{  							var expr1     = Read<ISqlExpression>();  							var @operator = (SqlQuery.Predicate.Operator)ReadInt();  							var expr2     = Read<ISqlExpression>();    							obj = new SqlQuery.Predicate.ExprExpr(expr1' @operator' expr2);    							break;  						}    					case QueryElementType.LikePredicate :  						{  							var expr1  = Read<ISqlExpression>();  							var isNot  = ReadBool();  							var expr2  = Read<ISqlExpression>();  							var escape = Read<ISqlExpression>();    							obj = new SqlQuery.Predicate.Like(expr1' isNot' expr2' escape);    							break;  						}    					case QueryElementType.BetweenPredicate :  						{  							var expr1 = Read<ISqlExpression>();  							var isNot = ReadBool();  							var expr2 = Read<ISqlExpression>();  							var expr3 = Read<ISqlExpression>();    							obj = new SqlQuery.Predicate.Between(expr1' isNot' expr2' expr3);    							break;  						}    					case QueryElementType.IsNullPredicate :  						{  							var expr1 = Read<ISqlExpression>();  							var isNot = ReadBool();    							obj = new SqlQuery.Predicate.IsNull(expr1' isNot);    							break;  						}    					case QueryElementType.InSubQueryPredicate :  						{  							var expr1    = Read<ISqlExpression>();  							var isNot    = ReadBool();  							var subQuery = Read<SqlQuery>();    							obj = new SqlQuery.Predicate.InSubQuery(expr1' isNot' subQuery);    							break;  						}    					case QueryElementType.InListPredicate :  						{  							var expr1  = Read<ISqlExpression>();  							var isNot  = ReadBool();  							var values = ReadList<ISqlExpression>();    							obj = new SqlQuery.Predicate.InList(expr1' isNot' values);    							break;  						}    					case QueryElementType.FuncLikePredicate :  						{  							var func = Read<SqlFunction>();  							obj = new SqlQuery.Predicate.FuncLike(func);  							break;  						}    					case QueryElementType.SqlQuery :  						{  							var sid                = ReadInt();  							var queryType          = (QueryType)ReadInt();  							var from               = Read<SqlQuery.FromClause>();  							var readInsert         = ReadBool();  							var insert             = readInsert ? Read<SqlQuery.InsertClause>() : null;  							var readUpdate         = ReadBool();  							var update             = readUpdate ? Read<SqlQuery.UpdateClause>() : null;  							var readDelete         = ReadBool();  							var delete             = readDelete ? Read<SqlQuery.DeleteClause>() : null;  							var readSelect         = ReadBool();  							var select             = readSelect ? Read<SqlQuery.SelectClause>() : new SqlQuery.SelectClause(null);  							var where              = Read<SqlQuery.WhereClause>();  							var groupBy            = Read<SqlQuery.GroupByClause>();  							var having             = Read<SqlQuery.WhereClause>();  							var orderBy            = Read<SqlQuery.OrderByClause>();  							var parentSql          = ReadInt();  							var parameterDependent = ReadBool();  							var unions             = ReadArray<SqlQuery.Union>();  							var parameters         = ReadArray<SqlParameter>();    							var query = _query = new SqlQuery(sid) { QueryType = queryType };    							query.Init(  								insert'  								update'  								delete'  								select'  								from'  								where'  								groupBy'  								having'  								orderBy'  								unions == null ? null : unions.ToList()'  								null'  								parameterDependent'  								parameters.ToList());    							_queries.Add(sid' _query);    							if (parentSql != 0)  								_actions.Add(() =>  								{  									SqlQuery sql;  									if (_queries.TryGetValue(parentSql' out sql))  										query.ParentSql = sql;  								});    							query.All = Read<SqlField>();    							obj = query;    							break;  						}    					case QueryElementType.Column :  						{  							var sid        = ReadInt();  							var expression = Read<ISqlExpression>();  							var alias      = ReadString();    							var col = new SqlQuery.Column(null' expression' alias);    							_actions.Add(() => col.Parent = _queries[sid]);    							obj = col;    							break;  						}    					case QueryElementType.SearchCondition :  						obj = new SqlQuery.SearchCondition(ReadArray<SqlQuery.Condition>());  						break;    					case QueryElementType.Condition :  						obj = new SqlQuery.Condition(ReadBool()' Read<ISqlPredicate>()' ReadBool());  						break;    					case QueryElementType.TableSource :  						{  							var source = Read<ISqlTableSource>();  							var alias  = ReadString();  							var joins  = ReadArray<SqlQuery.JoinedTable>();    							obj = new SqlQuery.TableSource(source' alias' joins);    							break;  						}    					case QueryElementType.JoinedTable :  						{  							var joinType  = (SqlQuery.JoinType)ReadInt();  							var table     = Read<SqlQuery.TableSource>();  							var isWeak    = ReadBool();  							var condition = Read<SqlQuery.SearchCondition>();    							obj = new SqlQuery.JoinedTable(joinType' table' isWeak' condition);    							break;  						}    					case QueryElementType.SelectClause :  						{  							var isDistinct = ReadBool();  							var skipValue  = Read<ISqlExpression>();  							var takeValue  = Read<ISqlExpression>();  							var columns    = ReadArray<SqlQuery.Column>();    							obj = new SqlQuery.SelectClause(isDistinct' takeValue' skipValue' columns);    							break;  						}    					case QueryElementType.InsertClause :  						{  							var items = ReadArray<SqlQuery.SetExpression>();  							var into  = Read<SqlTable>();  							var wid   = ReadBool();    							var c = new SqlQuery.InsertClause { Into = into' WithIdentity = wid };    							c.Items.AddRange(items);  							obj = c;    							break;  						}    					case QueryElementType.UpdateClause :  						{  							var items = ReadArray<SqlQuery.SetExpression>();  							var keys  = ReadArray<SqlQuery.SetExpression>();  							var table = Read<SqlTable>();  							//var wid   = ReadBool();    							var c = new SqlQuery.UpdateClause { Table = table };    							c.Items.AddRange(items);  							c.Keys. AddRange(keys);  							obj = c;    							break;  						}    					case QueryElementType.DeleteClause :  						{  							var table = Read<SqlTable>();  							obj = new SqlQuery.DeleteClause { Table = table };  							break;  						}    					case QueryElementType.SetExpression : obj = new SqlQuery.SetExpression(Read<ISqlExpression>()' Read<ISqlExpression>()); break;  					case QueryElementType.FromClause    : obj = new SqlQuery.FromClause(ReadArray<SqlQuery.TableSource>());                 break;  					case QueryElementType.WhereClause   : obj = new SqlQuery.WhereClause(Read<SqlQuery.SearchCondition>());                 break;  					case QueryElementType.GroupByClause : obj = new SqlQuery.GroupByClause(ReadArray<ISqlExpression>());                    break;  					case QueryElementType.OrderByClause : obj = new SqlQuery.OrderByClause(ReadArray<SqlQuery.OrderByItem>());              break;    					case QueryElementType.OrderByItem :  						{  							var expression   = Read<ISqlExpression>();  							var isDescending = ReadBool();    							obj = new SqlQuery.OrderByItem(expression' isDescending);    							break;  						}    					case QueryElementType.Union :  						{  							var sqlQuery = Read<SqlQuery>();  							var isAll    = ReadBool();    							obj = new SqlQuery.Union(sqlQuery' isAll);    							break;  						}  				}
Missing Default,BLToolkit.ServiceModel,ServiceModelDataReader,C:\repos\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.String   : return value;  				case TypeCode.Double   : return double.  Parse(value' CultureInfo.InvariantCulture);  				case TypeCode.Decimal  : return decimal. Parse(value' CultureInfo.InvariantCulture);  				case TypeCode.Single   : return float.   Parse(value' CultureInfo.InvariantCulture);  				case TypeCode.DateTime : return DateTime.Parse(value' CultureInfo.InvariantCulture);  				case TypeCode.Object   :  					if (type == typeof(double?))   return double.        Parse(value' CultureInfo.InvariantCulture);  					if (type == typeof(decimal?))  return decimal.       Parse(value' CultureInfo.InvariantCulture);  					if (type == typeof(float?))    return float.         Parse(value' CultureInfo.InvariantCulture);  					if (type == typeof(DateTime?)) return DateTime.      Parse(value' CultureInfo.InvariantCulture);    					if (type == typeof(DateTimeOffset) || type == typeof(DateTimeOffset?))  						return DateTimeOffset.Parse(value' CultureInfo.InvariantCulture);  					break;  			}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  			{  				case BuildStep.Begin: BeginMethodBuild(); return;  				case BuildStep.End:   EndMethodBuild();   return;  			}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.BuildElement)  			{  				case BuildElement.Type:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildType(); break;  						case BuildStep.Build:          BuildType(); break;  						case BuildStep.After:     AfterBuildType(); break;  						case BuildStep.Catch:     CatchBuildType(); break;  						case BuildStep.Finally: FinallyBuildType(); break;  					}    					break;    				case BuildElement.AbstractGetter:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractGetter(); break;  						case BuildStep.Build:          BuildAbstractGetter(); break;  						case BuildStep.After:     AfterBuildAbstractGetter(); break;  						case BuildStep.Catch:     CatchBuildAbstractGetter(); break;  						case BuildStep.Finally: FinallyBuildAbstractGetter(); break;  					}    					break;    				case BuildElement.AbstractSetter:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractSetter(); break;  						case BuildStep.Build:          BuildAbstractSetter(); break;  						case BuildStep.After:     AfterBuildAbstractSetter(); break;  						case BuildStep.Catch:     CatchBuildAbstractSetter(); break;  						case BuildStep.Finally: FinallyBuildAbstractSetter(); break;  					}    					break;    				case BuildElement.AbstractMethod:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractMethod(); break;  						case BuildStep.Build:          BuildAbstractMethod(); break;  						case BuildStep.After:     AfterBuildAbstractMethod(); break;  						case BuildStep.Catch:     CatchBuildAbstractMethod(); break;  						case BuildStep.Finally: FinallyBuildAbstractMethod(); break;  					}    					break;    				case BuildElement.VirtualGetter:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualGetter(); break;  						case BuildStep.Build:          BuildVirtualGetter(); break;  						case BuildStep.After:     AfterBuildVirtualGetter(); break;  						case BuildStep.Catch:     CatchBuildVirtualGetter(); break;  						case BuildStep.Finally: FinallyBuildVirtualGetter(); break;  					}    					break;    				case BuildElement.VirtualSetter:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualSetter(); break;  						case BuildStep.Build:          BuildVirtualSetter(); break;  						case BuildStep.After:     AfterBuildVirtualSetter(); break;  						case BuildStep.Catch:     CatchBuildVirtualSetter(); break;  						case BuildStep.Finally: FinallyBuildVirtualSetter(); break;  					}    					break;    				case BuildElement.VirtualMethod:  					switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualMethod(); break;  						case BuildStep.Build:          BuildVirtualMethod(); break;  						case BuildStep.After:     AfterBuildVirtualMethod(); break;  						case BuildStep.Catch:     CatchBuildVirtualMethod(); break;  						case BuildStep.Finally: FinallyBuildVirtualMethod(); break;  					}    					break;    				case BuildElement.InterfaceMethod:  					BuildInterfaceMethod();  					break;  			}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildType(); break;  						case BuildStep.Build:          BuildType(); break;  						case BuildStep.After:     AfterBuildType(); break;  						case BuildStep.Catch:     CatchBuildType(); break;  						case BuildStep.Finally: FinallyBuildType(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractGetter(); break;  						case BuildStep.Build:          BuildAbstractGetter(); break;  						case BuildStep.After:     AfterBuildAbstractGetter(); break;  						case BuildStep.Catch:     CatchBuildAbstractGetter(); break;  						case BuildStep.Finally: FinallyBuildAbstractGetter(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractSetter(); break;  						case BuildStep.Build:          BuildAbstractSetter(); break;  						case BuildStep.After:     AfterBuildAbstractSetter(); break;  						case BuildStep.Catch:     CatchBuildAbstractSetter(); break;  						case BuildStep.Finally: FinallyBuildAbstractSetter(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildAbstractMethod(); break;  						case BuildStep.Build:          BuildAbstractMethod(); break;  						case BuildStep.After:     AfterBuildAbstractMethod(); break;  						case BuildStep.Catch:     CatchBuildAbstractMethod(); break;  						case BuildStep.Finally: FinallyBuildAbstractMethod(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualGetter(); break;  						case BuildStep.Build:          BuildVirtualGetter(); break;  						case BuildStep.After:     AfterBuildVirtualGetter(); break;  						case BuildStep.Catch:     CatchBuildVirtualGetter(); break;  						case BuildStep.Finally: FinallyBuildVirtualGetter(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualSetter(); break;  						case BuildStep.Build:          BuildVirtualSetter(); break;  						case BuildStep.After:     AfterBuildVirtualSetter(); break;  						case BuildStep.Catch:     CatchBuildVirtualSetter(); break;  						case BuildStep.Finally: FinallyBuildVirtualSetter(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step)  					{  						case BuildStep.Before:   BeforeBuildVirtualMethod(); break;  						case BuildStep.Build:          BuildVirtualMethod(); break;  						case BuildStep.After:     AfterBuildVirtualMethod(); break;  						case BuildStep.Catch:     CatchBuildVirtualMethod(); break;  						case BuildStep.Finally: FinallyBuildVirtualMethod(); break;  					}
Missing Default,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractGetter,The following switch statement is missing a default case: switch (index.Length)  			{  				case 0:  					Context.MethodBuilder.Emitter  						.ldarg_0  						.ldfld   (field)  						.stloc   (Context.ReturnValue)  						;  					break;    				case 1:  					Context.MethodBuilder.Emitter  						.ldarg_0  						.ldfld          (field)  						.ldarg_1  						.boxIfValueType (index[0].ParameterType)  						.callvirt       (typeof(Dictionary<object'object>)' "get_Item"' typeof(object))  						.castType       (Context.CurrentProperty.PropertyType)  						.stloc          (Context.ReturnValue)  						;  					break;  			}
Missing Default,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,C:\repos\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractSetter,The following switch statement is missing a default case: switch (index.Length)  			{  				case 0:  					Context.MethodBuilder.Emitter  						.ldarg_0  						.ldarg_1  						.stfld   (field)  						;  					//Context.MethodBuilder.Emitter.AddMaxStackSize(6);  					break;    				case 1:  					Context.MethodBuilder.Emitter  						.ldarg_0  						.ldfld          (field)  						.ldarg_1  						.boxIfValueType (index[0].ParameterType)  						.ldarg_2  						.boxIfValueType (Context.CurrentProperty.PropertyType)  						.callvirt       (typeof(Dictionary<object'object>)' "set_Item"' typeof(object)' typeof(object))  					;  					break;  			}
